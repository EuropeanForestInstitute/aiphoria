<html>

<head>
  <style>
    :root {
      --border: solid 1px #ccc;
      --border-radius: 6px;
      --box-shadow: 0px 0px 8px 0px rgba(0, 0, 0, 0.4);

      /* Tooltip menu origin (top left)*/
      --menu-x-default: 16px;
      --menu-y-default: 64px;
      --menu-x: var(--menu-x-default);
      --menu-y: var(--menu-y-default);

      /* Logo */
      --logo-x-default: 16px;
      --logo-y-default: 16px;
      --logo-x: var(--logo-x-default);
      --logo-y: var(--logo-y-default);

      /* UI Button padding */
      --pad-w: 0.5rem;
      --pad-h: 0.5rem;

      /* Window title */
      --title-background: #44caff;
      /* --highlight-background: #9090f080; */
      --highlight-background: #44caff;
      --highlight-transition-duration: 0.50s;


      /* Tooltip table */
      --table-border: solid 1px #ccc;
      --table-font-size-title: 12px;
      --table-font-size-data: 12px;

      /* Toast */
      --toast-transition-duration: 250ms;
      box-sizing: border-box;
    }

    * {}

    body {
      display: flex;
      box-sizing: border-box;
      margin: 0;

      width: 100vw;
      height: 100vh;
      flex-grow: 1;

      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }

    .toast {
      display: flex;
      column-gap: 1rem;
      right: 10px;
      top: 10px;
      min-width: 32px;
      min-height: 32px;
      padding: 0 1rem 0 1rem;
      position: fixed;
      z-index: 2000;
      background: #fff;
      color: #000;
      align-items: center;
      vertical-align: middle;
      justify-content: center;
      border-radius: 6px;
      border: solid 1px #aaa;
      box-shadow: 0px 0px 4px 0px rgba(0, 0, 0, 0.8);
      transform: translate(0, -200%);
      transition: all var(--toast-transition-duration) ease-in-out;
    }

    .toast-show {
      transform: translate(0, 0);
      transition: all var(--toast-transition-duration) ease-in-out;
    }

    .toast-hide {
      transform: translate(0, -200%);
      transition: all var(--toast-transition-duration) ease-in-out;
    }

    .toast-success {
      color: #000;
      background: #ffffff;
    }

    .toast-error {
      color: #000;
      background: #ff6060;
    }

    .loader-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .loader {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      display: inline-block;
      border-top: 6px solid #3281db;
      border-right: 6px solid transparent;
      box-sizing: border-box;
      animation: rotation 1.5s linear infinite;
    }

    @keyframes rotation {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    /*! Icons.css v0.1.0 | MIT License | github.com/picturepan2/icons.css */
    /*! Object icons are removed fully and part of the "Navigation" and "Action" icons */
    .icon {
      box-sizing: border-box;
      display: inline-block;
      font-size: inherit;
      font-style: normal;
      height: 1em;
      position: relative;
      text-indent: -9999px;
      vertical-align: middle;
      width: 1em;
    }

    .icon.icon-2x {
      font-size: 32px;
    }

    .icon.icon-3x {
      font-size: 48px;
    }

    .icon.icon-4x {
      font-size: 64px;
    }

    .icon::before,
    .icon::after {
      content: "";
      display: block;
      left: 50%;
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
    }

    .icon-back::after,
    .icon-forward::after {
      background: currentColor;
      height: .1rem;
      width: .8em;
    }

    .icon-back::after {
      left: 55%;
    }

    .icon-back::before {
      transform: translate(-50%, -50%) rotate(-45deg);
    }

    .icon-forward::after {
      left: 45%;
    }

    .icon-forward::before {
      transform: translate(-50%, -50%) rotate(135deg);
    }

    .icon-menu::before {
      background: currentColor;
      box-shadow: 0 -.35em, 0 .35em;
      height: .1rem;
      width: 100%;
    }

    .icon-check::before {
      border: .1rem solid currentColor;
      border-right: 0;
      border-top: 0;
      height: .5em;
      transform: translate(-50%, -.375em) rotate(-45deg);
      width: .9em;
    }

    .icon-close::before {
      background: currentColor;
      height: .1rem;
      width: 100%;
    }

    .icon-close::after {
      background: currentColor;
      height: 100%;
      width: .1rem;
    }

    .icon-close::before,
    .icon-close::after {
      transform: translate(-50%, -50%) rotate(45deg);
    }

    .icon-copy::before {
      border: .1rem solid currentColor;
      border-bottom-color: transparent;
      border-radius: .1em;
      border-right-color: transparent;
      height: .8em;
      left: 40%;
      top: 40%;
      width: .7em;
    }

    .icon-copy::after {
      border: .1rem solid currentColor;
      border-radius: .1em;
      height: .8em;
      left: 60%;
      top: 60%;
      width: .7em;
    }

    .icon-download {
      border-bottom: .1rem solid currentColor;
    }

    .icon-download::before {
      border: .1rem solid currentColor;
      border-bottom: 0;
      border-right: 0;
      height: .5em;
      transform: translate(-50%, -.3em) rotate(-135deg);
      width: .5em;
    }

    .icon-download::after {
      background: currentColor;
      height: .6em;
      top: 40%;
      width: .1rem;
    }

    .icon-edit::before {
      border: .1rem solid currentColor;
      height: .4em;
      transform: translate(-.35em, -.25em) rotate(-45deg);
      width: .85em;
    }

    .icon-edit::after {
      border: .15em solid currentColor;
      border-right-color: transparent;
      border-top-color: transparent;
      height: 0;
      left: 5%;
      top: 95%;
      transform: translate(0, -100%);
      width: 0;
    }

    .icon-refresh::before {
      border: .1rem solid currentColor;
      border-radius: 50%;
      border-right-color: transparent;
      height: 1em;
      width: 1em;
    }

    .icon-refresh::after {
      border: .2em solid currentColor;
      border-left-color: transparent;
      border-top-color: transparent;
      height: 0;
      left: 80%;
      top: 20%;
      width: 0;
    }

    .icon-search::before {
      border: .1rem solid currentColor;
      border-radius: 50%;
      height: .75em;
      left: 5%;
      top: 5%;
      transform: translate(0, 0) rotate(45deg);
      width: .75em;
    }

    .icon-search::after {
      background: currentColor;
      height: .1rem;
      left: 80%;
      top: 80%;
      transform: translate(-50%, -50%) rotate(45deg);
      width: .4em;
    }

    .icon-share {
      border: .1rem solid currentColor;
      border-radius: .1rem;
      border-right: 0;
      border-top: 0;
    }

    .icon-share::before {
      border: .1rem solid currentColor;
      border-left: 0;
      border-top: 0;
      height: .4em;
      left: 100%;
      top: .25em;
      transform: translate(-125%, -50%) rotate(-45deg);
      width: .4em;
    }

    .icon-share::after {
      border: .1rem solid currentColor;
      border-bottom: 0;
      border-radius: 75% 15%;
      border-right: 0;
      height: .6em;
      top: 55%;
      width: .6em;
    }

    /* Plotly */
    #plotly {
      flex-grow: 1;
      background: #aaa;
      width: 100vw;
      height: 100vh;
    }

    /* Overlay for loading */
    .overlay-wrapper {
      display: flex;
      flex-direction: column;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      padding: 0;
      margin: 0;
      z-index: 10000;
      background: #fff;
      transition: opacity 500ms ease-in-out;
    }

    .overlay-row-wrapper {
      align-items: center;
      justify-content: center;
      margin: auto auto auto auto;
    }

    .logo {
      width: 120px;
      z-index: 2000;
      aspect-ratio: auto;
    }

    .top-right {
      position: fixed;
      right: var(--logo-x);
      top: var(--logo-y);
    }

    select {
      min-height: 2rem;
    }

    /* New UI elements */
    .button-toggle-menu {
      display: block;

      position: absolute;
      bottom: 1rem;
      left: 1rem;

      border: solid 1px #aaa;
      border-radius: 8px;

      z-index: 2000;
      padding: var(--pad-h) var(--pad-w) var(--pad-h) var(--pad-w);
      font-size: 20px;

      user-select: none;
      cursor: pointer;
      color: #000;
      background: #eee;

      box-shadow: 0px 0px 4px 0px rgba(0, 0, 0, 0.5);
    }

    .button-toggle-menu:hover {
      outline: solid 2px #999;
    }

    .menu-wrapper {
      display: flex;
      flex-direction: column;

      left: var(--menu-x);
      top: var(--menu-y);

      align-items: center;
      row-gap: 1rem;
      height: fit-content;
      user-select: auto;
      z-index: 2000;
      background: #eee;

      box-shadow: 0px 0px 4px 0px rgba(0, 0, 0, 0.8);
      border-radius: 6px;
      overflow: hidden;
    }

    .menu-wrapper[data-show="true"] {
      display: flex;
      min-width: fit-content;
    }

    .menu-wrapper[data-show="false"] {
      display: none;
      padding: 0;
      width: 0px;
    }

    .menu-wrapper-controls-wrapper {
      width: 100%;
      min-height: 28px;
      background: #ccc;
      border-bottom: solid 1px #ccc;
      cursor: move;
    }

    .menu-wrapper-controls {
      position: absolute;
      cursor: pointer;
      border-radius: 50%;
      font-size: 12px;
      padding: 4px;
      top: 4px;
      right: 4px;
    }

    .menu-wrapper-controls:hover {
      outline: solid 2px #999;
    }

    .menu-wrapper-controls[data-variant="close"] {
      background: #fff;
    }

    .menu-content-wrapper {
      display: flex;
      flex-direction: column;
      user-select: auto;
      padding: 1rem;
      row-gap: 8px;
    }

    .menu-item-wrapper {
      display: flex;
      flex-direction: column;
      width: 100%;
      height: fit-content;
      background: #fff;
      padding: 4px;
      border-radius: 4px;
      user-select: none;
    }

    .menu-item-title {
      font-weight: bold;
      margin-bottom: 0.5rem;
    }

    .menu-item-content {
      display: flex;
      flex-direction: column;
      flex-grow: 1;

      max-height: 250px;
      overflow-y: auto;
    }

    .menu-item-content>table>tbody>tr>td>span {
      display: block;
    }

    .menu-actions-wrapper {
      display: flex;
      flex-direction: column;
      row-gap: 0.5rem;
    }

    .menu-actions-wrapper>button {
      flex-grow: 1;
      min-height: 1.5rem;
    }

    .global-menu-wrapper {
      display: flex;
      position: fixed;
      flex-direction: column;
      column-gap: 1rem;
      row-gap: 1rem;
      position: fixed;
      top: 1rem;
      left: 1rem;
      border-radius: 4px;
      z-index: 2000;
      font-weight: bold;
    }

    .menu-buttons-wrapper {
      display: flex;
      flex-direction: row;
      column-gap: 1rem;
      border-radius: 4px;
      z-index: 2000;
      font-weight: bold;
    }

    .menu-buttons-wrapper>* {
      /* font-size: 20px; */
      font-size: 16px;
    }

    .menu-button {
      display: block;
      border: solid 1px #aaa;
      border-radius: 8px;

      z-index: 2000;
      padding: var(--pad-h) var(--pad-w) var(--pad-h) var(--pad-w);

      user-select: none;
      cursor: pointer;
      color: #000;
      background: #eee;

      box-shadow: 0px 0px 4px 0px rgba(0, 0, 0, 0.5);
    }

    .menu-button[data-show="true"] {
      background: var(--highlight-background);
    }

    .menu-windows-wrapper {
      z-index: 2000;
    }

    .menu-window {
      display: none;
      flex-direction: column;
      border: solid 1px #aaa;
      background: #fff;
      border: var(--border);
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      overflow: hidden;
    }

    .menu-window[data-show="true"] {
      display: flex;
    }

    .menu-window[data-show="false"] {
      display: none;
    }

    .menu-window-title {
      display: flex;
      padding: 4px;
      background: #44caff;
      user-select: none;
    }

    .menu-window-controls {
      position: absolute;
      cursor: pointer;
      border-radius: 50%;
      font-size: 12px;
      padding: 4px;
      right: 4px;
    }

    .menu-window-controls:hover {
      /* outline: solid 2px #000; */
      background: white;
    }

    .menu-window-content {
      display: flex;
      flex-direction: column;
      padding: 0.5rem;
      min-width: 200px;
      float: right;
      background: #ffffff;
    }

    /* Tools window */

    .tabs-wrapper {
      display: flex;
      flex-direction: row;
      flex-grow: 1;
      text-align: center;
      border: solid 1px #aaa;
    }

    .tabs-wrapper> :first-child {
      user-select: none;
    }

    .tabs-wrapper> :not(:first-child):not(:last-child) {
      border-left: solid 1px #aaa;
      border-right: solid 1px #aaa;
    }

    .tabs-wrapper> :last-child {}

    .tab-item {
      flex-grow: 1;
      cursor: pointer;
      user-select: none;
    }

    .tab-item[data-show="true"] {
      background: #ddd;
      background: var(--title-background);
    }

    .tab-item[data-show="false"] {
      /* background: #fff; */
    }

    .tab-item-content {
      display: flex;
      flex-direction: column;
      width: 800px;
      max-height: 500px;
    }

    .tab-item-content[data-show="true"] {
      display: flex;
    }

    .tab-item-content[data-show="false"] {
      display: none
    }

    .tab-item-content-wrapper {
      flex-grow: 1;
      padding-top: 0.5rem;
    }

    /* Data tables for processes, flows, and stocks */
    .table-wrapper {
      display: flex;
      flex-direction: column;
      row-gap: 0.5rem;
      width: 100%;
      height: 100%;

      flex-grow: 1;
      /* height: 300px; */
      /* border: solid 1px red; */
    }

    .tab-table-wrapper {
      /* height: 350px; */
      /* height: 500px; */
      border: solid 1px #aaa;
      overflow-x: auto;
      font-size: 12px;
      line-height: 12px;
      max-height: 300px;
    }

    .tab-table {
      height: 100%;
      width: 100%;
      /* border-collapse: collapse; */
      border-collapse: separate;
      border-spacing: 0;
      table-layout: auto;
      overflow-x: auto;
    }

    .tab-table>thead {
      top: 0;
      position: sticky;
      text-align: left;
      background: #e0e0e0;
      user-select: none;
    }

    .tab-table>thead>tr>th {
      white-space: nowrap;
      padding-left: 0.5rem;
      padding-right: 0.5rem;
      font-size: 12px;
    }

    .tab-table>tbody>tr {
      width: fit-content;
      white-space: nowrap;
      background: #fff;
      font-size: 12px;
      user-select: none;
    }

    /* Color data rows between two colors */
    .tab-table>tbody>tr>td {
      width: fit-content;
      text-align: left;
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }

    .tab-table>tbody>tr:nth-child(odd) {
      background: #f0f0f0;
    }

    /* .tab-table>tbody>tr>td:nth-child(1) {
      cursor: pointer;
    } */

    /* Coloring cell for process has stock */
    .tab-table>tbody>tr>td[data-has-stock="true"] {
      color: #000;
      /* background: rgb(71, 236, 112); */
      background: #17ff1750;
      cursor: pointer;
    }

    /* Center text in td-elements where colspan is more that 1 */
    .tab-table>tbody>tr>td[colspan]:not([colspan="1"]) {
      text-align: center;
    }

    .tab-table-empty-message {
      background: #fff;
      padding: 4px;
    }

    /* Tooltip */
    .tooltip-wrapper {
      display: none;
      min-width: 100px;
      width: max-content;
      min-height: max-content;

      position: absolute;
      z-index: 1000;
      top: 300px;
      left: 300px;
      padding: 0.5rem;
      border-radius: 6px;
      box-shadow: 0px 0px 4px 0px rgba(0, 0, 0, 0.8);
      background: #fff;
    }

    .tooltip-wrapper[data-show="true"] {
      display: block;
    }

    .tooltip-wrapper[data-show="false"] {
      display: none;
    }

    .tooltip-info-wrapper {
      display: flex;
      flex-direction: column;
    }

    .tooltip-info-row {
      display: flex;
      flex-direction: row;
      column-gap: 10px;
    }

    .tooltip-info-col[data-show="true"] {
      display: flex;
      flex-direction: column;
    }

    .tooltip-info-col[data-show="false"] {
      display: none;
    }

    .tooltip-body-section {
      display: flex;
      flex-grow: 1;
      column-gap: 10px;
    }

    .tooltip-body-section[data-show="true"] {
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      column-gap: 10px;
    }

    .tooltip-body-section[data-show="false"] {
      display: none;
    }

    .tooltip-title {
      font-size: 16px;
      font-weight: bold;
    }

    .tooltip-type-title {
      font-size: 12px;
    }

    .tooltip-body-wrapper[data-show="true"] {
      display: flex;
      flex-direction: row;
      column-gap: 10px;
    }

    .tooltip-body-wrapper[data-show="false"] {
      display: none;
    }

    .tooltip-section-col {
      font-size: 14px;
      font-weight: normal;
      flex-grow: 1;
    }

    .tooltip-section-row {
      display: flex;
      flex-direction: row;
      column-gap: 10px;
    }

    .tooltip-table {
      border: var(--table-border);
      border-collapse: collapse;
    }

    .tooltip-table-title {
      font-size: 14px;
      font-weight: bold;
    }

    /* Table headings */
    .tooltip-table>thead>tr>th {
      font-size: var(--table-font-size-title);
      font-weight: bold;
      text-align: left;
      border: var(--table-border);
      min-width: max-content;
      padding: 0 4px 0 4px;
      background: #eee;
    }

    .tooltip-table>thead>tr>td {
      font-size: var(--table-font-size-data);
      text-align: left;
      border: var(--table-border);
      padding: 0 4px 0 4px;
    }


    .tooltip-table>tbody>tr {
      text-wrap: nowrap;
    }

    /* Table rows */
    .tooltip-table>tbody>tr>td {
      font-size: var(--table-font-size-data);
      text-align: left;
      border: var(--table-border);
      padding: 0 4px 0 4px;
      min-width: 100px;
      height: 18px;
    }

    .tooltip-table>thead>tr[data-show="true"] {
      width: 100%;
    }

    .tooltip-table>thead>tr[data-show="false"] {
      display: none;
    }

    /* Table row: input */
    .tooltip-table>tbody>tr>td>input {
      /* max-width: max-content; */
      font-size: var(--table-font-size-data);
      text-align: left;
      border: var(--table-border);
      padding: 0 4px 0 4px;
      width: 100%;
    }


    /* Tooltip content grid */
    .tooltip-content-grid {
      display: grid;
      grid-template-columns: auto auto;
      grid-template-rows: auto auto;
      /* margin: 1rem; */
      row-gap: 1rem;
      column-gap: 1rem;
    }

    .tooltip-content-grid-elem {
      /* height: 50px;
      width: 50px; */
      height: fit-content;
    }

    /* Tooltip, node and link evaluated value and unit */
    .tooltip-evaluated-value {
      font-size: 20px;
      font-weight: bold;
    }

    .tooltip-evaluated-value-unit {
      font-size: 20px;
      font-weight: bold;
    }

    .highlight {
      background-color: var(--highlight-background);
      transition: background-color var(--highlight-transition-duration);
    }

    /* Context menu */
    .context-menu-overlay {
      position: fixed;
      flex-grow: 1;
      width: 100vw;
      height: 100vh;
      z-index: 2500;
    }

    .context-menu-overlay[data-show="true"] {
      display: flex;
    }

    .context-menu-overlay[data-show="false"] {
      display: none;
    }

    .context-menu {
      display: none;
      position: absolute;
      width: fit-content;
      height: fit-content;
      min-width: 80px;
      top: 100px;
      left: 100px;
      z-index: 3000;
      font-size: 12px;
      background: #fff;
      border: solid 1px #aaa;
      border-radius: var(--border-radius);
      padding: 4px;
      white-space: nowrap;
    }

    .context-menu-item-title {
      user-select: none;
      font-size: 12px;
      font-weight: bold;
      padding: 2px 4px 2px 4px;
      border-bottom: solid 1px #000;
    }

    .context-menu-item {
      font-size: 12px;
      padding: 2px 4px 2px 4px;
    }

    .context-menu-item:hover {
      background: var(--highlight-background);
      cursor: pointer;
      user-select: none;
    }

    .context-menu[data-show="true"] {
      display: block;
    }

    /* Info window */
    .info-window-wrapper {
      display: flex;
      flex-direction: column;
      position: fixed;
      width: 100vw;
      height: 100vh;
      row-gap: 1rem;
      align-items: center;
      justify-content: center;
      z-index: 3000;
      backdrop-filter: blur(4px);
    }

    .info-window-wrapper[data-show="true"] {
      display: flex;
    }

    .info-window-wrapper[data-show="false"] {
      display: none;
    }

    .info-window {
      width: 80%;
      height: 80%;
      background: #fff;

      box-shadow: var(--box-shadow);
      border-radius: var(--border-radius);
      overflow: hidden;
    }

    .info-window-wrapper>button {
      width: 150px;
      height: 2rem;
      border: solid 1px #aaa;
      cursor: pointer;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      font-weight: bold;
    }
  </style>
  <script src="./plotly-3.0.0.min.js"></script>

  <!-- NOTE: Works only in dev server! -->
  <script src="./pako.min.js"></script>


  <script>
    // aiphoria logo
    const logoData = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAy4AAAE\u002fCAYAAACgppe8AADx20lEQVR4nOzddZgk53Xo4V9VM0z3MO\u002fszDJqV7LQtiSLWpaZu+2Ywg47ThwHb+gmccjxDd6YHVO3+VqWLLVtMVq4WsaZHWZqpqr7R3X3zq4WBqoHVud9nrFXu1NffT3dU1Xng3NACCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIcTapax0B4QQopJCkYAdaCp+1QEewApkgVlgFBgKB6MTK9ZJIYQQQlySBC5CiMtOKBLYCNwO3ApcAbQCVZz\u002fmpcHJoGTwOPAfcDj4WA0vTy9FUIIIcR8SOAihLhshCKBNwEfAW4B3Eto6ijwP8Dnw8HoiBl9E0IIIcTSSOAihFjzQpHAzcD\u002fBl5rctOjwD8C\u002fxoORrMmty2EEEKIBZDARQixZoUiASfwd8BHK3yqZ4CPhIPR5yt8HiGEEEJcgAQuQog1KRQJrAPCwKuX6ZRJ4NfDweiXl+l8QgghhJhDXekOCCHEQoUigS3AAyxf0ALGnpkvhSKBP13GcwohhBCiSGZchBBrSigSaAceBDatYDf+KhyM\u002fvkKnl8IIYR4xZHARQixZoQiAQfwE8zfhL8Yvx8ORv95pTshhBBCvFLIUjEhxFrySVZH0ALwT6FI4J0r3QkhhBDilUJmXIQQa0IoErgV+OlK9+Mc08BrwsHooZXuiBBCCHG5k8BFCLHqhSIBK\u002fAEcM1K9+U8fgbcFA5GMyvdESGEEOJyJkvFhBBrwftYnUELwLUYxS+FEEIIUUEy4yKEWNWKsy3PAHtXuCuX8uZwMPrDle6EEEIIcbmSGRchxGp3B5UJWu7HWOZlls+GIoGVTNEshBBCXNZkxkUIsaqFIoEwEKxA03cAR4BngSaT2hwAngcOAY8CT4SD0SmT2hZCCCFe0SRwEUKsWqFIoA44CtSZ3HQPsDscjMZDkcDtwI8Aq8nnABgCvgv8RzgYPVyB9oUQQohXDAlchBCrUigS8AMfAP6tAs1\u002fNhyM\u002fsqcc\u002f0G8O8VOE9Jutj+X4WD0VgFzyOEEEJctiRwEUKsCqFIwAHcALweo8jkFqChQqd7UzgYveec838G+OUKna\u002fkEPDhcDD6TIXPI4QQQlx2KrE0Qggh5i0UCTQDv4Axu7JtGU55CnjoPH\u002f\u002fWxjB0s0VPPcO4MFQJPDBcDD63QqeRwghhLjsyIyLEGJFFNMcfxT4Ayo3s3I+fx0ORv\u002fXBfrUAjwMbK5wHzTg\u002feFg9BsVPo8QQghx2ZB0yEKIZReKBDZjzHr8I8sbtEwBn7nQP4aD0SHgbcBwhfuhAv8TigReX+HzCCGEEJcNCVyEEMsqFAlcj5Eq+DUrcPp\u002fCwej\u002fRf7hnAwegh4MzBW4b5Yga+GIoGtFT6PEEIIcVmQwEUIsWxCkcBe4B7Mq5uyEEeAf5rPN4aD0WeBu4DBivbISPP8hVAkYKvweYQQQog1TwIXIcSyCEUC1cDXgdoVOL0O\u002fMZCUhGHg9HngFuA\u002fRXrleHVwCcqfA4hhBBizZPARQixXP4G2L5C5\u002f5EOBh9YKEHhYPRYxhZxr5jfpfO8oehSGBLhc8hhBBCrGkSuAghKi4UCVwJ\u002fMolv7EyPh0ORv9xsQeHg9GpcDD6LowMaAnTenU2D\u002fCnFWpbCCGEuCxI4CKEWA6\u002fxcrUjfqXcDD6u2Y0FA5G\u002fw9wLcYenUoIhiKBXRVqWwghhFjzJHARQlRUKBJoAt6yzKctAB8LB6MfM7PRcDB6KByMvgkjZfLTZrYN2Fm5WSkhhBBi1ZPARQhRaTdiZM9aLgeAW8PB6L9U6gThYPT\u002fYWyqfwPwXWDWpKbfGYoEakxqSwghhLisrMTSDSHEK8vNy3SeSeDTwD+Hg9FkpU8WDkY14EfAj0KRQDtGBrLbgauADsC3iGZbgdcB3zOpm0IIIcRlQwIXIUSlXVHh9vuA\u002fwH+KxyMDlT4XOdVLGr5FeAroUjAipHyOYwRzCzUG5HARQghhHgZZaU7IIS4fIUiATdGHZQNJjc9AjwGfAu4LxyMzpjc\u002fpKFIoEHMWZPFuowsDccjGbN7ZEQQgixtsmMixCikrwsbsnU+eSAfwGiwIvhYHTCpHZNF4oE2oA9izy8E2Op2QnTOiSEEEJcBiRwEUJUkhNwmNTWFPBX4WC0UrVUzHQ9sNhN9i5gIxK4CCGEEGeRrGJCiEpSMG9JahzQTWqr0l63xOO7zOiEEEIIcTmRwEUIUUl5jJoqZhhfjmxhSxWKBGwsblP+XM1m9EUIIYS4nEjgIoSopFTxywz9JrVTaVuKX0th1r4gIYQQ4rIhgYsQopLSmBe4HDepnUq7DrAtsQ3ZfyiEEEKcQwIXIUQl6YBmUlsvmdROpV1jQhtpE9oQQgghLisSuAghKsmGkVlsqfIY9WDWgh0mtDFpQhtCCCHEZUUCFyFEJXVizkbz06yB9MDFgpvtJjS1VvbzCCGEEMtGAhchRCX9LmAxoZ0nw8GoWXtlKqkK8JvQzkkT2hBCCCEuK7IBVAhhulAkYAf+AfiwSU3ea1I7leZi6UvjJpDARQghhHgZmXERQpgqFAncDjwF\u002fI5JTY4DD5jUVqWpLP26ejgcjI6a0RkhhBDiciIzLkIIU4QigfXA3wA\u002fZ3LTPwoHoyMmt1kpWSCHMfOyWE+Z1BchhBDisiIzLkKIJQtFAr8KPIf5QQvA5yvQZqUkil9L8ZgZHRFCCCEuNzLjIoRYtFAkUA\u002f8N\u002fCOCp3i0XAw+nCF2q6EGWAEaFnk8ZPA0+Z1RwghhLh8yIyLEGJRQpHATozZgUoFLQD\u002fWMG2TRcORjXg6BKasABek7ojhBBCXFYkcBFCLFgoErgS+CmwtYKniYaD0bsr2H6lPLmEY\u002f3Ap03qhxBCCHFZkcBFCLEgoUhgA3A30FTB02SBP6pg+5X0CKAt4fg3hiKBj5rUFyGEEOKyIYGLEGLeivVZvgq0VfhUnwwHo89X+ByV8lLxayn+LhQJXG1GZ4QQQojLhQQuQoiF+GPghgqf41Hgryt8jooJB6MFILLEZpzAZ0KRwFLSKgshhBCXFQlchBDzEooENgG\u002fV+HTDAMfDgej+Qqfp9K+jpFhbCmuBP7ShL4IIYQQlwUJXIQQ8\u002fVbVDbjVRoIhYPRUxU8x7IIB6O9wNdMaOpjoUig0jNcQgghxJoggYsQ4pJCkUAD8N4KnqIAvG+N1Wy5lH8GYktswwJ80oS+CCGEEGueBC5CiPl4I9BQobazQDAcjH6vQu2viOLM0adNaOqmUCQQMqEdIYQQYk2TwEUIMR9vr1C7E8Abw8HodyrU\u002fkr7B+CICe18PBQJWExoRwghhFizJHARQlxUKBKoBa6rQNMvAjeFg9GfVKDtVSEcjMaBj5rQ1FXAnSa0I4QQQqxZErgIIS5lO+YXm\u002fwccGM4GD1kcrurTjgYvR\u002f4FxOa+rAJbQghhBBrlgQuQohL2WViW33Au8PB6C8XZyNeKf4IeHqJbdwaigQazeiMEEIIsRZJ4CKEuJRNJrSRB\u002f4duCocjH7bhPbWlHAwmgE+hLGnZ7HqgGvN6ZEQQgix9kjgIoS4lJYlHKsD9wI3hIPR3woHo+Mm9WnNCQejR4FfWmIz15vRFyGEEGItksBFCHEpSyk6+evhYPSN4WD0WdN6s4aFg9HvA3+yhCZ2mNQVIYQQYs2RwEUIcSlLuU6EQpGA07SeXAbCwejfAl9d5OHNZvZFCCGEWEskcBFCXEpqCcfeDPydWR25jDy\u002fyOPcUs9FCCHEK5UELkKISxlb4vG\u002fE4oEXmNKTy4DoUjgauB\u002fL6EJ3ay+CCGEEGuJBC5CiEvpXuLxCvDnZnRkrQtFAi7gs4B7kU3EwsGoZmKXhBBCiDVDAhchxKXsN6GNO2TWBYC\u002fAPYu4fgBc7ohhBBCrD0SuAghLmU\u002fMGVCOx8yoY01KxQJXAt8bInNmBFECiGEEGuSBC5CiIsKB6NDwDMmNHVnKBKoMqGdtepvAesS23jCjI4IIYQQa5EELkKI+YiY0EYHsNuEdtacUCTwNuC2JTbTC0g9HCGEEK9YErgIIebj+xgPzku114Q21qLfN6GNH4SD0ZgJ7QghhBBrkgQuQohLCgejk0DUhKY2mdDGmhKKBG4BlpqYoAB8wYTuCCGEEGuWBC5CiPnqMqGNBhPaWGvMSErwvXAw+oIJ7QghhBBrlgQuQohLCkUCrZizzMtmQhtrRigSqAECS2wmh7GxXwghhHhFk8BFCDEfnwTqTGgnbUIba8k1QMsS2\u002fhPmW0RQgghJHARQlxCKBIIAB8wqblhk9pZK5a6t6Ub+CszOiKEEEKsdRK4CCEu5U9MbOuYiW2tBXuWePwniokRhBBCiFc8CVyEEBcUigReB9xkUnM68KJJba16oUhABdYtsZnrzOiLEEIIcTmQwEUIcTEfNLGtE8BhE9tb7ZxA9RLb+L1QJPAWE\u002foihBBCrHkSuAghzisUCfiAO0xs8r5wMJoysb3Vzoo5WdT+MRQJeE1oRwghhFjTJHARQlzIHqDdpLZ04CsmtbVWFIpfS7UF+IgJ7QghhBBrmgQuQogLeZWJbd0fDkafMbG9tSAFTJvU1q+HIoEqk9oSQggh1iQJXIQQF7LDxLb+zsS21oRwMKoBfSY11wW83qS2hBBCiDVJAhchxIW0mdTO\u002f4SD0UdMamutedHEtt5pYltCCCHEmiOBixDiQvwmtDEA\u002fKEJ7axVZgZs18tyMSGEEK9kErgIIS7EusTjdeCXwsHokBmdWaOeBk6b1NZ6YJtJbQkhhBBrjgQuQogLSS\u002fx+I+Gg9H7TOnJGhUORmPAN01scoOJbQkhhBBrigQuQogLmVjCsVmgMRQJbDarM2vYZ4CESW21mNSOEEIIseZI4CKEuJDuJRxrB\u002f4E2BeKBMKhSOB6k\u002fq05oSD0RPA501qrs6kdoQQQog1RwIXIcSF7DOhDRcQBJ4IRQLfCkUCu0xocy36e2DUhHbkmi2EEOIVS26CQogLeRZjyZcZFOBdwDOhSOCvQ5GAw6R214RwMDqIOdnVUia0IYQQQqxJErgIIS7kKLDf5DadwJ8Cj4YigZ0mt72qhYPRLwJfWmIzIyZ0RQghhFiTJHARQpxXsfL7tyvU\u002fDXAY6FI4E0Van+1+nXgiSUcb1ZqZSGEEGLNkcBFCHExXwNmKtR2NfD9UCQQrFD7q044GE0B7wV6F3F4Cjhlbo+EEEKItUMCFyHEBYWD0T7gcxU8hQX4aigSCFTwHKtKOBjtBT4MaAs89DSLC3iEEEKIy4IELkKIS\u002fl7YKCC7VuBr4UigS0VPMdqY2Ph198nwsGoWckShBBCiDVHAhchxEWFg9Ex4HcrfJp64DOhSOCVck361UUc8yPTeyGEEEKsIdaV7oAQYvULB6PfCkUC\u002fwz8XgVPczPwSxiV5hckFAn8E7AbyJnYHzvwdDgY\u002fTMT2yQUCewA3riQYxSUSbvF9piZ\u002fRBCCCHWGglchBDzEg5Gfz8UCTQB76\u002fgaX4vFAl8NRyMJhd43K3AlRXoj70Cbf4msKA6NoqiPP7ld\u002f1wuAJ9EUIIIdaMV8qyDCGEOT5EZTfrbwHuWsRxGbM7UmTqnpJQJLAV42e4IBZF\u002fbqZ\u002fRBCCCHWIglchBDzFg5GtXAw+svAx6hcsPDuCrW7GvwvwL2QAxRF6fFa3fdUqD9CCCHEmiGBixBiwcLB6L8ArwYeqkDz14ciAW8F2l1RoUjgTuB9Cz3OgvrF\u002f3r7t2MV6JIQQgixpkjgIoRYlHAw+nw4GL0FCAHPmth0G7DexPZWXCgS8ACfWsShs8CXzO2NEEIIsTbJ5nwxL6FIwA38NVDLwgvnXZSOTq6Qo83bqu2pv+KvfunVf9hnZvuissLBaCQUCXwLuBMjK9idgGcJTVqBDcBBE7q3WvwJsGMRx0W++p4fSdFJIdaoYOSO69D5jTs7A4U2bxu5Qo4fdv9Qm0xP6aqiKgttT9M13e\u002fwK2\u002fZ8CbVYXFwcOKQ9dHBx5767nsf+o9K9F+I1UYCFzFfDuAXgGozG9V0IwbaWruVqxqvpMpW9Z+ABC5rTDgY1TDqjPwoFAn8IkvfwL956b1aHUKRwO3AJxZxaAb4V5O7I4RYRgrKloJe+EAsG0NVVGwWG1V2HxPpycW1pygkc0mS+RROq4s6Vx1Oi7MOkMBFvCLIUjExXzqQMrPBvJanyu7llnWv43XtN+Oz+wp5LWfqbI5YEY+x9GxcV5nRkZUWigQ6MZZ6LeZa+\u002fVwMHrA1A4JIZZbHgWGkyPouo6qqLR5W9F1fVGNKShkChmGEkMA1DprWedtr1SiFCFWHQlcxLLTdA1d19lWu5U3db2JTdWbyn+fzC+0fIdYhXqAU0tsY2coEljT16dQJOADvomxZ2eh4sDfmdsjIcRKUFAYTY6SLqTRdZ02TxtOqxOdRQYvikLvbC+armFVrFzZWIkSVkKsTmv6wUCsLTo6eS1PtaOa2ztu46a2m3DbjMywsWyMh\u002fsf1r99\u002fLsy47LGhYPRDPDEEpvZAnQuvTcrIxQJODCClmsW2cS\u002fhoPR4yZ2SQixQlRFJZaNMZIcAcDn8NHmaaWgLe52pyoqI8lRpjPTKIpCtbPaxN4KsbpJ4CKWRUEvYFFU9jTs4U0b3kinvxMAXdc4PHGYH576ISemT6IoC96rKFanHy3xeDfwOhP6sexCkYAL+DZGkoLFOAn8g3k9EkKsNE3XOTVtTEQrKGyp2YJlkfe70nKxk9OnUBV10cvOhFiLJHARFaXrOgWtQIunhbs67+L6lutwWBwAjKfGiZ7+MY8OPkYyn8KqWlGQwOUy8QgwtsQ23mVGR5ZTKBJoAO4F3rSEZv4gHIzOmNQlIcQqYFFV+uL9TGem0dFp9bbS6G6koBcW1Z6qqJycOUEyl0RV5FFOvHLIp11UTF7L47Q6uKH1el7feSdN7iZ0dLKFLM8OP8s93ffSF+vHoljkwnuZCQejo8CPl9jMbaFIYKcZ\u002fVkOoUhgL\u002fAwS5sp+ko4GP2uKR0SQqwaCgrpfJrjU8dRFRWLamFH3WIypBtURWUmM8vJmZNYVUkQK1455GlRmE7TNTRdY1P1Rt604U3srt+NRbEA0Dvbyz3d9\u002fLc6PPk9TwW1bLCvRUV9JUlHm8Hfs+MjlRaKBL4JeBRYPsSmukGPmZOj4QQq41FsXBs+jiz2Vl0XWd91XqaljjrcnjyCFPpKZN7KsTqJYGLME1p873f7uPWdbdwy7pb8Nv9ACRycR4ZeIQf9\u002f6EifSkLAt7Zfgp8NIS2\u002fhwKBK41YzOVEIoEugKRQLfAT4LeJfQlAb8SjgYHTenZ0KI1UZRFBK5BIcmDqEqKlaLlT31exZ9L1QVldnsLA\u002f3P2JyT4VYvSRwEaYo6AUUFHbX7+JNG97ExuqNKCgU9AKHJw5z96kfcmTyKAoKFlkW9ooQDkZzwH8usRkF+FwoEmg3oUumCUUCvlAk8MfA88A7TGjyT8LB6E9MaEcIsYpZVAtHp44xkZoAHTp861hf1UFeyy+qPQWlnK1MiFcCeYIUS1KaZal31nHn+gA3tNyA0+oEzt58n8glZR3uK9PXgBNLbKML+GEoElhvQn+WJBQJ1IYigd8F9gF\u002fA1Sb0OzXwsHoJ01oRwixypX2urww9iI6OgoqVzVdZdR1WWR2MNkjKl5J5NMuFq2gF1BR2duwhzd0vYE2r1FnL6fleG7kOe7pvpd+2Xz\u002fihYORs0qpLgHeDwUCbzdhLYWIg8QigSuCEUC\u002fwDsBz6FeTVmHgN+xaS2hBBrgFW10j3TzenZ0yiKQr2rnt31uxe910WIVxIZAheLktfy1LvquK75Otqr2tF0o5DWYGKQnw0\u002fw2hyFItqkc33AuBLwC8Cr15iO23Ad0ORwL3AvwIPFYtdgrFHpBJ2hiKBh4DXYPL1UlWUE1bF+p7\u002fefc9STPbFUKsDc+OPEezpxmHxcGuup0MxPoZSg6Xk9kIIV5OhsHFgpQyhu2s21GeZdF1I8XxU8NPc3\u002fP\u002fYylxmTzvSgLB6MaRrasxS3ifrk3APcBL4Uigf8KRQIhwGdS2+fqAG7G5KBFQRm2q7a3\u002fc+77xkys10hxNqgKiqT6UleHN2HqijYVBvXt1yP0+KQgpJCXIQELmJeFBTyWh6X1cUt617Ha1pfg8PiQFFgID7APd338NLYS2joMlokXiYcjD4N\u002fLXJzW4BPgJ8A9hlctsVo6CMOiy2N3\u002fpXT88uNJ9EUKsHItq4dDkIXpn+1AUhQZ3A9c0XYNWsQlkIdY+WSom5mUkOcKehj1c33wtta46dN3YlP\u002fi2IscGD9AXi\u002fI5ntxKX+NsVzszpXuyEpRUHodFttbvvSuH+5b6b4IIVaWgoKmazw59BS1zlrcNjdba7cykZ7g4MQhuacKcR4y4yLm5cM7PsQdHbdT7awBYCI9wX099\u002fHC6IsyyyLmJRyM6sCHgGMr3ZeVoCrKi06L\u002fRYJWoQQJaqiMp2Z5omhJ8p7Ra9tvpZ1Ve2LTpEsxOVMAhcxL42eRiyqBQWFo5NHubf7RwwnR2Qvi1iQcDA6ArwdGF7pviyzrztUx01ffNfdp1a6I0KI1cXIMtbD86PPo6BgVa3c1HYTDa568ppkGhNiLglcxLxUO6rJFXI8MfgEjww8SqaQlVkWsSjhYPQQ8CbglVA1TQP+KByM\u002ftwX3\u002fWD2Ep3RgixOllUC\u002fvGXuLw5GFURcVj83Brx63UOqslTbIQc0jgIublwPh+ftRzHwcnD6EqKqoisyxi8cLB6HPAHcDlPANxErhDiksKIS5FQUFRFJ4aepqT0ydRFAW\u002f3c\u002ftHbdT46iRmRchiiRwEfNyb899ylhqzFHhWRYryLqzV4pwMLofuAl4ZKX7UgFfAK4NB6MPrHRHhBArat43TQWFgl7g0YHHODVzCh2dakc1d64P0OppvliaZLs5XRVi9ZOUFWJe7Ko9jrGx2g1UKsm8DpyuUNtiFQoHowOhSOAO4O+Bj65wd8xwEPiDcDB670p3RAixKjwCvBeY15SJqqikC2meG3mejqr1FlVRqHPVc13L9dx96u7ztWEBes3ssBCrmYxuCyFWhVAkcBfwKWDbSvdloRSUcR39Uzr8n0gwmlzp\u002fgghhBCXIwlchBCrRigS8GLMvHwUqFvRzsyDgjKkKurnHRbbf37hnT8YWun+CCGEEJczCVyEEKtOKBJoBX4N+HmgbYW7cz4vAp\u002fzWF3f+Pw7\u002f9\u002fkSndGCCGEeCWQwEUIsWqFIoEa4G3A+4EbANdynVtHR9d1VMXIYaKg9KqKcrem618v6NrT3wz9WNL8CCGEEMtIAhchxJoQigQ2A7cBdwLXA81mta2jo+laOWuPqqh4bR6cVtfYTGb6c6qi\u002ftRtcT7z3+\u002f47qxZ5xRCCCHEwkjgIoRYc0KRQC2wB7iq+PVGwF\u002f697mBiKKoWJQLZ37X0bGpNmodNXjtVdQ5a6lx1hDLxhiID9z\u002fD2\u002f4\u002fOsr\u002fXqEEEIIcWkSuAgh1rxQJPAExlIyCnqB9VUdbK3ZQk7LM5Ya4+DEofKSr3Ppus7N7TexqXoTVtXCeGqCZ0eeozfWS0Ev\u002fPhboZ8GlvO1CCGEEOL8pI6LEOJycNYgjKqobKjeCEBNsoYjk0fOW3xI0zXqXXV0+bsAODp1jMcHHiddyGBVrVS44KoQQgghFuDC6yeEEGINUlCYTE+RzCXJa3mq7FX4HH40XXvZ9+q6js\u002fuw6paSeVTPDX0FBkti1WVMR0hhBBitZHARQhxWVEVlVg2xlhqDAUFh8VBl6\u002fzvIELCiRySTS9gN1ip6OqAwWFvJanoBco6JI4TAghhFgtJHARQlx2CrrG8anjgLEcbFP1Jtw2dzlrWIlFsTCWGqMv1o\u002fdYuc1ra\u002fh9Z13srt+F+3eNprdTSvRfSGEEEKch6yHEEJcdiyqyulYL+Opcepd9fgdfnbUbufZkeewKmdf9jRd47GBx9B1nQ5fB52+TtZXrSev59F1nX\u002fj6yv0KoQQQggxl8y4CCEuOwoK2UKOfWP70NEp6AV21e2iyd34suVfqqKSzKf4ad8D3NdzPwcmDjCWGiNbyKDJUjEhhBBi1ZAZFyHEZcmqWuie7aFntocN\u002fg2oFpXXtL6GH\u002fXcR6aQOSs9cunP\u002ffF++mP92Cw2XFYXNtmkL4QQQqwal+VdORQJ2IEaoK74\u002f37ADdgx0qbmgRQwC0wCE8BkOBhNrUiHhZinUCRgA2oxPtt1nPlsl36X80ASiAHTVtU6Hei4ffKD130sthL9XS46OsoFylI9M\u002fwMja5G3DY3De4Gbmq\u002fkQf7HiKv5V9W28WiWEAxasHEspX\u002fkYUiAXdOy9W2eVr9d3YGGhVU9496fuQYSY66VEXVgSzG+zkDTAETbqt7+gvv\u002fH6m4p17hQlFAlagCqjGuG\u002f4AC\u002fgAmw6OhbFwh0dt2td\u002fq5UMpeMF\u002fTCrKqoU08PPT35V3\u002f9HzM8hkzRrWLFwrWNQD3Ge+wBLIDO2c8Fo8BQOBidXpmeipLU+Gk12v9Tv4JSpyhKrYJSDfhURbX3zHZzYPwgw8mRTLqQLt7zbON21Tbx7fc+MLPCXRcVclkUoAxFAp0Y1bOvAa4AujAuTj7AdonDC0AcGAO6gZeAnwHPhoPRUxXqshDzEooEmjE+29cBVwIbgSbm8dnWdK3gt\u002ftSb9n4limHxXH6xbEXDz859NQzDovjGeBIOBhNV7r\u002fy+Xnv\u002fOWp5L51HXnC17yWp4uXye3dtyKoihYFAs9sz080v8o6UL6UrVafhwORk0pQJmbHrLef\u002fr+LTaL\u002fdr7e+5\u002fVX98YKeqqOs1Xavz2X3ut258i81pdfJg30McmzqOVX1Zv3JATNO18RvbXtu\u002frXbb0Wwh86ym6z\u002f76E9\u002f5+DJj82cr1SNOI9QJOADNgG7Me4ZW4EOoAHjd8vJeZZS6+hUO6q5qvFKOn2dAGi6lk7lUzMvjL4wcnTq2OmCXjhsU237gP3AyXAwmlyWFyVeJhQJbAFeDbwG433uwBj4sV\u002fi0CwwDhwDHge+Gw5Gn69gV0VRKBKoyWuFvfWuuute1XjVlU2eps1Oi6NFUVS\u002fpmsuXdfRi1W5CnqBVC7FdGaasdQYY6kxpjLTyWQuOVXQC\u002f0KyiFVUZ9RFfVp4NDldM97JVuzgUsoEtgLvAV4PcYFyWPyKZIYQcy9wPfDwej+pTb4qv\u002fbZb913S0fv6H1hnq31a3p6NhUG9lChvt67mc4OXLB6t4XYQNeCAejX1xq\u002f+bj3pe+8gsOq2NvX6wv9+PTPyGv5y840r0AFmAY+KdwMJpfei8vLhQJBIA3Y9yczGIFPh8ORl9aakPv\u002f9YbOvJa\u002fo3AWzGC8drFtGNUkF\u002fPHetvR0Hhgb4HODlzCoti0YATwMPA94FHwsFofKn9Xkn\u002f9dj\u002f\u002ftmjg49dU9AL5\u002f085rU8O+t28OrWV1MaOR9LjvH44OOMJEexKBYU5byf4yUFLqFIwALckC1k33p9y3V37G3Yu0NRFNvTQ0\u002fz4tg+rKoVHR2rYuUtG95Mvbuel8Ze4vHBJy5YS0bTNeqctdzVdRd2ix0gP5IYef6e7nvv0XTt7m+\u002f94EXFtvfy1UoElCAncCtwG0YgwBtLGKfZymtdpe\u002fi6sar6TWWYuma2i6xunZ07w4to\u002fx1DgWxZJXFKUXeBb4CfBQOBg9btZrWkmPHP6eEs\u002fFP3Z48vC6F0ZfKCTySayqDcvC719zqRgzi\u002f+wlGCvOJD5zuLXlRhB6FI9Hg5GX7vYg9\u002f29ZvqVdTft6gWu0WxLGiAQUfHaXFyQ8v1bKzeiKqo5LQ8uvE5tBe0wnfetOdDDy22b6tBKBJoBALA2zACzRYAm2rFY\u002fNQ7aihwVVfTrTisjpRFYsRwBR\u002fmoqiUNAKpPIpJtOTDCdHGEkOM5WeJl1Ia7qun1AU5QEF5Tuqoj4aDkaXPGsdigTeBNypo2c9Vjdt3jaa3E3UOmvx2r04LU4sqqV8T9J0DR2dUvA1NwgrUoBCQS986k1XfGhoqf27XK2ppWKhSKAKeBfwC8ANGA+8leIGri9+\u002fa9QJPAo8Fnge4uN2j961e\u002fUVNm9f+ywON0oYFWsTKQneGb4WUZTY4sJWkq+ASxL4GJVrcG+2b7A44OPmxW0lPQBn8aYrq+0LcBvVqDd4xjB7oJ97HsfUN689a13Hp48\u002fEuPDDx6B8ao75Louk6DuwGLYiGdTzGRniy9XyrGz2AL8MtAdygS+CbwpXAwemSp510JG6o3MJIc4cDEwfM+8FtVK4cmDwNwfcv1aGjUu+q5q+suDo4f5NDkYRK5BIqioirKkj\u002fXH\u002f72mxvShcz7gA8Dey2qhcn0JGA8iNS76suBkoJCVssylZmi3m3cnC9WAFNVVMZS4zwz\u002fCw3tr0WTdesTZ6ma69s3Hvt8yMv\u002fHkwcscTCspngW+\u002f0kf7iyPu7wTeAezFhHte6Tp9cvokg\u002fFBdtbtYGfdDpxWFxurN9Je1c6RySPsHz9gTeQSGyyqdYMC7wHSoUjgGeA7GINhp5fal5Vy0\u002fa36\u002fft\u002f9o7t9duv6HR3cjJ6ZP0zJ4mnoujKupS7mUF4EtAz0IPDEUCrwJ+B+Pht2qxHbiA3FIOvrntpprx1PgnhhJDxHMJNF2b989JQSFTyPDE0JOcmulmU\u002fVGWj2tOKwOI2BWCoPAQ0vp30oJRQI3YNyD3oyxfO8sWS1HJj3FRGqSE9MnsKgW3FYX1Y5qGlwNNLobqXHW4LF6sCgWVEXFY\u002fPgsXno8HVQ0ArEc3FGk6PqYGJwy2hydEssG\u002f9IVssdefvXb\u002f6fdD795R998OnBJbyEIPB+BYVkPsWJ6ZN0z\u002fZgV204rU5cVjcemwevzYPb6sZtc+O0OHFYHNgsNqyKFVVVUYvjJ4qioOu6XtAK\u002f7WEPl321kTgYv8bvG\u002fouulXCrr2m6qidJn4sDxfVuCW4teRUCTwKeDL4WB0QSP2Nc6aWqtqtVoUC6l8isMThzkwcYB0PoPl5ctCFmLZboDPjz6fPjhx6GWbm02wnPuLTlao3ebFHPTDfV9+h0W1\u002fEEyn7zu6NRRCrq21JFLwNiv0eRuBGA2O0s8G7\u002fQrEIX8Angd0KRwLcxZr72LbkDy0jTNa5quorR1ChjyfHz\u002fj5ZFAsHJw6RyCW4ofUGfHYfNtXGVU1XsblmEyenT9Ez28N0ZpqslntZzZf5uHvfFze6rO7feHro6fe9OL6vqbQMTUFhNhsjr+exYsVn92FVrGhoKCjous5YaoxN1ZuodlTjtXmZzc5e8HfMqlo5OnWUOlctO+t2UtAKXNV4FXktr7409tJrVdX6WgX+OBQJfBLjWvWKWUZWnF25E\u002fgIxiiuqxLnsapWsoUsz448x6mZbq5s2EuXvwuHxcGehj10+jp5cexFTkyfpKAXsCgWJ3Bj8euvQ5HAvcB\u002fh4PRByvRv0qbTE\u002f2Vjv8N7R6W2nxtLCnYQ\u002fds90cmzrORHoC4FLLMM9HxZhh7pnvAQ8d+nZD+FjkL8dTE7+iKqrF5PtSyXmq187f7vrdenFJoXMkOUJvrI\u002fhxBCxbJyCXkBVVJRLDJhkChm6Z7vpnu2mxlHNBv8GNvg34LF5lmOwz1ShSOBWjHvORWezFRTjnjXnx5LMpYjnEvTF+lEVFafVSbWjmkZXgzHb4ao9K5Dx2X34HX421WwiW8gyk5lhODG8bSgx\u002fLdTmanfD4bv+Pyx6WP\u002f8sJHTi9mhuOs1RA6OnktT66QI55LoDNevo+UXotFsWBVrdhVG3aLHYfFgd3iwG6xYVPt2FTrkMfqmVxEX14xVn3g8qP9X\u002fnwiemTf9If6980m50lkU+SLWQpaAVjQ27xl738Aa+8bcBngF8PRQJ\u002fHA5GfzTfA50WZ0Mqn7IfnTnKgfEDTGWmsSiWpQYtACNLbWC+nht9XlviiNpqMIRxIzL7RbQt5Jvv3velayyK5ZOKotxqVa08N\u002fIcA\u002fHBi462z5ema1TZvdQ6jevqaHKMnJa7VNtO4P3Ae0KRwBeAvw4Ho0sZjVo2peUUN7ffzP09UWK52HkfmqyqlZ7ZXibTk1zVeBUbqjegKipeWxV7G\u002feys34ns5lZpjPTxLIxclqOb\u002fPAJc\u002f\u002fvRc+V2232P9YVdRfA7xZLWvcsOZcktL5NPlCDovVgtPqxGaxkclnQDFG2kaTY+S1HA6Lg0Z3A9OZ6Yv+niko\u002fGz4Z3htXtb71lPQClzbfC2qovLi2D5URd2qoHwR+HAoEvidtRaMLkYoEngH8HGMmfKKUxQFq2JlOjPNg\u002f0Pcmz6OFc1XkmTuwm\u002fw89NbTex0b+R50afYzgxMndJYhXGaG0wFAk8AvxjOBj94XL02Sx3n7p7oNZZx5aazXT6OqmyV7GnYQ9ba7bSF+vj8ORhhhMjaGgLCWAUjP2p8xI98I33pArpT93ecXvbiekTHJs6Xg74Tb5HLSk4KAUnbpubLn8Xnb5O0oU0E6lx+uMDDCWGjQGTQhZFUVBRX\u002fY8o6CUf47TmRmeHXmOgxOH8Dt8ayYhRCgS2AH8Dcas2KIoioIFS\u002fnamslnGMoPMRgfLAcyNY5qmtxN5WVbbpsbVVGxW+zlmZrd9btI5lO1k+nJj9+Qvf7DH3nc+febqzd\u002f5tad71lIVpaGC\u002fWxHISe81iqoZPVsmQKGchRXio2Z6BsKpaNJRbQh1ecVRu4\u002fOz4vbumMzP\u002fqqPfsrVmK1trtpLX8qQLaeLZODPZGWYyxlcsFyeVT5EtZMtF44DiL77x8VEwovbFztaU1lLqlNcm7gXufW8k8MUN\u002fq6P\u002f83r\u002f3viUm080Pdg02R6orxkx4wH1KJlC1wWMYK2Gk0ACcxfTtAyr+96B7av\u002f9G\u002f\u002fplVtf4RYLWqVgbiA+wbf8mMIBYwApdmdzNOixNNLzCQGFxIYG\u002fHGK1+eygS+JNwMPp5UzpVQXktr6sWlRpHDbd33MZP+x5gJjNzgWVjFuK5BA8PPMKRySNsrd1Km7cNj82DTbVR76qnwWXcj85Zf3xeDx769htzWu7TiqJsAjg9e5pTM6fOei8VFAp6nrxewIHxe2RVLJQWWauKynRmilguTo2jhnZvO8enT1z0vIqikNcKPNz\u002fCLd13Eqbt42CVuCapmtwWpw8M\u002fJsaUnKzcCToUjg98PB6H\u002fO7ye6tnzo22++MZ5L\u002fI2OfuMKzMiflU57ODHMlprN7Gm4giq7j\u002faqdhrdjRyZPMJL4y+RyCXP\u002fVzeBNwUigQeAP4sHIw+sewvYBE09NOjqTFGkiPsG3uJTdUb2VyzmWpHNZuLwcxgYpCDE4cYiA9Q0Arzvb7NZ+Za+ejdH\u002fibifTEH9W76vA7\u002fLyq6VVsr93OyZmTHJ08ymRmClgd96x7Tt1Dg7uB9VXrqXPVYbfYcVldtFeto71qHTktx2xmluHEMP3xAcZSYyTzSXRdP+\u002f+u1JgltWyjCbHVv1s6nWf3WLt8nX+AfAnGMvwTXO+QGYwP8RAMZBxW13UOGtpdjfR5GmixlGD0+osB5IemwdN1xoKeuGf0lrm136478u\u002f+6Y9H7r7UucNRQJujMyeC+tv8X9fdj8+85+T93\u002fomSUtTbzcrcrA5ee+edcf3NcT\u002ffMWT7Pb5\u002fCVHyhsFmNqzWf30UorOjqarpHX8mQKGVL5FPFcnHg2TjwXJ5FLkMynyOTTZLUceS1PQS+UN0iVApELKc\u002fmFKf3bBYbDosDj82Dz+6jxlFNtbP65+uctTffu\u002f+1v\u002fSG3R+46JT\u002f8enjLXNHTUw0ZnaDl7mZ4pfZgUtTKBJQw8HoBZcV3Pj5ndvu6Lj9C1V23w2lz1YsG+OxgccpaAXTRglVRWW9bz2qohLLzjKaHC2vo12AJuBzoUjgLh391yLBH6\u002faz9mDfQ9qN7a9Fq+tinpXPa\u002fvvJNH+h9hKDF81ubIktLPeSQ1xkj\u002fqJEq2VVPo7uRakc1HpsHu8V+0d\u002fVzk9X2T9yxUf+\u002fvj08Y\u002fq6CRyCUYSI\u002fTF+ylohUsGinOvPAoK6UKGkcQINY4amj3NuK1u0vn0RdtRFZVMIcMDvQ9yy7qbaa9aR0ErcEXDFVTZq3hi8EniuThW1eoC\u002fiMUCewEfvNyWTr26JHv1ydyif89lZn6lQPjB5RTs93kC3nTBgAWyqJY0NA4OHGI07Fe9tbvYUvtFuwWO1c0XEGHr4PnR17g1MwpNPRzl4TeCtwSigT+GyOAGV+RFzFPCsqQRVFAUYnn4jw\u002f+gKHJ4\u002fQ5e9kW8026l31rPetp83bxlBiiAPjB+mL96Hpl5yBuegAUCgS8ANfHUoOv+ne7nvZ4N\u002fIjrrt1DhqcFld7K7fzZbqLfTGejkyeYSR1Gg5aFpCULukB8mh5DCDiSEOThyi2lFNm7eVdm879a56Y7+DaqPWVUedq47tdduNa0lyhL5YH0OJYeK5OOigqupZr2EZV5os2j8++Ie7nx994f\u002fm9fyrVUVdynswL+cGMql8mkS8n75YHxbVgsfqps5VR7O7uXy9L70Hmq5tVFX1B\u002fe89D+fmkiO\u002f+EHr\u002f\u002fYBd\u002f3rJatsirW6gqsPlnVv\u002ferwaoKXIo51r9Q0Atv3T+xn\u002f0T+7Grdjw2N367nxpnDbXOWnx2I5hxWOxYVEt5naDP7qOJprOm3gp6gbyWJ6\u002flyGo5soUsueL\u002f57U8eT1fXnY2d8PcmXWI9nL7Dosdm8WOTbWd9YCp6\u002foGRVF+fP+Br3\u002f8zl3v+5cLvT6LYlnQUqJ50jFq0Yj5S2LUxGg3ud06jLoPs+f7xzd85fo3X1F\u002fxZf3Nu6tsVmMTMZ5Lc8jA48ynZk2bQZO0zX8Dj8tHuP+PxAfJJlPLiVgfqeCsvdP7\u002fu1D\u002f7v1\u002f\u002fXqhwN7o318UDfQ9y27tbywMKd6wM8O\u002fochyePlPYYvOw4i6KCYizjOh3rpWf2dPn336JaLhhIhiKBDuCr+8ZeurGgF8oZYhRFKa9Xn8vIIGhcOwByxYGUs+7hOvTF+thSswWvzUurp4Xj0yewKhf\u002fXKiKSrqQ5ie9D\u002fDattewqXoTBa1Al7+Lakc1Tw49SV+svzRy++tAXSgS+LlwMLpmlpicz69+\u002f923DiWGPlfjrOmqc9Zxc\u002fvNbEtuY9\u002fYS\u002fTF+ha6RMk0pdn0ZC7J44NPcGr2FFc3Xk2zp5lqRzWvW3czG6q7eG7k+VL2sbmfFwVjtvOuUCTwW+Fg9JIjvyuoPJAxdwbg0MRhTkyfZH1VB9vrttPkbmJd1TpaPC0Mxgc5MHGwPANz7oN4UeuFThiKBOqBHwLXGUktchycOMjJmZNs9G9ge+12ap212C12NtdspsvfxXBimKNTx+iP95POpyuxjOySSvWhACbTk4ynxjkwfpAqexXNnibavG00uhvx2ryoikqVvYoqexUb\u002fRtJ5pMMJ4bpnu1hKD5IMp8qD6audvft\u002f+oHC3rhP+pcdd4jk0foj\u002feTLeQulsXRdOcGMvFcklguTvdMD1bVitfmpd5VR7OnmQZXA36HH7tq\u002f1hLVeveZ47f975rNr\u002f+vCta1ld11MxmY95ELk6+OFB1viV+izC61AYud6smcAlFAlsxsq3shDPTu3k9z3RmhqnMNN2zPcaaYtWKy+LEa\u002fPic\u002fjw2\u002f34HX68Ni8uqwu7xY5VtaIqKlbFWqx+fbH9mfNZEPLyYwqaRqaQYSY7w1hyzDKYGPrU+75557qvv+f+j13goEoELilgugLtXrbCwWg+FAlccmnfIlRjFIR8WeDy1q\u002fd+Iu763d\u002f9vqW6xSbais\u002f6D42+Dj9sX4zlw2i6Rob\u002fRtwWp0U9DynZpZWjkhHx67aN+6q3\u002fXg\u002fQe+\u002fmt37nrfF0zqqmlsqo2R5Aj3n76fm9tvNjJzWWy8uuXVrPOu49nR5xhLjl3woeXcm5uOTk47\u002f2BbKBK4Cvge0KGjn2nvIvcro\u002f6HH7vFXtyoP1tez16iqipDyWHiuRg+u58N1Rs4Oc\u002f3zkiRmuPh\u002fkeIZWNcUX9FOYANrL+DA+MH2Tf+Eul8GqtqDWKMIH9gXo2vMsXN9385k5n50\u002ftP369sr93O1pqtOK1OmtxN3LH+dmPp5dhLDCWGyumvl5taDIqHEsP8qOc+ttZsYU\u002fDHrx2L52+TlrczRycOMSBiQOkjPdl7uHrgR8UE8F8YjnSxC\u002fCFEYWsPIPtxS0FfQCx6dP0D3bwzpvOzvqdtDqbaHD10Grt5Wh4uxDf6yfnJY7dzbkvDMuxayi\u002fw+jptVZ58tpOQ5OHOLE9Ek6fevZXrudBncDVtVKW1Ubbd42pjNTnJw+xanZbqYz04DxHs1zBsC0pTtzr0GzWWM\u002f3dGpY7isLuqddbR522jxtFDtqMZmseGxedhYvZEN\u002fg3EsrOcjvVyaqab8dT4eYvorhZ\u002f9ePf+ctMIfu\u002f3DY366rW0eZtYzw1zrGpY\u002fTMniaRS6xIEKkqCsy51s9mZ5nJzHBi+iQ21UaV3Uudq54WT\u002fOtfrv\u002fwS8++Y9v\u002fvkbPv6yhD63rbutsaAX7NOZaUaSo4wkh5lMT5HMJ8sz7qUZsQXOMkngcgmrInAJRQJXAz\u002fgPBess6ZCi\u002f+n6RqJYtQ8mDASQZQ2SRprR53F1HMePDY3bqsbl9VVzN5gjHqWR1RRUM65eJUeKjU0CnqBglYgW8ietRwtlo0xm51lNhsjlU+R1\u002fKlUZDfDUUCtnAw+lvneanz2wOxMAmMKuliYSoxHevBSOnYN\u002fcv3xu58xeubNz7ud31u410h8XP1xODT3J86ripQYuu63hsHjbXbAZgLDXOUGJ4STcHTddoMtJO2nVd\u002f\u002fwXn\u002fon\u002f89f\u002f\u002fsXnFlcKRbFwkR6kh\u002f13Mf1zdexqXoTOjrrqtbR5GnixNQJDk4eYjo9Dcql176f72YTigSuA+5hgWubdV2ny99Vvp4NxAco6IWzZlMUFJK5JH2xfnbW+Wn1tFLrrGUyPTmv909VVHR0nhl+lonUBNe3XI\u002fX7kXXdfY27mVd1TqeG32O07O9AO8PRQJ94WD0jxfyOlZaKBJoAL4M3AUQy8Z5auhpjk0dY3f9bjb4N2C32Msj\u002fL2xXvaP7WckNYqCsiIPeaXlYwcmDtIb6+PKxr1sqt6Ew+rkqqar6PR38vzoC\u002fTM9JxvluhjwN5QJPD+cDC62uo6xIAM59mzUAoodHR6Zk\u002fTG++jzdPKjrodtHvbWFe1jlZPKyPJEQ5PHub0bC+ZQqY0Et90gfN9CaPGx8uUzpfX8xydOsapmW7avG1sr91Gi7cFm2qj2lHD1c1Xs6t+FwPxAU5On2QoMUS6mCHzEp+NiiytnHveTD5DX7yf3lgfNouNGkc1bd628pIyu8WOz+Fnt2M322u3M5Ya4\u002fjUcYYSq+tjURxY+O9Dk4d\u002fuT\u002fez9aarWyq3ojb5qHR3Uiju9HIQDfTzcmZU0ykJ8rLpFfi97M0wACgoTGdmWEyPc3xqeM4LI7tqqJG3x2+\u002ffXfCv3krBpMdou9SVEU3DY3rd5WNF0jnU8znZlmPDXOaGqMyfQkiVyCXCFHaZBrHoHMsu1ZXqtWPHApPgjcywKK7JU22s8dIQUjW0M6nyaVTzHB5FnpTEtLOCyK5cyXqqIqlvL0XrlIEBq6rlHQNQpawdhUqxl7Y4x\u002fO7P5v3TsOQ+fvxmKBGbDweifzHmdVhaQLWUB4hjBi1iYSgQuKsa+kLJPPvDxNzS5mz7b6m01lhKhkNfyPDH4BEenjpkatICRvWZ77TZ8dh+6rnNk8sh8soldUqnwWUHP89L4\u002fk+94+uvs3\u002f3fQ\u002f9vUndNo1RsybNQ\u002f0PM5gY5KrGq6iyV2FTbeys38nG6o30zPZwfOo4o6mx8ojlfEbFQpHALuBuFhi05LU866ra6fJ1oaOTyqXonum54MzPiekTbKkx9kVsqdnME4NPzvuGrqBgUS3FB4JJrmu5lvVV69F0jRqnkbjg9GwvL469yFhq\u002fI\u002fe\u002fvWbn\u002f3e+x7+7kJez0oJRQLbgO8C20t\u002fV3rYmc7M8MjAoxyePMyuul10+jqxWWxs8G9gnXcdPbM97B8\u002fwHh6fEUCmNKDdTwX55GBRzk5fZJXNb2qnPXo1nW30FvdywujLzD68pnBW4FHQpHA28PB6IFl7fjFJYA0F9lsXfo8AvTF++mPD9DiaWZH7Q4jePG20uxpZiI1wdGpo5ya6Saei9fzm1j59zOZvEKRwJ9j1OK5qNLPWUPjdOw0vbFeGt0NbKnewnrfetw2Nw6Lg43VG+nydzGTmeb0bC89sz1MpCfL14PzfD4qPuM1d9ZX0zXGUxOMJsfYP74fv6OaDu861vuMzf1W1UqLp4UmdxPpfNryOb5X6e7NS7Hg7leA94KR\u002fezJoac4OHGILTWb2VS9CZ\u002fdR5W9iisarigGYKN0z\u002fQwEB9gNhubd3roSigNLKnF0+b1PIqubLAo6j2hSOCWcDA6UPrel8Zfaql11lLjNPZWWRQLbpu7HMjouk62kCWWizGRmmA0NcZEapzZbIxMIYOmaxdaXrZq95KuFisauBQfBH7AIiuDn0sBuEgaOjAe7Ap64ZIb88+0eSaH+LnLSS7hj0ORwMlwMFpaVuPFpNd5jhmMm4dYmIpsgNPnzKr9YN8Xd1oUy1esqlUtbUhN5BM82v8YvbHeCgQtRkX1HXU7ABhPjXNqpntJG5U1XaPaUU27tx1d1xlPTTCcGMZusX8yFAmkw8Ho\u002fzGr\u002f2YpPXQcmTzKQHyQ3fW72FK9BYfVmHHdVruNTdWbGE+Nc3r2NAPxAaYzM+S03Jmp\u002fXNumsWR\u002fu9wgfSX51PK6d\u002fkbuLGthvLe2YOTRxiNjt73vffolgYTY0xnBimvaqdjf6NHJw4SCwbX9DDtlW1Mpud5Se9P2Vr9RaubLwSr91LQSvQ6eukzdvGiekTHJ488n9u+OzWR5\u002f85aOr+mZZLC54NxeYtS79bMZTEzzY\u002fxBNrkZ21e9iva8Dm8XG5prNrPet59TMKQ5OHGQiNVkezFpOpfMNJAYZ6R5la82WciKFTl8nrZ5Wjk0d58DEAWYyM3P3AmwCfhqKBN4cDkZ\u002ftqydvrAMC7j3lGaSBhNDDCWGaXDVs6NuB+t962lwN1DvqmdX3U5Ox\u002foafum3fqvrrn9\u002fx3GA94Rvfx3w5wvp2NwkOCPJUUYSo7w4to8ufxebqjdQ66xFVSxUO2qoaaxlZ\u002f1OJlITnJ7tpT\u002fez3RmuriKolyQdkl1XBbqzAO08XmZSk8xkZrgwMQB6l0NbPRvoMPXQZXdi8PiWE27879IMWiBMwML8Vy8nL65o2odm6s30+huxGax0eZtp9XbRjqfZrycHnqQqcw0uULOzL0jCzbnHrAZCIcigTtKBcifHv5Zs4qKy+qixjmnIKajBrfNjVW14rA6cFgd1Lvq2cpWclqOZC7JVHqKsdQYY6kxpjMzZy0vU1FX9bV4NVixwCUUCbRgrBOvxCzEBc0NapYhmv+3UCTwQjgYfYEz+x\u002fMNnOxLFbigkxNaFDKVKcqahvAt579L5dVsf6Poii1uq5jVa0MJYZ4bOBxJtOTpgctxrkVrmm+BpfVhaZrvDj2IrlCbsmBy5bqzTitTkDn2NSxuTM4nw5FAiPhYDRs1uswk1W1ksgleHLwKY5OHmNH3Xa6fJ24bO5icc4mmj3NZAtZjHXKI4wkR4x1yrkEOS1PQcsXAPJa4XOqom5RLnHdKC8z1TUjSKrbylWNV5XTb\u002fbH+tk\u002fceCi74mmaxyePEyrtxW3zc322u08NfT0gh+yS0vHDk0epj8+wN6GPWyq2YSKMfO8o24Hnb7O9hvbXvuJJ\u002fnt319Q48uouKfoXuZxrziTLW6U0b4HaXI3sqtuFx2+deWgtcvfxanpUxycOMRkemUCmLnLx07Hermifnd5lm1X\u002fU42+Ds5PHmEw5NHSOQSpT0gjcC9oUjgrnAw+syydvg8NF3LKoqSWuh9tBRQjKbGGe1\u002fmFpHLVtrt7DBvwG\u002fo5orXXXVV6676fd1XX90Mjn23G\u002f88P3\u002fnNfyymKzgpU2xsdzcfaN7ePw5GGa3U1srN5Im7cNt9V4yCxdD64s7GUiPcFAbICBxACT6SlyWm5F77GlAEADhpPDDCWG8Iy9yAZ\u002fF23etlWRIfBd37j1n7jAvrm5yRuOTh3jxMxJ6px1dPk66fB14Hf4cVldrKtaR3tVO7lCjunMNMOJYQYSA4ynJsrpoVewjtxrgX8EfgvAolhaAVL5FIn4nIKYFgc+h596Vz2NrgZqnbV47V7sxeQsfoexJ7vT34mmF0jl08xkZorLy0a1mcysJFu6hBUJXIrLpr6KMYp0OXMD\u002f4VRDK0Wk\u002fOXF0nqvMWZWWoDpQdUFPDZq9jg30BHVce6CD\u002fGbff8haIoV1kUC3ktz\u002f7R\u002fbww9qIpy7bOp6AVuLJxLx1VHQCcmj5Fz+zpJQctVfYqY6+IrjOTmaF7tufcNj9fnFlc8Qep8ymtX57KTPHYwOO8NL6fDf4uunxd1DprjTTnqq08WrZL30W2kCWRixsbeFVLVeDJu\u002f7ipdEX3pIupMkUsxGWU6oXlZYf2VU7PnsVrd5WNvg3UOesK69tHowP8nD\u002fw5fcUKsqKn2xPkYSI7R4W9has5VjU8cvWZDyfOYuUXp08DGOT59gb8Me2quMGbTiLNRv\u002fGDfF7\u002f8lj0\u002fv3+xP+dKCUUCWzBmWhY0wFV6OB5OjjCSHC0HMOt863BYHGyv284G\u002f4biDMzKBDCl9yaRS\u002fDE4JOcmD7JlcW9SG6bh1c1vYrN1Zs5OHGQ49PHSeXTWFRLnYLyg1AkcGs4GD28bJ09j3VV7YXR5Fg+XTAmXRaa6raUCnoqM8UTg0+yf\u002fwAG\u002fxdbK7erOYK2RrgusGpk795V+edVx2fPsHp2V5S+dSiH1xLxxX0An3xfvri\u002fXhtXtZ52+n0d9LoasRhdWCz2Gh2N9PiaWGvtpfpzDRT6cnCt\u002fjpgs9pNoUzgVg6n+bAxEEOThxa8eyAn374z37xyNTR35tKT5WXep13KSxnltWPp8YZTRozYY3FGjet3lZ8dh82i40GdwMN7gZ21u8kkUswlhpjID7AcGKE2exseV\u002fxcqRYnuM3Q5HAfeFg9B6K9YZeVkdGyzKSHGU4MYyiKNhUG16bUQy6wVVPvasev8OH0+LColrw2rx4bV7avG1oupbOadnY\u002f+Wby\u002fV61qSVmnH5O4x1u68E14Uigd8ADjHfRWYLU4nsWK8EC94XVErYUBr1cVvdNHkay0s83DY3Ba1Q94MXv7DTqlp\u002fV0FhMDHIcyPPM5QYwqJaKpLdKK\u002fl2Vy9iasarwJgJjPDz0aWHkdousb22m147V4ADk8eJpVPnRt4uYGvhCKBG8LB6NSST1ohpQAmlo3xwuiLHJw4RIOrnnVVHbR5W\u002fHb\u002fdgsNlDAbrFjt9RS46zFZnXszRdyN6zztpbrRWXyGbJallwhS0HXAAWbasFhdeKxenDZXNhUWzk9ckErcHjyMM+OPEe2kL3kQ5eCQl4vsG98H42eRpxWJ1c27uXBvoeW9voxRmujp0dZV7WOPQ1X0ORuAgWnruh\u002fBLxv0SeogGJ6\u002fO9wkfS4l3JuANPobmRX3U46qjpwWOcEMLPdHJo4xER6AlDOra9SUaXP5mhqlB+f\u002fgkdvg72NuyhwdWAz+HjhtYb2Fa7jYMThzg5c5J0Pt1sUSzffW\u002fkzpu+Ebx\u002fxZaVvHvjO\u002fN9yYH0SGKEntkeRpIjpIp1hxbyMFl6yE3kkuwbe4nDk0cUzeZ4\u002fK1b3+MZmjl9VXtxKdFMZoZTM6c4OXOKqfSUcR0+fzrli5q7jCyZS3Jo8jBHp47hd\u002fho97azrmpdub6KVbVS76qn1lm7mpZjAXMemFfY3fu+dKVVtf7rpppNjCZHOT17mv74ALFsrFyz53zLvErve17P0x8foC\u002fWj9PqpN5ZR3tVO62e1nJmtVJ66A3+DWQKGabSkwzEBxmIGzNimUJmOZeU\u002fUMoEngYIxHPyxifL6O+ERjbE4zgd4oT0yewqBZcFhd+h586Vx0NrnpqHDV47V5sqi2toCYr\u002fQLWumUPXEKRwBuBVbssoUI+jpERxXQ6umzMX5yXXRzmFiWd++fSBlOX1YXf4aPB1UCzp5l6Vx1uqwcwHvKLmVHaHVbn306kJmz7Jw7QPdNtZI+qwCwLGEHLpupNvLbttVgUCzktx2MDjxHPxpc821LjqGZbzTZ0XWc6M83x6RMXCry2Av8CfHjRJzRBaZnWXKU9aqWHm7mjroMJo7qy3WLHb\u002ffT5G6kyWNslvbaPNhUO\u002fl8xqMDVsWK1WLFaXGCvdj2JW6QmUKGwfggBycOMpQcRmX+I8UWxUJfrJ+emZ5iKtQuumd6ODVzakmfpdL7V9rb0+lbz676XTS4Gt710OHv\u002fN3rtr9zNc26fAHYZUZDZ\u002fY7GMsBy0vISgFM7TY2+Lvome3h0MRhxlJjLHcAU+pjaaPypuqN7KrbRY2zhhpnDa9tezU76rZzeOIwJ2dObkvkk\u002f\u002fDbbyBn1Ym49WlXL\u002ftzYXvvfDZzLbabWyv285Ueoq+WB\u002fdsz2Mp8bLQfp8P\u002fOqoqAqRirlb7z0he4fHPnmdU3uJtu22q2s866jxlHDq5pexY66HQzFhzgxfYKBxOCSarOUspECxWxSUxycOHR2fRVXY3Gp7OLltTN7+0vXDeOapHAmaeqqi40uKT89ZH+g\u002f6H\u002fBtyKopQDv1Q+RSmgHUwMEc\u002fF0XVjlu3c62Y5kFSM+lYDiUH64wPFTHDVtHiaafW2Uu+qx2V14bQ4afG00uJpZU\u002fDHmYzswwlhuiPDzCeGiOVT3NWmnrz7cB4hvXO55vLmXHnvOxUPkUin2AgPnDWrEy1w5+tdlRnK9Pty8eyBi6hSKAG+LflPOclZDBG3lOcyUfvxEhru7Qr1dnWA79jYnuAMQPgsNhXY37\u002fVa+gFxLolB9qSzV\u002frBYjpbbT4sRjc1NlryrXCaqye8vTu6VlYqXMIBbVQraQpS\u002fWd9Xx6ePW\u002fvgA2ULWrFmWHEb2uNLnVMX4fFbtabjCfnXT1eU6Ho8PPk5\u002ffGDJgZKOkULXZXOh6zovjb90vtmWuT4UigTuDgej31nSiZegVCzWolhQMIKvnJYvF3ss6MaKilLGmtLNsqAXmEhPMJYa4+DkIeyqHa\u002fNQ7WjmhpnTbFGlAenxYXdYsOiWosje8Z5dd1oI6flSOVTxbXZIwwnhpjJzi6pjshzo8\u002fT4mnBZXNxbfM1jCZHSeaTS74pW1Rjj8Xx6RP0xE6z0b\u002fRts7b\u002fgvA7y6pYZMEI3f8IfBWs9s9a8N28oE5e2A6cFgcbK3ZygbfBvpifRycPMhocuzce4SVM\u002fcIh9n9A7CqFgp6gUMTh+me6WFrzRa2127H5\u002fBR66zlNW2vZmfdDg5PHnl9w2\u002fW\u002f9V\u002f\u002f\u002fTbf1aJfszH90\u002f+IN\u002fgqqfL30W7t509DXvYVb+LidQEPbM99MZ6mUxPXSxb18soKHjs3jfo6G8bTAwymBikxlHDRv+GclHVDdUbWO9bz0xmmp7Z03TPdjORnlxSWt2L1VepsnmXFBxe0\u002fQqslqOdD5Dprjk1Ji1zZHTcuWyC2dlLUUpJxu61N66lfIrP\u002f3I76\u002f3dV7T5e\u002fU6531isViKe\u002fvW+9bz3rf+nIBzZ7Z0wwnhkjkk6CfuQ7PNTeI0dDK1+UDEwdx29zUO+tp9RrZ1Px2H1bVRrWzmlpXLdvrtuvxXDw+FB9K9cz2ZIYSwxT0gh3jd9WDuStePsYSnp\u002fPXV5WnpXJTCVzhZwkW7qE5Z5x+Quga5nPOdcx4EngaeAwMMiZrFylwMWBsYm+BdgGXIuRO377edpbiOolHn+WvFagxdPMDS3XzfwP95jZ9Io432h5Jb265YakVbViV23YirV9SjV+bKoNq2o9a4q7vKdBN\u002f5cmoXJFrLGSONsH6djp5lKT9s0NCMQWnzw0As8Vfw6CPRjFHsrBy55Le+sc9bVXNt8bZOmaxuAa14YfeGa41MndlpV68WqrV5SXsvT5etko38jAIOJQU5Mn5zPDM4\u002fhiKBn4aD0emlnH8x3tB1l+q2unFY7KjFh1Nd18jrBbKFDIlckpnsDBOpCSbSE+WUlKVlf3NHXvN6nqnMNJPpKfSZU+Ugx6pai58Pazl4AdD0AnktT1bLki3kyOv5uZtIc0A3xvXmGEaNn3GMGb8CYAOqMNZLb8AowLsdqFMVlan0FM+PPs9rWl+D3+HnupZrebDvofJM4FKUU8fqGkenjnJy+uQ7f+6bd\u002f3F197zoyXv\u002f1qK37\u002fnF67vj\u002ff\u002fVUEvVKxw5NwAZjT5AI1nspAdURTl8c01m59pdDce+\u002f7J7w8l86kpi2KZe49wYlzP2zBGX68HbsB4\u002f0xRem+yWpYXx\u002fZxvJgie1vtVnx2H9XOGq5vuZ5ELvGnr3\u002fhzkfffuUvR80690Kk8+nU6Vgvp2O9eKweWr0tdPm6aPG2cF3zdVzZeCWjyVG6Z3voi\u002fUxk5m56PKhOd6voHhK79N0ZppnRp5l\u002f8QB2rytbPJvosXTQq2rjlpXHTvrdzKWHOXUTA\u002f98T5mszFjhH8RS8ngnPoqhQzpfHpJBShf1XQ1YNznNP1MuYW8li9fO4rnIZlPkswliefixHNxkrkUmUKGvF7cW7eM98mLCUUCOxP55J\u002fsH9\u002fP4cnDSo2jRu\u002fwdbC+ah01zlpFURU0XcNpdbKhegMb\u002fBtI5BIMJYY4PXua4eQIyUsEMXP3naVyKU7nTtMz21OcjfGPb67Z\u002fOy2mm3PFsjv0+FUnbNu\u002fMqGvYkGV332fz\u002f9N5yaPW23KKoHIxvkBuAqjN\u002fVqzCuu4u1lGNfZk69wqTFapEZl0tYtsClWGTy15frfHOMAxHgG8BzpVR2lzAKHAceAT4TigTswJUYaf5CnFOrY7kV9AI1zmpubr8Jv8O\u002f5jJQzM28BEb2J6fFqXhsnmXrw7babVmLYtEwZi\u002fKG61LwQkYIz6KrpRnZHRdJ6\u002fnSeQSTKYnGU4MM5wYLqfSLd3sFrnuOA58HyMH\u002fpPhYPRSRUVngJH\u002f5ltHgIcx0lASigQ2A2\u002fGyO6yd6Gd0HQNj83Dtc3XGllgClmeGX6WeT5EdgF\u002fACx7UcNWT6uioxfrLhkzKxbVil1x4LV5qXcZWYw1XSOrZYln40ykjdTOo8kxZrMzZM8pEnbuqG1Oy5ULiZ1PKYWyRbFoKDyKsT\u002fjQeDEPK87AIQigSbgNcD7rar1TUcmj9qaPc1sqt7ERv9GJlITvDi2z7Tlh6VRTh19XUEv3IZRK2VF7O9+yHc6dvoLw4lh20vj+xlODC9pxupSiu0ODyWHvzF4ejDyns3vfjF0zW9mLnHYDEaRuKPAA8C\u002fhyIBN0ZF9w8A7wR8ZvSvFMCk82leGH2BY1PH2FK9ma21W\u002fE7\u002fHhsHvJ6\u002fj+\u002f98Jnr377lb88bcY5F9Q\u002fRUmXrnepfIpjU8c5MX2SKntVedN7s7uJdm87qXyKocQQ3bPGUrh4Ln7Bh1aMEfKy0rU1p+U4Nd1N90wP1Q4\u002f633r6fR1UuesK+5Xay+P8J+ePc1AYpBUPjWjoAwAwxjZJJOcqctixRisrMJIoNNc\u002fCqvuCg+VC5pA3wpM5xVsRi141SrMUpqcZTPgcJZZRo03SiAPbf4dekrW8gWAxkdBdRv88BSurdYf6+guEvXoYn0hDKWGuOlsZeoc9Xp66s6WFe1jmpHtaIoChoabpubTTWb2FS9iXgubrxPsV5GEsMkilnDLhTUzpml+Imma188PHX0J\u002f\u002f1tm\u002fOp8r8BMZg4HPAtwBCkcB64A0Yy5uvNefHYYpUOBiVVTSXsGxzj8HIHfcoKG9YrvNh3Fz+FfjPcDA6bFajxXoOH8FYUlFjVrvzVdAL+O1+7lh\u002fOzWOGvJ6\u002fv1v2P2Bry3X+UORwPeAty30uDMjTbpRAdjuo8FVT0MxXaDb5j6h6MoVb7\u002fql1Lm9\u002frl7tn35b02i\u002f1ZRTnzRKTrxd0t5ZH6LOl8mnguzkxmhqnMFFOZaWLnjNYvcdlODvgs8KlwMHpyqa+rpFgI7G3An2AE3ZdUCihf134zm2s2A\u002fDsyLM8N\u002fL8Qh6S48BeM1\u002fLfPzDg594eiI9cW08myivJ7eqFhwWJ167l2qHnxqHsezLbXVjU20oijEimC1kmc3OMp4aZzg5zHixSFi2kAWU4tr7eb3HeeDrwL+Fg9FnzXhdoUhgr6Zrf+2yOt\u002f0+s7XU++qJ6\u002flebDvoSXvd7mAr4WD0feb3eh8ffGpf\u002fpki7flEzbVRraQpTfWy4HxAwwnjWLSJgcw08CngP8bDkZN2+QeigQ6MZaS\u002fCrlHVHm0HWdgl7AbXWzsXoDW2u2UuusBfjXwK73mr4c+VJCkcB3OE9hyNIyWotqocZRTUdVB52+Tupd9eUsd4PxQbpnuhlKDpPKpUBZWGay0jlsqo1Gd0O5PpHP7puxqJYngQcOTRx67qH+h4\u002fZVNvIN0M\u002fueSsSSgS8GAkg7gS48H2juJ\u002ffz4cjP7SAn40Z\u002fn577x1k0217XdYHE6n1YHDYnzZVTs2iw2HxYHT4sRldRm1P1Q7VtVWnDFSKdWoA14241LQCn9w5+73\u002feNi+7YYoUjgzRg1+F7m3Ht9g6te76jqoL2qHb\u002fdr1hUS3nQsjQgmMglGE4O0zvbx3BymEQugaZr595ffwL8VTgYfdTE16FgvM9\u002fBlyn6\u002fpylcq4kEfDwehNK3XytWJZ3p3fufv9gdHk2P05Lb\u002foqdsF+gHwsUo+PBVvTv+EMbq2LPJanjpnHbd13Eq1o7pU4C74xis+uGy58xYauJRuLg6Lg0Z3A+uq1tHiacFn92G32AClOPtSOBHPxK9419UfWZbA5d8f\u002fcvdmq49n9fz1lwhV1zmkyVdyJDJpymlvs0WshSKI1twZnTQpM\u002fwU8BvVzKVcCgSsGEE2X\u002fJJfZt5bU8exqu4Lrm61AUhYFYP\u002fef\u002frEx87Sw1\u002ftf4WB0WWdX3\u002fWNW59UFOX6c\u002fs5dwmiRbHgtDrw2f00uhtocjdR56zDY\u002fNgs9hQMAKZTCFDLDvLaGqMocQwY8kxYrnYmQJh53+4ehj4eKXey7d\u002f\u002feaPtnia\u002fzmwPqB6bB7S+TQ\u002f6f0JA\u002fFBs4OXPmBXOBidNbPR+XhP+Pa9NtX2VHtVm2N3\u002fW4aXY3F5ZgZTs\u002f2cmDiACNJY4DVhADmbuCj4WD01FIbupBi0cx\u002fx1hKZqpSAOOwOFjvW8\u002fWmi35RlfDq++64gPLmpY8FAl8A2MVwgXNDTDqXXV0+jrpqOqgxlmDoijMZmbpi\u002fXRM9vDaGqM9AIzk815UH6y0d3wmTdvePOP79r9\u002foFLHji\u002f11dDMTALB6OfX2w7wfAdm3T0\u002fTq6E14efMyZrS0HMi6rC6\u002fNU06X67a5cVld2FU71uLeSUVRKOjax9+29xf\u002faSmvcyFCkYAKPIExw3hRc4MYh8VhBDG+Dtq8bS8LYkrvdTKfZCw5Sl+sn+HkCLFcbFzTtY9Hgj\u002f+UqVe081f3KOu87T+ttfu\u002fetkLuVN5pMrVfjyp+Fg9PblPOFatCxLxe7ouOMPJtLjHJ48Ql+sj0whO581rouhAZ8IB6MV\u002fyUOB6M9wLtCkcBvA\u002f9MhX+WeS1Pm7eVm9tvxmvzFh8sB3hu9PlVuZGrtFyntKmy09+J3+E3Cq8VL2QFXStfGBTUCy7BqYSH+h9OYYyQn\u002fW+zc34YvxZMab2zb92fRr4g3AwuqS105dSbP8fQpHAgxjL0Lae7\u002fvyWp4N\u002fg1cXVyLHc\u002fGeHzwiXJO\u002fgX6YCgS+FQ4GD2xlL4vxEUf3ue8d+lChmSxgJtRLMxJtbPaKD7nbirN\u002ftHgbqTR3cT22u2k82km05MMFbOQTaYnyRQypdFAHWO07m\u002fDwWjFPsDfe9\u002fDn37zV18z9ujAY1+9dd3rcFqd3LLuFh7ofYDBxJCZwcs64ArgMbManC9VUf+yoBccJ6dP0Rvro8vXxe66ndS7G9hcs5kOXwe9s70cmDjIaHJ0KUvI\u002figcjH7S7P6fKxyMPheKBG7CGOD6bTPbLu3Jyut5jk0do2e2x+q2uv4SY\u002fR4OV3y+nWmeKLGcHKEocQwL4y+QKO7iS5\u002fJ+3ednbV72JH3Q6mMsZ+wZ7Y6bMykymKesEQRkE5alEsfxoORb8N8J9ETHtxxRTviw5YSl422HWBF6Ohl\u002fe6TGemMeKbM4NmFsVSTvhiUSyoxv1queu4vIV5BC1w9mb7vJ5nIDGo9McHzgQxVR20VRlBjKqqxT0xLtb7Olnv7ySRTTz19PDT7\u002f\u002fkXZ+t6Az+wz+\u002fT4N9n75735d+Mpud+eJkeurqvlgfY6kxErlkefbHxEHLC6no88DlouKByw9e\u002fML1dov9tjZvOy2eVibSExybOkb3TDfxXMLMKqgJ4H3hYPS805eVEg5G\u002fzUUCRwHwpi0rnkuYzRCZ0fddq5tvra8xKU\u002f1s+D\u002fQ8xm42tqsCltIm9yd3Ejtrt5XSjpVG30sZ1DY1kLslUZoqx5BiTmUl9NDm6bJGLVbXmWf4LfslvhoPR\u002f1jOE4aD0WeKD1HfBm6c+295LU+7t50biymV81qeRwceYyozvdgHYg\u002fGfraPLb3n5pp7IwXIaBmGEkMMxgdRFRWX1UWts4ZGdyONrkZqnbV4bJ5yRee9hRwz2Rljrf5MT3wgPvCBb7\u002f3ge8vR9\u002fvfv\u002fjX3vb1yztdtX2yZvab8Jj83Bbx6082PeQKZnk5ng1yxy4FD+bbwHKCQOKD+Rs8G9gV90O6lz15QCmb7aPAxMHGUmOLCSAyQMfDAej36jka5mrOHDwO6FIoAdjWZqpSntgCnqBWC5+VygSeH04GL3P7PNcxLwryp+V9lbP0xfvoy\u002fWh9vmosVjbOpv9bayt3Evuxt2M5GaoDfWS+9sLxPpybP2Ec7xf4A\u002fDQejcdNf2QooD5udyZF8Fh3d2Gun58q7MlfAby3moAsGMaMO6l11+rqqdbR72\u002fE7\u002fIqmKGgF7XvN7ub3f\u002fKuzy5bXZM37\u002fnwgeN9T72uZ7bny1trtrwzmU8xnhpnMD7IUHKYmcwM2UK2krMxsr9lHioeuHzv5P\u002f7pfW+DnbUbqfaUUODq4F6Vz2763dzaqab49PHmUpPorPwyrtzJIG3h4PRH5vb+\u002fkJB6M\u002fCkUCb8FYfmBatom8lsdjc3NN0zXlPQeqonJy+iSPDT5OtpDFaXGsig96aWN0nbOOPQ1X0OnvxKbajM3SWsFIIYxRD2QgPsBAfICJ1ATJfKqUUlhf5nWlOhW+6p\u002fZM2P8f\u002fHB8hfDwegXKnneCwkHo6OhSOANGEspb4FS0NLGrR234LA40NB4cuhJemN9S30Qfu+7w7f9zbdCP13VBVLPDWTS+XS5GJpRZNRFrbOWFk8LLZ4Wapw11DnrqHXWTu2u2\u002f3W23a+x7T11vPx\u002fZ975O8t37DcrijK7Te23Yjb5uG2jtt4bOAxTs6cwqJazBgRnNdoqsnOqu0194H8yOQRume66fJ3srNuJ\u002fWuejbVbDICmFifUSfn0pv4NYyBrW9V\u002fJWcRzgY\u002fZdQJJDFWDpmujnv+ceB5QxcFjVCPPf3Lp3PcGLaKCxZZauizdtKl7+LZncT1zRdw56GPYynxumN9dIX62MqM42u61mMa+lXTX49q96Z2lTGfy2nUCRwLcV7x1KcG8QMJoYUo6bWC9Q769hWu+0bv\u002faaP\u002f2goijL\u002fnyzed31id\u002f73ofefdvG27\u002fitrp\u002frsvfRaevk2why0x2huHEMIPxQcbS4ySXdzZGFFU0cHlv5M6WZD759gPjBzkxfZIuXyfba7dT56qjyl7FnoYr2Fa7lYHYAMemjzGUGCJbOO+oyqV8YKWClpJwMPpwKBIIYTwULmkBdkHXUIAN\u002fi6ubrqaGmdNeSbjxdEXeW70+fIvCys05DJXQS\u002fgUO1c1XQlO+p24LQ6jboZxYAllU\u002fRN9PHyemTjCRHz6pya+KM20KZdoUpByjFIKWUKtlhdeCxuvHZfdQ4a0jn03\u002fwF4F\u002fW5GgpSQcjMZDkcA7gQcLWmHPBn8XN7bdiMPiQEfnmeFnODJ51Iw6MM2Kkd3sS2b0e7mcm18\u002flU\u002fTF+8vB3J+u4\u002f2qvb8jtodoXde9SvLGrSUWFXrHx+bOn6LruuW17a9FqfVyevWvY4qexUvje83o\u002fjajlAkYA8Ho8uSlrO4F+SN5\u002fu3UgCT1\u002fMcmTxaDGC62FG7gwZXPRurN9JRtY7++AAHJw4xmBhE07TzVVT\u002f9ZUKWkrCweh\u002fFDPGVbLuyq2hSOCmcDD6SAXPYSpj2Ztxy4zn4hyePFKsZO83MpP5Oml0N9DqbeXKhisZTg7Hnx1+9r3\u002f\u002ftZv\u002fHCFu\u002f5K9CFMjpbmBjHFwsA\u002f+Ne3fO3nfp0\u002fW7Fnm39++5f1nz\u002f14Q\u002f\u002fpP+BVo\u002fNc0ujqxGX1WXMxLsb2Vm3k2Q+WZ6NGU4a2UWzhezL0jgL81U0cNHR36qg1FpVKzktx+HJI5ycOcU6bzvbarfR4mnGYXGwodrYAzGRmuDkzEl6ZnqYzRnZYOcxC\u002fMX4WB0xdJ3zhUORu8NRQKfwFjTvGCl5VT1rnqubNhLp389pWtEMp\u002fk6aGnOTlzaiUf9s9SmmVp9bZwffP1NLgbyjMsVtVKIpfg+Phxjk0dYzprlIZYYn2TFTV39kTX9XJ9D6fVidvqpsruxe\u002fw47f78Tl8eG1enBYHVtWGqqhfu31ncFkzv1xIOBideuNXXv2+61uuffJVja\u002fyWVUrGhrPDD\u002fDS+P751Ov5aJ0dOyqjde0vuZD3+SnXzKn1+YrbXAu\u002fT6V\u002fnvuMoBzA5mpzDRDyZHf+LPbP70idTMAIsEfPxOKBO4+Pn3ibVkty01tN+G2ubm2+VpqnDU8NfQ06UJ6KRvY2zBSvveZ1+sL03TtV1VFvegF7UwAU+DI5FFOzXTT5etkR90OGlwNRgHEqnaG4kMcmjhEX7yfvJYvzUD9dzgY\u002fe\u002fleC2XEg5G\u002f1dx1PrOCp7mIxip\u002fNecufe2mcwMU+kpDk0eotpRQ0fVOtb71me6fF1v\u002ffB1v7ci+X9fyUKRQDXF5ZyVoqActarWn2cVDMju2nBL\u002ftrPbPpgp6\u002fzKY\u002fN09boaqDN20aTu5Gq4v29yl5lzMZoWWYzswwnhxmMDzGRHieRSxYzXBqZKWVGxjyVfoIMlv4wd+r\u002f5Ew3PbHTNLub2FqzlXVV63BanTS4G2hwN3BF\u002fRX0x\u002fs5OX2KkeTI3I2w57b\u002fMPBXFX4NCxIORv85FAncDrx+vseUNrLXOmrYUbeDjdUbjWU7xZmX7plufjb8DNOL33NgulJWlL0Ne7iy8Upsqs14UFAs5LQsh8YPcWD8ILPZ2fKmwrXCCExAn1PF2KJacFjOzKBUO6rxO\u002fz47D48NjcOixOraj3vmte8lj+dyMWXPVXpxdzzgScOffTgb\u002f+Rruv\u002fkdNyPDn0FEcnjy45aAEoaAW21e9mg3\u002fDa+\u002fe96Xdb97z4f0mdNlUuq7jtrnZXL2JZk8zdtVGTsszk5lhODnMcGKERC4BytkZrFRF\u002ffIPfu7Rz6xg10s+b1Wtbzs928v9+fu5uf1map21bKnZQq2zlicGn2QoMbTYpWNVQAfLELj87U9\u002fr\u002fXE9Il3zmZj8xqQmXsfOTp1jO7Zbjqq1rOzbgeN7kY6fB20elsZSY5waOIQA\u002fGBU7PZ+B9W+nUshILy24qiPJsr5KoqNDL7plAksD4cjJ42u+HlNPfzMJmeZDw1zr6xfb8WCf1EgpaVcTPQXsH2deAj4WB01dSm+9mvnOjvinT9VjKX\u002fO6pXDcnZ07hsNjxO\u002fw0uZto8bRQ76rHY\u002fOUn1931u0klU8xk5lhLDXGWHKcqcwk8VyCbCFbLmCtSDCzaBV7Ci4WwnvZWmnjxmM8CAwmhhhMDFHjqGZT9SY2+Dfgs\u002ftw29xsqdnCpupNTKWnOB07zenZXibTk+S1\u002fNyK1B+rZCafJfh9jF\u002fyC1YwL82uWFUrLe5mttZuZX1VBw6rs5wecCYzwwtjL3Jq+tTcPRIrTtM17BY7r265gU3Vm87k7Fcs9Mf7eXbkOUaTo2tiduV8syhWxYrL5qLKXkWNo5oaZw3Vjmq8di8ui+uCAQoYP5u8liddSBPPxpnNzmJX7X\u002f0q6\u002f541W31+OOnaH\u002f\u002fPoz\u002fxZ6ZuTZG\u002fuWvqcFMF5\u002ftcPPrrpdaGhWu8X+ZmBVBS6l36U7Om6j0d1U\u002fn0rPeTv1HcSz8bpj\u002fdzfPoEI8mR0ud7GFgtD8GPAH1W1bpuLDXOj7rv4zWtr6bT30mdq47Xd97JvrF97J84UB5QWKAO4HHzu322PQ173rqtdlttd3G\u002f42R66kwR0Ivc0M8EMBonpk9weraH9qp2dtTuoMXTUh4ZHUuO\u002fdH7r\u002f3odKVfx0J8I3j\u002fsc888Xf\u002fNJme\u002fMtTM6eYzswYNaHMKxVQhZGy\u002fv+Y0dhqULznfyYcjH5xpfuyGMV9nGv9IfXtFW7\u002fv8PB6EMVPseCRYI\u002f\u002fl4oEvimBct7jD05BcZTE4wmxzg4cQiX1Umts45mTzPN7iZqHDU4rU48Xg9t3rZyEdFkLsl0dpqp9BST6UmmMzMkisFMafB6mVMvr1mVfKq8lYs8uMOZkczpzAw\u002fG36G\u002feMHWFfVzubqTTS5m7FZbNS56qhz1bG7bjcTaSPLSH+sn9ls7Etfe8+Pnq9g\u002fxctHIweDEUCn2VOCsy51eJVRcVnr6K9qp0Nvg00uBuwqtby6H4il+DI5BEOTx4hlU8ZD8qr5IKX1\u002fJ47V5uaX8drd7W8kNRtpDh+dEXODR5mIJeWPUBS17L64qiYFOtuGxu\u002fHYftc5aap21VDuq8dg8OCyOl41Yl1I2F7QCOS1HKp8ikUswm51lJjvLbGaGWC5OKpcio2XIa\u002flHvvPeB5cti9FCfefEd\u002f+XRbE8aNb7peka22u347a5KWgFDk0eugv4W1MaN5mRncH4nUwX0vTFenFZ3TS6G6myV7GjbgebqzcznBzm4MRBBuND\u002f\u002fS19\u002fzItGK2SxEORmdDkcATQNCiWEjmk\u002fy07wH2pvewp2EPNtXGNc3X0F7Vzs+Gn2E4MbzQFPQdFex+mU21vduqWrmi4Qq21W6jP97P0Uljv2NOy12yz6UARkOnZ+Y0vbE+Wjwt7KzdTpOn+aH3X\u002fvRZatxtRDXNV\u002f36dHU6M\u002fvqtvVOZgY5OT0SQYTg6TyabOWAr+LZQhc8lp+QTVXlqAb+EQlT1BJ1Y5qMoU0qXz6rCBmrQQzoUjAizEYWylTrNL7RNFfYiyTc567hyWdz9Af76cv1odFteCxeqhz1dLkbqLeVY\u002ff7sdldRmJXVx14DdKQeQKxvNDLDvLVGaayfQksWxs9X8YVoFKPl3Oew1v6UKd1bIcmzrOyelT1Llq6fJ1sd63Hr\u002fDj81iMyJaTzN7GvbkJlOT\u002f\u002fY1flTB7i+NgvKvmq79QkEveAHsFhs+h49mdzPrqtbR4G7AZXWVgxVd15nJznB86jjHpo4Tz8WxKJZVFwA0uht5desNNLmbyGt5rKqV8dQ4jw08zkhypJxjfrW7pulqpcpepdQ4a8pByrk339IenqxmjJbEsjFmsjPMZGaYzcZI5OKk82lyWv6sEZO5NySbalsV+1ou5DvvffChUCRwHwtY2nghuq7jsXno8ncBMJGe4NmR5\u002fa+4+uvW\u002f\u002fd9z20apatKCjktBwP9z\u002fCbR23UuusxYGDGkctBycO8szwMzR5mtlSs5lGl1E0tdndPDCdmf7CKrvmPEZxOa6qGHWQnh15jpHkKDe0XE+Ns4ZmTzN3db6ew5OHeWl8P8lcEotqnc+jUkuF+87v\u002ffDDW3pjvTe0elvLs7NGBp\u002f1jKXGOT51nJ7Z0yTmkTa\u002flBADYCA+wFBiCL\u002fd95+Vfg2LtWfDrbP3vPQ\u002f\u002f+GwOv5xg38Dnb5OZjIznI6dpnumm4n0BHmtsJQg5upQJLAlHIweM7vvc+1puEIdT40znpo4K+lKBUaO\u002fzwcjE6b3ehyedumt5Zrs4ylxhhPjTOVniaRS5DX8ujoK1XwcL6uADor2P4XwsHosuypW4xwMHqoWGz158\u002f9t3P3QcZzcWK5GN0zPVhUCy6LC5+9ihpnLbXOGmoc1XjtVTitTnwOI3FPB+vRdZ2cllM\u002fzVeW+dWtPRV5Kg5FAj7gmoUeVxo9A8pTcfvGX6LZ3USXv4tWTysemwerYr3vg9f97qpafnKubwTvP\u002fmR77\u002f7B7XO2vc1uZtodDcWq8XbgTMj9zktx2hylBPTJ+iN9ZHKp1ZlwFLy+s47VYfFUQ5aume6eWzw8fLM0Fqxu363YrPYlFKgoqMbS7zyaeK5OFOZKabSxlcsFyeVT5HX8meq\u002fM4NUIrLy85jH8ubmnSx\u002fhMTAhcNjUZ3A16bFx2dY1PHyBQyXrvFfh2wagIXMB70pzJT3NdzHze03ECnr5NmTzON7kbGU2Mcmz7Oo\u002f2P4bNXsb1uO43uxq+Grv6NqZXu9zlemvsfpetnf6yfe9L38KrGV7GlZgs21caehj2sr1pvLD2dOUVBL1xqgKGhsl2H\u002fvjAzf2JAWeDq54t1VtY71uP2+ZGR6HR1UiTu4k9DXswlpGdYDI9Oa9lZMXXdfTw5NG7K\u002f0aluLQxKGv2iy2P2zzttX57X5qnDXUOGvYUbuDsdQY3TPd9MX7mM3GQKeccnWenBhpaysauFzbfK2q6xoz2VmG4kP0x\u002fsZS42TzCeN5W\u002fmzB69AHzdhO6uGE3X8Ng8VDuq6fR1UtALpPNpYtmYsX8nPc5kapLZbIx0IV3c1M1qCmZuvPS3LFoa+FwF2zfL\u002f9V07cOAcrHPdPnfypkpUyTyCQYTQ8Cc\u002fbI2D\u002f7iftnSnlmX9aKLlERRpZ40t7HETVylC15Oy3E61svpWC8eq5tWbyvrq9avhs2xl\u002fS2jW\u002f9sqpY3nfuRSdbyDKVnqIv1kdvrJfJ9JTxIKGu3oClxKpaldJ+lkMTh3hy6Kny\u002fpa1JK\u002flyWoZYtk4k+lJJtITRpCSjZEuZM66ccydGl7gTfjr4WB0VdTZuYQfYzzgbFlKI7quU+esR1VU0oV0uTo98Fpg1S3ZsSgWErkkP+19gA3VG7iifjd1zjoa3U00uptI5VMMJYY4PXu6cGD8QHil+3sePUAc8M79SyMFeZpHBx+jL9bH1c1XU+usxe\u002fw87r2m9lcvYnnR59nODFysbSd1ZXuvKIotwGMJEcZSYyyb3wfG\u002f0b2VS9iWpHdXkGr7SMbDA+yLGpYwwkBssV1S\u002fy+\u002fiNR3\u002fxwKoqznuuj9\u002fyyeF3fP11P\u002fTYPB9q97axsXojze5mHFYHbd42Wr2tpHJJBhNDdM92M5QYJplLLmRp1h1ARbOp5Qo53WF1UOeso85Zx\u002fa67SRyCcZSYwzEBxhJjDCbnSVXWlK2uIfwz4SD0ZUqFmyK7534Pl6bh3pXPQ2uBmqdNXhtVTS6G2n2NAM6OS1PKp9iNjtb3gdRGjhL51Pk9UJ5H+YKLDN7TQXbfjAcjB6pYPumCAejP\u002fvoDz\u002f4s1g2dl08Gz+TgfJS+\u002fHOmZEByOQzpPNpxpPj5dk2m2rDYXHMu6DrK1lFnpI1XbvSrEwp5RzfGDUVjk0d77mn+94HTWm8wpK51KNuu\u002fsEGpuS+SQTqQkGE0MMJ4aYzkyTO5No4EIj9quSRbGwf3w\u002fPxv+GUaqv5VPzbxQP+r5kZ4uZPTSTAqcPbplQgCZwajps+qFg9F0KBL4AecUAVwMp9UBQK6QI1OsMAxcvdR2L6WUtGOhN\u002fPSZ\u002ff41HF6Z3vpqFrHpupNNHmacFldbKzeSKev8+h4cuwgfLlS3V+sSWCCcwIXOPO6umd7GE6OcEX9Feyo247dYi9uXG\u002fi+PRxXhrfz0xm5nx7SV7WpplCkYALeBVQruEQy8bL++TWedvZUrOFZk9zeRnZet96OnwdTKYnOTF9ku6ZbmLZ2MsyvwEF4PuV7L9Z7Bb7t7Na9kPHp09ycuZUcUR+PZ2+TmqdtbhtnnLimlg2xkB8gJ7ZHkaTo6RLS7Mu\u002fOB0dSgS8Fayqvw9PfdqDc768vJndzHros\u002fuY4N\u002fA5lChun0NMPJYYYSQ+cWHZ5PADYJ\u002fL9K9X+5xLIxZrOzDMQHURQFu2rHa\u002fdS6zD2PdQ56\u002fA7\u002fEZafW8V67ztaOesApjOGBu7pzLTxLKzJPOpcpaqSgpFAh5gdwVPsaL1lRbiDZ13fSddSF03mZpkKDnMcGKYyfQU6UK6PMM4n3tQ+XvmfFtBL5DMJVdjsqlVpyJPyy6r66pkPmn6hr3ikpyf7vu1voRpjVbQO6765dRf\u002f+Sj94+nxjdNZaZJFzfmlYOVVT67cj5WxcrBiYM8PfyzNbOx8Hwm0pO6gqKbFKScz761MIo0xw8xIXDJFYxC2naLHZfVRTKfwqIom0KRQEM4GB1bavsXsq12qzKRmiCWjZHTcmjFTHFnKCjKmQrj5352S0UOj0+f5FTxAbK9qp2Oqg78Dv\u002fT77v2txdVIbzCkhgPdusv9A1W1Uq2kOXp4afpnu3mqsYrWVe1DqtqZUfdDtb71nN44jCHp44Y+1\u002fOBDCVXrOw4dx+z51lPz59glOz3TS6GtlSs5mOqg5jGZmuU+us5fqWeq6o301vrJfj0ycYTY6WE4UoinJQQTlQ4f6b5UkFZcSqWpoApjPTPD86yYGJA0Z9Gp9Rn8ZnrzJqRDn8bK3dykxmhv5YP6djvYynxsqDBOfcc9cBmzGWWlXERGpCH0uOcWTqKG6bmzO1LprwOXw4Lc7y3tTd9btJ5pJMpCcYTgwzkhxlOjNdfui7QCDzYDgYHapU\u002f5fLucuH8nremFVJTXJ8+gQWxShYXGXzUuOsodZZS42jppxltclmpN4FzspSNZOdIZFLqN+mohmi12PUdqqEBLAmBqIBsoXsPXaL429avW22tqp2ClqBeC7OeGqcocQQo8lRZrKziypEeW4gIy6sIk9sb9n45p1HJ49ycOIQWS1r9jKiH5vZWKU9N\u002fL8j20W22+UbsprcXZirp8N\u002f0w\u002fNHl4TQctAKqiLrrzpQxx5\u002f4ZzszaqIr60JI7ubxeBAZYwg1KURRGkqNouoZNtbG9dhuPDjyGrigNCkonULHA5aa2m9S8liOeS5DIxUnkk2TyGTKFDNlClkwhS6aQIVNIky4Yf58r5MpJFUojZaVU7VOZaSbSkxycOITb6q54WuDFCAejWigSmL7U95X2YI2lxvjx6Z\u002fQ6e9kb8Me6l31uK1urm6+ms01mzk0cZgTMydI5pKoimr90LffrH75XXdXajh3N2A7b3\u002fn7HUcLo5q+hw+Nvi72FS9iRpHDbqu47Q62Va7jU3VmxhLjXF86gS9sV7S+dTj4dBP1sTSonAwOhGKBJ4D3gBngreCrjGYGGIgPojL6qLF00ynr5MWTwsem6ecAXFH3Q6mM9MMxAfojfUxnho\u002fs0leUVUFZS8VDFzm3tNSuRTduR5OzXTjsNipdlTT7GmmxdNCnbMOt81Nlb0Kn91Hp6+TnJYjkUswkZ5gJDHCWGqMmcwM6UKmPCNjUSz3VqrvK6n0UHu+5UMjyVHAmEV0WOzGXgiHnxpHDTXOanx2P26bG7\u002fDT52rloKuVfqhYisX+F01wYFwMNpTobZN1zPdfXR99frDdovjitJ7WPpMb6zeSLaQZTY7y2hylOHEMGOpceK5+Jnse6tjv9KaZ3rgcv\u002f+r9egsOGa5mvo9HXy7Mhz9MX7UMxZUpQCnjOhm8vGaXW+AMQwcuuvefvGX9KWIfXliju3vgtQupFiV+3YLXacFgdOqwtX8cttdeG0OnFaHBR07ZFvcP8Kv4r5CwejM6FI4AWWELioispgYpDR1CiN7ka21m4llU\u002fxwtiLZAqZzcAz5vX4bLFsTC890NW76st\u002fX5p1KaUiL+iFcp2dRC7BdHqa8fQ446lxZjKz5LRceZSsuHxTm83Orsq060XzXgZUGkA6OX2S\u002flg\u002fW2u2sLNuJz6HsbTnhtbr2Vm3nWNTx+me7bE+NfS0ClQqcNkz7z4rxlKbF0Zf5NDEYdqr2tk6ZxmZqqg0u41R\u002fdnMLIPxwccj\u002fKRC3a6IxykGLiXlJdIKZLUs3bM9dM\u002f24LF6aPG20Fm1niZPE26rm3pXPfWuenbW7WQmO8NgfJC+eD9jyTFS+dTe5XoRc9fy5\u002fUCY6lxRpKj7B8\u002fgNvqps5VS7O7mSZPE9WOapwWJ9XFOlkb\u002fRvJaTmSuSSTmUnGkmOMpcayk+mpJ5er\u002fyutNBg49zkpo2VJpzOMpybO2gvhsjjx2r34HdW4ra6KrhXT0bdV8H7\u002fVKUaroTfvPkvCr\u002f6vXc97XdUX9HmbaXJ3YjPbmS91XWjPljpHrS9druxVDIzzUhyhOHEMBPpSZK55Jn9MRLILIrpgcux6WNt7d72Bq\u002fdS72rnsD6OzgxfYIXxl5gJjO72ErOJT1Ar3m9XRYDGDnor1jpjpihEpvwS7U0CtrKDJKeqbFjVPawKBbsFhsuqxuvzUOV3YfPXoXX7sVj9eC0OrFb7NhUK6piOTN6dsYs+tkZn9aIZ4A3LfbgUprhp4d+xp2dAeyqnasar6LOWcfJmZNb4GETu3q2H5z6geaz+\u002fA7\u002fPjsvnKKa+N9smFVrVgVK1bVik214rRWU+eso6OqA03XyBQyzGRmGEwM0hvrZSw1Tq6QQ1XUcZtqW7XXHE3XcgsdECoti3tpfD8nZ06xrWYrW2u3UmWvosrh4+rmq9lVv8vS6e1QXuJTFeo5OxfyzaUAJa\u002fnOTl9ip6ZHupddWyu2UynrxOPzYOu61TZq7I76rav5kDzfC46GHf2Ps8Ux6eOc2L6BF6blxZPMx1VHTR5mvBYPdQXN8nvqNtR2uS9o8LLiC7Y57nLZFL5FL2xPk7P9mJVrXhsRl+bPE00uBqodvhxWJz4HX6qndV0+brI6\u002flT2Vzm1JdZ1cnh5mWxBSjPNzNT0AvEcnFmczEG4oNQucEFAKyKdUtBL1AoJgeAs5faLnH1xbPm9HL5TGamnp3MTP3yqZlT2C12\u002fHY\u002fTZ5GWjwt1Lvq8Vg95ffLbrHT5G4qL5VM5VNMpaeMQCY5wlR6itTcPV+s7RU5y8X0wOXh\u002fkda\u002fA6\u002f9cqGvWys3ohFsbC1divtVW28OLqPo1PHyOuLquQMcCQcjGbN7nMlhYPRQigSOMxlEriYTdM1rKqVjf4N6g3N1\u002fFdHlqW8xb0gq7rulFrxWKjylFFXXGkpMZRQ1Uxz7pNtc1rplDXNQpnRvQHk9nEyDK8DLPtW2oDFsXCcGKYh\u002fse5sb2G3FZXaz3rae9qn3DJ\u002fmsGX08r3QhQzI5ylDCqA95diY4BVUx6gvZVOucVJR+Yy2501hL3uQxbjC76ncxmZrk5MxJTs\u002f2jj459NRMxTq+RE3uRkZTY+WNofNVWo6Vzqd5bvR5jk4dY0vNZrbUbMHv8Jc38VdCKBKwAl2LOdbot3HvGC2O6O8be4n1vg42+TdR66wdzWqZATP7uwyOY+xXcl\u002fqG+emXk\u002fmkhybOs7x6RN4rB6aPE10VK2j2d2E115VKqbb+d3nP+N6x1W\u002fkqrwa7hkv+dmVoplY8xmZjk5cwqrasVbnC1tdDcWA5lqbKrt4Fuu\u002fIXMSvbbLFV2L+l8hqyWXdAm7vM5a6BsGQbr37rxLZtLM9SJXKK4HDdBKpckVUiTLWTJF2uZzU0UYPTReIWl\u002fRvnvF4dOFz5V2Aui2I5CIBiBJET6QnGUmMcnDiEy+qi1lFT3tdV66jBOSfFscvqwu11017cH5PMJ5lMTzKSMAKZ2eysTL\u002fMg+mBi1W1tsayMR4eeIQTMye5uvGq4pS2h1e3vpoN\u002fi6eHXmOocTwgjYuFa2lzc5zVeSX8+zNx2tPXstT56zlhtYbaPW0kCvklu2XttHVoFQ7qpVmTzMNrgaq7FXYVBuKohg\u002fV52zZlFKS4wyBWMdcjKXJJlPksynSOWTpPJp0vk02UKGnJY\u002f+YV3fn9NBdhFJ4E8S7wuWFQL3bM9xLsTXN9yHS3eFlTURnO6eH7GqLQC57meFIpBZU7PkUIHYuWH\u002fdLSC7\u002fdR7PHKA7b6GqkyWPUXtrTsCf+uXd8d9WmtH5j1xs4Pn2CZ0eeI5FLLDjRROlBOJVP8fzoCxyePMIGfxdd\u002fi42VW+sUK+pBpqW2ohFUUFRSeaSHBg\u002fyNGpY9Q76\u002fr\u002f7S1fn116F5fVSPFrQcHc3CAmlU9xavoUp2ZO4bQ4aXDV017VTrO7ud5tdddgLLNeNVRFPeuhezYbYyY7y6mZ7nL1cZ+96uDK9dBc79j0jnKa6JHkCGPJcWazs+VARikOsKy2Jdjf+Nm\u002fOfwOf0OdWjenb0bl94JWIKflinsHM6TyqTn3xSSpXIpUIV3cT5gtF2rWdM2YuVGYsiiWtTbIAEZNshnAf+7MYqaQYSAxSH98oPw5rnfV0+JpLiessKtGLT9FUfDYPHhtXtb71pM30mGrl8MMY6VVYnN+c+lNHIgPMJocYVvNNq5ouAKPzUOzp4XXd72e41PHeXFsH7FsbCHLx05WoL\u002fLwfR+l2ocvKrxSiJrK18BYAQtnb71vLbttXhsHgpavpyRajm8fv2disPqUBRFPWv6u1i9lmQuyWx2lpnMDNPZaWLZGIlcgnQ+Q07LXWB0qTyiVNGibxU0DExhQvFBq2plPD3OfT33s7lmE5urN1cvuXeLVL62nDviV\u002fyjMWo2yVhqnIMTh6h2+Fnv62RT9UaqHdWr6oHvXJZidrAWTzPPjTzPqZluNBZeV6n0EJwtZDk0cZijU8e0RldDpUZG6gG\u002fWY2V+q7pGsPJkVNmtbtcwsFoIhQJDLLIWSg4s\u002f8OjD0xffF+emN92C12r1211wGDJnW3Is7NupXIJZjNzq659\u002fJCcloOn9131t6HWDbGeGqc0dQY46lxZs9JTGA8FKsrGsrc1xt1Vjv8Hq\u002fNi9deRZXNi9fmwWVz47QYS6adVufLssHpuo6GEdzkdePentWyZAtZ0oU0mXyGVD41dnL65Gor6jsf48Ao57mGzd2bBhDPxYllY5yaOYVNteGzV9HgbqDF00KDqx5vccC0NAsnBSjnpxKBS\u002fmhx6JYKOgaL43vpzfWy5WNV7LRvxGrYtxsO6rW8dL4fo5OHSNbyM5ntLC\u002fAv1dDqaPKhT0ApuqN3Jl01VmN11xeS3PpuqN3NR2ExbVgq7rJPJJnhh8YtmmkFTFAihoulZedzqeGi8WopwmkU+clSP\u002f3KJfl8gQt6qqxC\u002fALEZdEFOqplsUCxoahyePcHzqRPVHvv9ux\u002f9927dW3dKPc0fNpjMzTI6+wJHJwzS6G1djGuSyR\u002fofYaN\u002fI21VbdzWcRubZk\u002fzwtiLjCRHAMWYlViAOQ\u002fA+lByuBJdBuPzZTe70eJDw1r93TMtsJj78FTQC9ZUIdUC7Der\u002feVQDEYr9gFcbt898T28Ni+NrgaaPc3Uu+rxO4xAZhvbyGk54rl4+T40lhpnOjNNMpckr+XLG\u002fOXezN3ppCpHkwM+\u002fXSfbB477Oq1mKCGidumxuPzY3H5sFj9eC2uXFZXTgsjvL+QrvNTpVSddbyOB29\u002f+O3fHLV3Q8upVj3bAgj1fhFzZ1Z1NDK2SqPTh3DrtqpdvjLRUjrnfU4rc4K9\u002f7yUInApWbuf5TWUs9mYzzU\u002fzCnZrp5VeNVNLgb8Ni83NByA5uqN7FvbB+nZ3svNlqoU8F0qhU2jglLcEp0dFxWF5trNpPOr+ri0C9T0Au0e9u4se1GLKoFVVHpne3liaEntaeGn162fowkR5jJzuiDiUHGU+Mkcykj00cpOFEuGZxczKoe3byQcDCaDUUC42a2WXqI0tFrpjLTXozCnKta6X3Pajl6Y32ra+3GOQ5PHuH49Ak6qtaxq25XaT8RJ6dPcmDiAGMp4+1czJ7CSiTiKKq\u002f9Lcs2lqt+VGRPXHFh8SKLdPUdO18yUnMMl2JRldCKdXxaHKUg5OHcFgc+O1+Glz1NLgbqHPW4bP7qPZXs9G\u002fkYJeIJ1PMZuNMZmeZDw1zmRmitnsLOl8+qyiyRVeXlZjUVTXuUtw83qefC5PIpdgPD1+ZtVC8bNgVS1YVRt21Y7D4sBpdeKyOnFZXTgtLlxGgpu1+ruKjj4EL9uzc1HnDpDl9Xw5896BiYO4rC6qbN7KVhO9TFQicPGd7y9Lb1bvbC\u002fDiWF21u1gV\u002f0uXFYXDa4Gbuu4jf5YP\u002fvGX2I4MYxezO40RxpjXeFaNIvRf1OqURe0Al01nfgdfjKFVf8cWKbrOm6rm9e0vrq8n6RnpocH+x8ip+W4smEvB5fpmf++0\u002fdrxd355VGs0npxE0ya1dAKqFTf3QqKB2NGZ02Ym81ptSrNUp+a6aE31mcEMPW72Fq7lQ3+DZyaOcXhycOMJseM4rfqyqcy16Gmgj0wNfBeRpXsd12lGm5w1SuJXJJUPlWsiaQYezWW\u002fkCdx0hYcFk4N9VxTsuV97sok8Y+O6\u002fNS62zhgZXA3WuOqodfupddTR7mgFKeyBK2eKYTE8ylZkinU9X8hfaB7zsIviyzfbn9KCgaxSK+0Hh\u002fPXOMJZbrUlOi3O0oBeKxY61l2Vbm8\u002fn\u002f3z7Y9L59NreuLxMKhG4XDQzikW1kNfzPD\u002f6At2zPVzVcCVd\u002fi5URWVd1Tpava2cnj3NgYmDjCZH5wYwGVbZBsMFSGFS4KKjY7fY2Vaz7awLwVqgoXFF\u002fW6qnUYBueHEMA8PPFKueF0aRVoOqqJW8vktVrGWK69SG5ttVLAae0EvvKJz4ltVCzo63cUAZl3VOnbV7WRLzRY2VW+iP97P0cmj9McHyBQyK1oMVwFfBd+vtTq4Vcl+n3cw0Qxv6HqDJVvIMpOdYSI1wXhqgunMFPFcgkxxvwZQ3gOxgPdb5\u002f+3997xkVznme5ToXNGzsDkHDgkR8yZoEgF27IsQJYlS7bXaffa1jrsXYe910G+lrO9tmWv5ZVsWStAsnIgCYqZM4xDcnIe5BwanVOF+0d1NzAZmOlGmDmPfhBnMED3qe6uqvOe833vC6siRPRauHDSqps6s5lZwukwZ2bPokgKTtWJP+8OV+msJOS03C5r3TU0ehuRsPJyMlpG+Sf+o1xDvaY5y3yr5HnfvJDZaxrRCuBH1n0wVRCSltNanGg2RjzfC5vS0+cFHC9E0JRx5\u002fKGoxzCxXG1HyiUj0UyEZ4feoHTs6fZXb2bOk8diqSwLriOFn8Lg9FBjk4fZSw5jomZVSRl9WwvnE8GKInLlG7otAXbqHJVFU+K1YBpmnhUD2sDa4u5Ga+M7COlpVBltRj2eAOgsXoFNkCiTI+rsoBrw7XS5m+TplNTxHLxYqPjck3Ml5JCeWNhYqjkBUxfpI\u002fB2CCN3ka2VW6lydtEq7+V6dQ0ZyNn6Y30MZuZxTCt0tylvGF+YO37\u002fIOxIU6ETxLPxkv9\u002fKtylV439YRpkrfuLvnn1lPqByygSIqVHO7w0+xrxjANcnqOpJYkko0UdwYimUhRzOiGXuzZWOjq9GrHMI3irsN5x5zftbhUXktaS5PUkkWLd1VWcSoOvHYfQUfACu90hHCqzrLdOA3TcFzGyrgUlOteU3acilNTbSqVrsri+2dioBk6OSNLSktbYiYTZTYzSyQbIZaNkdRSF\u002fTOyshCsCyacggX20J\u002fsHCBHowPMZoYZU1gDdsrt1PlqkKVVNYG19Lib2EoNsSJ8Ilcb6R3xdqSXgUdKEmTryqrbK3YUvz7apmcmVguaIXms1jW2pTw2\u002f0FFxVJXeFlOQvBxDSwxMuqxDCNdEFElnhiIUH50rUebn5ITutpxpPjDEQHGE2MEc\u002fFrfKoG1jE3Nd4DydmTjGeHC8KgIKAARiIDTAUG6LWXcPmis20+Vu5o+4OdlbtZDQxytnIOUbiIyRzSZDmVsbLSaWrylPjrmVTaBPHZo5xYuYEKS29aCvny7CizRQux4NND+QmU5P0RweI5axrYwnfiwXfkxfLDwee1YOOgJW94gzisXmwy3ZCjhAhZ4g2fxuGaaAZOVJamkQuTiQTJZwJE8nMm8wZWQzDOO+6cyPx3rbHSGkpIpko0WyEeDZOUktaVsGGNjeRLU5iJSSJ87JvAOs11FKM5cWMLMkoklK2FcyAIyDrhkbWyKEbOoapY1xY9nWBsCn8vfjny7MaIwMA+H7vDxJ2xY5bdVmmBPO+XPnvBR1BFJ+MCcXF2qSWLIqZcCbMbGaWeDZOep6gF1ydcgiXRc8+Lfchk1Ph0\u002fRF+1nrX8O2yq1UuqpQJIVWfyvNviYpko5I3yhj+nYZMSjBtrdu6jR7m6j11BZTbKfTq6ZlgJSWImfkcCgOKpwVfHDtB9DmLtpSVstIn+ebyz3MBWNZPpqY88ohbLLNUGV11QqXR1seMdN6mkgmQjQbJZqNkcwlyRjWhRW41vC0sgoXSZJw29ysDaxljX8NKS3FRHKC\u002flg\u002fI\u002fHRvIgxUaQbq5xsS8VW1gTWcmz6GIenDpPSMsWARphrsB9NjjGaHCPkCLEhuJ51wXX516qNSDbKUHyIvkgfE8kJ0nqmmG9TDrJ6FqfixGPzsLduL+uD6zkwfoDeaF8pysdWpXBZH1zPxtAGdlfvZjg+TG+kl9HkGGktXSwpuo7JfNmES3+s3+yLWmLDLtvzE7YAFc5KKpwhAo4AbtWNXbHjt\u002fsJOAI0eButa6dpFFen8\u002fbHxetOLBsna6zWAouLafW3Fv9sCTmNrJ61So20BPGsZZsby8aI5xKktBQZPVO8PxYmtHO9MgpI1ifCKONk90fX\u002fYipmzpZ3bIyzugZ0rqVWZbWM2QK\u002f9UzZPUsOSNLzsihGTq6qaGbhnV\u002fN8\u002fPncuf46vyXAWYTE1e1Ldjua0p2GUHLtWJ1+61DBccQfx2Pz67L9\u002fHVIGMjIkVvZDSUsSyMWtnJhOV\u002f4PnlvHIVgflEC7XRKF8TDd1ToRPci7aS5u\u002fla0VW6l2VyNLCi7bVYOFVyoSJci4lZDYWrkVGctibyQxwtP9PSUYXvmRJZl4Ls6hyUPcXnd7sTzMJtusV8YEVnDPTsGXvrDVr8gKLtWF124lsIecIYKOID67D7tiZ7WGSK0JrJHm113Pv7CG02Gm09PMpC13m4yeWUwKtJn\u002fKgvHpo8Zte5aQs4QqqziUl20Bdpo9beS0lKMJ8fpjfQykhghkUuel3uxmiksBNxScwstvhbeGn+L\u002ftjAeY3AMCdgZjOzvD72Bkemj9Dqb2NjcAPV7mq2V25nc2gzs5nZwi6N9PrYG2UZ83fPftdo9rWwvWorPrufkCPEwy0PczJ8kjfH3iKtp6\u002fnvVmVW2tjiVEz4LB2LDZVbGJ9cD2RbITB6CC90T6m0lPk9Ny17h6W7bybn1mhmVpxJflcpLewkIPb5ipO4EIOS8x4bB6cihObbMfhcBJyWmakBUGjGRqaqfEvfKtcQ19STs6cxKk6cauWVbBdseO2ufHavdTkTd9M5o49p2dJ51fo49l4Pg8kTiIXJ6mlyOhpsvrFeWKlJqOnUSQVt+rGZ\u002fehSMp5ItrM\u002f8\u002fICxTd0MgZGpqRI2vkimKnENxcyHBJ62lyhrZyb\u002fhX4cLcoQJ6Pl4hqSWZSk8X5wuyLONQHHhUN35HgIr8jmTAEcBr81LvqafJ24RhGjfOqloZKYdwua7V5vkC5lT4NL2RPpp9zWwKbVTr3LUrRmgtEpnrfK11U6fBU0+jt7EYUHV85jiR7OrpRZUlmUNTh5lJh1kbWIPf4bfcxYCcoRFNR1bEhaywklK4Iaiyiit\u002f861whPKOL0G8Ni9O1YlNthUvZIZpqDkjV7ZejnLz2uhrpsfmIeAI4LP5ipOOkCNEi68lv0pqZQ7MpGcYT4wzkZxgNhsho2UwuWx\u002fiYm181gW9o3sN+2KnUpnBc2+Zpp9zQQdwfNETJu\u002fjXguxkBskHOz55hITRaNIVbrLsyTfU+xrXIra\u002fxtVLoqeaTlEU6FT3Fg4gCJXOq83ReYs3pOaxmOTR\u002fjdPgUte5a1gfX0+xrptJZSaWrkm2V2+R1\u002frXSq\u002fx+ycccyUb18NQhzkXOsqNqB1sqtqDKKlsqtlDprOTFoRcJZ2avVbysynvE93uflL12L62+FtoCbVS7qqhwVlDhrGBr5RZm0mH6Y\u002f0MRAcJZ8JohrYYEbMkK9vnNRfPEzORTJTZTIT+6EBx0ceh2HGrHnx2HwFHgIDdj9\u002fux21zF6+pNqlsG0VLzvODL+R3MVXsisNa9LJ58Np9+G0+vHZvUcxZ9sFWuVGVZDmHF+5JuqmjGTkyepa0liLv6Fa2Vfpvnfm2JMsKdtmGXbGsja0vJ07VgVNxFsdsV+zYFTs22YZTdeGVfcXPaKEPpHAseYHm\u002fhu+VJZxLwGXvGFcyW2tIN6mUtOcxUSWJGyyHbfNRcBu7VIGHP4VMQda6aw44VKgIGAMDHqjvfTH+h0uxblaJ4Qq17ldLyGxvXJ7IRODqdQUg\u002fFBPLaSOCwvGbIkMxgfZDA+WFy9ATBMw1gus4HzdlMkCYfiwGfzUuGstCYQrgr8dj9O1YkqqciSXLz45vQckXzNciQTYTYzq8ZziVUbf\u002fvu5EEnWO9ToYbXbw9Q4bQEW8gRwmvzEHKEqHRWsj64nqyeJZaNMZmaZDg+wkRynFg2bjl9zU2udMpY01xY7BhLjjOaGOPdyYNUOSvzZabNBBwBZEnGa\u002fOxrXIbm0KbmEpNcXr2DP3RfhK5xKrshRlNjDKeGGd9cB17avfgt\u002fvZUrmFOk8dr42+zkBsAEVWLtoNK6bNA8OJEYYTI\u002fhsXlp8LawNrqXCWUGrv60sY5YlOSNLMkktxaujrzEQG+Cu+ruocFVQ7a7msdbH+OHAs0ylp65FvJQ82HIpkCTJGcvGODR1mGMzx6l0VtLmb6XF30LQEaTWU0uNu4ZdVbuYSk\u002fRH+1nKDbEbDaCbuhX++wuWy\u002fBpcQMQFrLkNLSxQwQawdUxibbiz0CTmW13u4vptBzppk6Wi5JIpewyo3yVQZzZUb2vGhx47V5i+VFHpsHt+rGodhRFRt+xUHAEUBCQje0sl20MkY2hw7JvOeFJaCsPxUoBGPKkowiK6iyiq2Y4ZIXO3mRMyd4HKiybTW\u002fwYtOiryUAcN8Yd8X7UeSJJHjsgDKIVxKmog4L0vBltLTq\u002fWD7uA6HJUKuy1NvqZis\u002fGx6WNk9VypGlqXlPmTkaJdIEtbuqPlt6kLtpMBRz4MzFVNhbMCr82LXbEXb7qGaVgT9FyMSDbCTHqm6JaTuKAHRJKkVStcVFktKuGckWM2kyWcmaUv2lesY\u002ffZvVQ6K6lx11DtqibgCFDhrKDKVcWm0CZSWorp1DRD8SGG4yPMZsLkDE2TJLmsResXJIYzmhxjJDHKO5PvUueuZW1gLY3eRtw2N4qkUOuupc5Ty+7qXZyLnON0+DQzmTBQ1vDFklIY58nwKUYSo9xWeyvrg+sJOUM82voIh6cO887Eu0UReSHSvMeI55IcmT7KifBJAo6AsTG4sVyrfwmY2\u002f0Zjo\u002fyg74nubfxHlr9rfjsPh5peZin+p9mdvE7L2Vz0Cozgfnio5Dx8e7kQWrdNbT522j0NeKz+Wj0NtLgaSBdk2YqNcVAdICh+DCRy4uYFee0dl5p6byJXNbIkslkCGfCK7ly+Jq50oq8VWaUJqmlmM6XGQHFslabbMOpOHDZ3NZuTV7Y2GV7OV3FEqYJUn7MhbLgS\u002f4sBoaRd5WbJ3Qu1d9iOWnJq7b2nxJl8l1O2AuuTDlmveWyuHNISKtre2EOD9eg0AvISOyo2lHcbZlMTdIb7Suu4qxmlss9ZmNogxR0BKVqVzVBRxCX6kKV87sppolmasSysXn5BFOE8\u002fkEBTvDouNW\u002fiY8T0T6luWgSkOw8IfLlX7MpMNMpaY5GT6FTbHht\u002fmocddQ76mnxl2Dz+6jxd9Cs7+ZjJ5hJjXDYHxIG42PLtnK73wRkzNy9McG6I8N4LP5aPW3sC64jipXFTIyHpuHXdW72BzaTH+sn+MzJy7MkFrxqLJKIpfgxaGXGI4Pc3vt7XjtXm6puYVqVzX7RvYxm4lccaHDsuK1\u002fj2cDpv7RvaVa7jn1beqskJKS\u002fHswHPc13Qv64Pr8Tv83Nd4L0\u002f1PY1maIsp5QuUfrjlxzCNivlioyA+NFNjMD7EYGwIl81FvbuONn8bdZ46vHYvzb5mmrxNpHVLxAzGBhmODzObiRTLySRJWjX1xDfzRO5qoY5Zw+oXmc1Girse+derbKUK2yq2xjVTK7igmWk9I+X0LFreHAjmZZQUxn9hv+Pl38dQucZdbnRTD94sVt4rkZILF9M0I2WqF1dYvR\u002f0INcoXDRDY02gjWZfc3HV9NDUYbJ6dlXutqwU7mm4R7IrdkmSJEzTzO8uzDKTnmEiOcFkaopIJkJKT+V3UuYSoRdQUlS2pOol4IpjvzA4zTANwplZptMznAifxKk4qXRW0OhtpNHbSMgZot5bT72nPp2uSqf+ln9fkoO4cMxzuwpxDk8d4cTMSeo8tWwMbaTZ24xDdWBTbGwMbWRNYA1DsUEOTx1hIjm55OO9VgrvyanwaSaSk9xZfwct\u002fhaafE08vuZx9g3vYyA2uKDrRqFUsEzMXOr5dFPn5eFXsMt2mn3N1Hnq2F29izfG3lyMgKwq7VCXhqAjWB3LxsgZ5zfgzxfgGS3DuUgv56K9eFQP9Z46Wv2t1Hnq8Ng8RRGT0TPMpGcYig0xGB8ilo2tHuvJGxTN0PITe2uaey0T3uUQdXc13BWTJTmnm7otZ+SkrJ41C6GLlgOaZRqQ1BKktDRZPSNZTmhzuWxXsNWvWZqjKD01rurqgtFAztSKVt6wsLBJwfVR8pmvz+6bjuViRbehElNb6gdcImq5hkuNaZo4FAd7avYAVknHUHyIvmifEC3XSU7PksglmE5PM54cZzI5SSQbJa2nizXXBWvWa3it68sx5nLT2d3uZJETvwuFTNbIMpwYYSg+jE22UeEM0exrptHbONvia1n2wLHCpNDAYCg+zFB8mApHiI2hjawLrsNj86BICm3+NTR6m5hITtDNM8s97EWhyirRbJRnBn7I7upd7Krehd\u002fu55GWR3hz\u002fE2OTh9FWoK8liswdalvypKMZmi8MrKP9695Ap\u002fdz9bKrZyL9DKdnl7o\u002faShtENdGj6w9v014UyY3kgvg7FBotnYReGg853wUlqK07NnOBM5i8fmod5dR4u\u002fhTq3JWIavA00eBrYpe8ikYtPfonvL+fh3fRsqdhCzsgSzyUse\u002fm81fFFyerzxckKYDo1FVEVW8KhOIJ22Y7D7pAKvTVwvhNaVs+S1tNmMpcknotbFs+5uJUkryWxdmvmnNBMzKZlPrxr4tl3vyJlFb1eM7RiSKgl4GJFMZfIJfPOabm5fKL5YqY8gZ43DSWf\u002ff7Iug+OD8WGeHvibcsZ5hKNoddBS6keaIm5pnHrps6t1XuoclWhGzqaqfH2+NvFG5rg2vle7\u002ffNtJ420nlLX0mSkSXpPHvP66D16j+yIglxnSvW81eIDQwmU1OMJyd4d\u002fLgWFdHT0n7366H+bsw4cwsr46+xpHpo2wMbmBTxSZ8dh+qrNLobVzmkV4Zw7TcaS6kYCDx1vgBptPT3N1wFx6blzvr78Rv9\u002fPG2JuX7XtZAiaADJfo+5MlmVg2xoGJt7m\u002f6X7sip2tlVt4afjlhT72qrtHPHukW8mhNdS566j31JPKBwxa9t2jlwwHLZgrAKRyKU7PnuVM5Cxu1U2tu5ZmXxP1nnq8Nq\u002fus\u002fsnlvP4BHB\u002f032YmBTCHNP57JpYLkY0EyWajRLPxfOiJotmavlSrPxO\u002fzIJmq+f+easS3XO2hVHsBC26LV58dq9eG3e8+yd86YKUrWruvj7hmkUbfULuzV5YSMltWTjLT\u002fc7fndR\u002f5q2Re0FsPJ+Olgpauq3qW68Nl9hJyh4rlpYKAbOlkjO\u002fceZ2NWRlE2Sjwbs3pi9cwl32NWkGhdyZRcuCiSMrg+tJ4GbwNHpo9yfPoYaT1Tqh2C9aV4kGVg42J\u002fQTM0WnzNbK\u002fajm7oKLLCoYlDjCXHxW5LCYhko6ZUOqFyIWtL\u002fohLQwPzelyulwt2Y8ZK9bilprALk8glODDxNifCJ9kU2sSWis147Su7rc5n9xDLxi\u002fTeG\u002ftFvZG+ohmotzfdB\u002fV7hq2V23HY\u002fPw8vArZPTMcoiXKaw+l0uWiiiyQm+kj22V26h2V9Psa8Zr85LM5+9chbYSj7XsnJo9XVXnqWv22DzFXfY2f8G+O85IfITeaB\u002fjyfFLBlJaIsYS4WktTW+kl95IL07VSZWrKtzkbRxdzuMTWPlJNtmGXbFZ4auqhyrXnNWxtWuRI61Z2S2xbKzgUkk0Gy2u4BeCp5ewHCmVNXLhjJ5ti2aj5zXaF1zELCc0K6OmYPHsyzuhuVQXTtXJpXZrDNMI6oYWoHx90WXh5eF9dYosVxaCJj3zbK19dl\u002fxuL02L0FHsHh9NU2DnKGR1tMkc9Z7PJudJZKJEMlESeTiZPRlMwBcVZR8BmyYxqBmaDhUB3vrbmddYC1vT7xDf7QP4\u002fqbXTeVapxLzJbF\u002fLBu6lQ4Q9zTeLdVKoDEeGKMg5OHboiG\u002fJWALMnlvNqv7exud66kHYYFspHyVU8PlOlxS8Zcxkmatyfe5mzkLGv8a5Z7WFfkibYneGn4JUbio5e9NqiyykwmzFN9PdzbeA9tgTbWBNbgVJ08P\u002fgC8Vx8qXdwZ4FRLiNcJCRyRo6+aB817hrcqptqVzW9uV4UrjrOls7u9lBXR0+4xGMuGy8Mv9jkVt0VTd5G2vxt1HpqcSgOTNMsBlJuCG0gmokyGB+kP9rPZGqKrJ7NN9\u002fLxZN2fjlZ1sgyFB8aPzBxYNW8Fjcq3z777WK+yXyrY59tbqLrUBx4bB78Dj\u002f1HqvauJCbldHTxLMJotko4UyYcNoSNEktSc4oX0zPf3z0OaOzu338cr01hmmQ1tKktBQzzJzXsF8IIHUUd2O8+PLHnT\u002fmINYi30jZDqAMmJhtOUOz53SNeC7OxEW21ioOxYE7L178Dj8Be6Bobe1UnVS7q6nz1BV3aXJ6jrSeJpFLyF\u002fh6WU+wpVPyYWLZuRGbIotCvg1QyPkDPFwy0MMRAd4Z\u002fIdJpKT15OXsL6zuz3Q1dGzalxSOrvbPSxCcGmGRtAR4KHmh\u002fDafJiYpLQUr4zsJ2tkRYnY6qAJaATOLvdAFsmeMj72uTI+dkkplOHEsnHenXx3uYdzRSz3rft4su8pItnIZa8PiqSQ1tM8N\u002fg8d2p3sLliM\u002fWeetpbH+XZgWeJZKNLdm3p6ujRO7vbzwG7LvczkiQxkZwo7jZXOEOci5xbiKyuxdp1WTWTdQlpUzKXlI7PnOBk+BRBR5AWXzOt\u002flYqXZXFe6Xf4WeHcwdbK7YSzoQZjA3SHx1gJj1zUVN\u002f\u002fnFRJKX\u002fpZ85siQBlILLY6XI54jnEkymzPMmuoqkFEutvDYPPrvfCuR0+PHaPLhUNy7Vjc\u002fupyHfwqWbOtl8n2Yil1DK3Id32UWnqzmh5UvEiGXjmObERbs1iqTsBl4p07jLxc4r21rrJPNZPRPJyWJ\u002fiyzL2PM5RT67l4A9YIWvOgL4bF5cNjdu1S1qxRZAyYXLPxz83OTdjXePbqnY4g85Q+iGjolJq7+VBm89J2ZOcnjqiLXKt\u002fj+l0ascrEDpR53GVnHAuquC6m49Z567mu6l4A9YPmimwavjOxjKjUlSsRWDy6sSdlqEy57y\u002fjYZ8r42GVhvj3wSkU3dfwOPw803c\u002fT\u002fU+Tya\u002fCXwpZkovXk4yeYVf1LqpcVTza+ig\u002fHHj2WjJTrocjwI9d7h8lJFJaGs3UULCylhaIDNwCvFOCMS4Vt83vWSm4Gx6ZPkqls5JWfwstPiuIsmA3W8hN2l61nZnUDAOxAQZig8xmwmjnZ7kcLefAC5MywZW50kTXYG7XYn5+S2HHwqk68do8+O0Bgo4AQUcQn92H2+Ym5AwRdATL\u002fQacutZfvJITmmGamKZ26\u002fUMbJl4z5X+8bz3+lKW1sWcIksPFoSrx+bGrXpEAOUCKPldueeTBzK+r\u002fjPno2c27S9chtbKrbgVJ1ohoYiqeys3klboI1Dk4c4PXuanK4tpvxJAu5kdQmXu+Dy9Q2GaYkTp+pkV8UudlbvwCbb8gm1JvuG99Eb6RWiZfVxH\u002fCN5R7EQunsbq8HdpTp4VOsoh2X1cTro6+zp2YPdZ467m64m+eHXrjiZLIwiXhj\u002fE00U2NPzR4qnBU80vIwz\u002fQ\u002fs5Q7L1cVFrIkUyiCMsxF3c\u002fvB\u002f73tQ1rWbhz\u002fl8uF0RZ46qm1d9Kk68Jv90PWJOeanc1tZ5adlXvYio1RX90gKH4IJFMFBOzrPdKh+Igo1vhuxf23ggWxpVETSFPLJqNMhy3KqoKgsZtcxOw+3Hb3OWe7B4rx4PmD\u002fP2zu52W1dHz6rYFXz0X2\u002f1GaZx27X2Fl1OyGWNLJl0hmlmbsDY1dJTlq5Mm2w7nNEyvDH2Jt879z3OzJ6hkLqqGRpem5e7G+\u002fmibYnaPE3FyfvC+TRcoy5XJim+VhBhBSOUzd1LK9zA5\u002fdx67qnXxw7fu5ve42VEkt1ni\u002fNPQSJ8OnbnjRYrmt6GWt1V0GHuzsbl9NdX13Ub6cpGHKXMesm\u002fp56cw3CwcnD\u002fFm3iFsXXAdt9bsueq1tHAtfnviHd6eeBvTNKlwVvBwy0N4bJ7FioRr5RCWoL0khmkQdARQZRsAsWxsMY99d2d3+6pI5e7sbl\u002fDFRYMCjXzuqkznBhh38h+vnP2OzzT\u002fwwnZ06SyCWQkDAxUWWVek89dzbcwQfXfoD21kczm0Kb3i3n+D+49gPK423v5dbaPTR4GnAojqI9rm4aN+U5WUoK56oiKaiyWgxJ1kyNSCZCf2yAY9PHy33CngCSZXrsjayi3uUdldv3+u3+ZlVSip\u002fzgq21cR2f9\u002fnvc7np7G5f2Y4zC6BcM+IDha3vcGaW5wdf4JT3NLfU7KbOXVecqNa4a3i05VH6on28O3mQqdTUQvpf7u7sbq\u002ft6ugZL9PYS8ZPfe2JOgnpPpjftGXHa\u002fNS4aygxl1DlasKl+qyBE2+nnsqNcX+kf2MJsZuaNFS+By4VTdrQm3ybTW38nWeX+5hlYrtwG5Wz+7gZct2SsCxro6ey05SS0GTt1EaT06Q1bOltmBf0dgUO8fDJ\u002fA7\u002fOzKZ7ZEMlFOhk9e8doxX7woksLu6t1Uuap5sOkBnhn4IVk9W84ASoA+4DSw85LjkyRa\u002fa1IkkROzzGeHF9MX+Q64HbgxZKMtLw8DHiu9kPzbcazRo7+2AD90QHcNhd1nnra\u002fK3Ue+pxq25M08Sm2Gn2NZ+9pWp37x\u002fy92UbvN\u002ful0L5rCbNsHo4plPTjCXGmUiNM5uJkMlbzltGAiKUrxQsZRilx+YZjGVjZwzT2Dk\u002f36xE2LAWo4+U6gHLyaOtj35QM7Si81s0GyWSiRLLxkjkEqT1FFk9N8\u002fq+PyMnkIA6TLz553d7e90dfT803IP5Fop16z4XSANOAs3m6H4EGOJMdYH17GreicBR7DY\u002f7IuuI4mXxMnZ05yZPoosWzsSpOPSuBx4ItlGnvJ+ND6H3vcMI0KmBMuqqxauyr5xPZCH4ssyaT1NIenDnNo6jBpPX1Dixbd1FElhQ0Vm9hZtZOgI0g6l1oB53TJkIGfYBUIl87u9lrgsTI+xetlfGwAHmt9TJ5KT3Fs+hh90f6bRsBIWNeWt8YPELD7WRNYy5317yGajTCWHL\u002fiCl5BvLw1fgCH4mBr5VYavA3cWX8HLw2\u002fzNHpslSIAMUG\u002fX1cQrjopk6Vs4oWXzMAE6kJptMzizV06WAVCBfTNH9isZPA+SImrWU4N3uOc5FzeG0e6j0NtPlbqXXXYpNtr+\u002fZ0F5Wf9WXhl\u002fSq5xV1Hnq8Nst96SQI8TawFpyRo54Ls50ai7kdzY7J2REadnq4F8+9E3tL174nYOJXHznVHqaaCZKWk+hGVZ4ZgkE6Y8Df1Wq8ZaL3\u002f7Bf7LFstFH3TYPIUeIalcVElZeViGrJpO3s7YCKePE8vk8VghnmqyeRTc1jAtFzdIK+jrgHzu72\u002fcCn+7q6Iku1ROXinLNjHuxVtOKW+CKpGBgcHzmBP2xAbZVbGVL5RZcqgvN0FDz\u002fS9rA2s5Mn2EkzMnSesZFFm91Nv506wC4eJSXZ+Yf7MtbCOalhm69WE1JWLZGH3RPk6GTxFOh1Ek5YZ1DytspzZ4GthTcwv1nvq8iDPI3nge5h2d3e2f6eroWVSdyzLwE1xn8ORV2FfGxwYoGlvUumuZTE5ybOYYvZE+MnrmhhcwElK+6X4\u002fPrufKlcV9zbey5N9T5LIJa844S+8Lq+NvoZLdbEmsIb1wfXohi51v1xWpyKAHuCXLjWm3TW7sOfLjo5NH7uW0N0PdXa3\u002f4+ujp6pko22xPzOU7+4fSA2+EBaS1+zzf18++NkLsWp8CnOzJ7Bb\u002fdR7aou+\u002fb1iZmTJpzErtgJ2APUumuo89RR5aqyKgscFVQ4K1gfXF8UMjOpGUvIpCaJZCKk9QyGaVCG1XxBidhVveMNkD6umVZafDQTZTo9zVRqmnBmhlg2Tmbe+7jIyfidnd3tt3d19LxZ7uO4HnpjAw8MJoa3OBUnbpsHn92H3+4r2hy7bW6cihOv3Uu9VF8s4bRaA6yMnpSWyouaGJFsNC9sEqS0FDk9h27qS\u002fHhL9Tk\u002fwzwns7u9p\u002fr6uh5bQmet2SURbh0dfRond3tr3BB7W4hEC2jZXhz\u002fC3ORM6yq2on64Lriv0vbpubO+rvYENwAwcnD9Ib7UM39QtvWg90drff09XRs2Jt9J48\u002fO93AQ8UtgvnQqasAKJ4Ns5UeorxxDiTqSlSWqq4K3OjohkaPruPW6p3syG0oXis0UyUU+FT5kvDL91oBdFtWCu\u002fn1\u002fmcVyWzu52B5eYPJaQUax+hrLy\u002fd4f6BuDG1gXXEetp5ZqdzXbK7dxdPoY5yK9N7yAkSWZpJbkpeGXeW\u002fbY1Q4K7i74W6eHXgW4yrOT5IkoZsGrwy\u002fgtfmocpVzcbQRvlfPvon0s\u002f+3f9dzmHvAyaBYtS2ZmhsDG2kzd8GULT8vYaFnFrgp4C\u002fLslIy8C9jff+p3AmbH9n4h36ov0A1xUGOt+ZLJqNxUYTY2XfcSpcw3VTZzo9zWRqkqMzx3AqToKOYFHIVDgrcNvcRSGzLrgOzciRyCWZycwwkZxkMjXJbHqWlJZCN\u002fVyD12wCKZT0y\u002fIkpJz29w2T37S3uhrxDRNskaWZC7JbGaW6dQ0U+lpZtNhEvmMmeLu2uVFqQz8IrCihYuJ+atZI0dGzzKbjWDG53ZNFEnBnneAc6sefHZvXtj4LxI1dVJdXtQYaIZOzsiS0tKFcrPG97\u002f6fvmTd\u002f7XpXIX2wa82Nnd\u002fttdHT1\u002fsUTPed2Uc5b8FJeZEBUusJFMhBeHX+JU+BS7a3bT6G0ErJtXyBniweYH2ZQY4d2JdxlJWOG\u002f8y7sv8UK9v\u002f+xulv\u002fLpTdeXHa6Lnk3GzepaMniVn5OZWmW5wwVJo9t0U2sittXvw5R1xMlqGE+ETHJk6SjwXN922Vd8zdil+vbO7\u002fcvl7vG4Dn4a2FrGx391KcIAJ1PWxOfYzDG2Vm5lXWAd1e4a7nNVsa1ya17AnCNzA5eQKZLCRHKC10Zf5\u002f6m+2j1t7KnZg9vjL151RV9WZJJ6WleGn6Zx9sex6E4kMu869vV0TPZ2d3+PPARKDTkB7m99jYkJNJamrfGD1yP5e6vdna3f2El5n798bO\u002fvjGtp3+mxl3Dwy0P0xft4+3xt5lOz5Tk8ylL8ivf\u002f\u002firSxb6WlhhL9yfs0aWseQYo4lR5KnDuFRLyNS4a6h111pCRnUTcAQIOoOs9a9FM7XiBHgyNUUsGwWeW6pDEFyBjm\u002f852M\u002fdcsTR7w2zy0FK+5KZyV+ux+X6iLoCFLhrGBNYA26oZPRM8RzccLpMFOpaWbS00SyUVJaCs3QAJAkGXluV+YnO7vb\u002f6Kro6d89anXQWd3+0PA+67UW5QxsqQzGcKZ2YtFjWLHpbjw2j3Fkkorp8cSNX67nwpnBSbmNkVStgGHl\u002fDw7Fh9L\u002fcBv9TV0bPiA0HLOVveD4xjrXxdksJFbjQ5xnh\u002fD23+NnbnswUK7lsNngZq22rpi\u002fZxaPIQk3MN\u002fB\u002fo7G5\u002foquj5wdlPIZrorO7\u002fX3RXOxDs9n590vr9CxYH15HCOeqQjM0Ao4Ae2tvZ01gDZJklbUMRAc4MPE2U6mpomPKDcpm4FeAzy73QC6ks7u9Cvi9Mj\u002fNd8v8+ADFFfnZTIRXhvdxbPoY2yq3nSdgtlZu5cjUEXqjvWT13OXKUFc1qqxyevY0lc4KdlXvYkfVDqbTM5yZPXPVc0yRFKZS07w29jr3Nd5LnaduKYbcBXzExGrevrP+Drx2L2DyzsS7i86vKpThAiDRBvw68D9KPurr5NDUod\u002fti\u002fZ7d1fvYm1gLeuD66n31HN46jBHp4+RM3LXWy7cXaqxXgvz+3AA0nqGkcQow\u002fERZEnGWRAyrmpq3DVUOENWsrrdh9\u002fhp8Xfgmma\u002fCH\u002fsJyHISjwxxi5rtyzM3r4lqnUDKfCp1FkBZfixO8IUJkXMxXOCrw2r5Ucb3NT667FNE00UyOlpYhlY8ykZ+aVmMVIW3baThPz97HKllcUeXfQz1zt564oavQMaS3NTGbmvJweu2LDpbjw2X0F8WdTJOWXgF8u8WEshA8Cezq723+xq6Pn+8vw\u002fAumbLPFro6eqc7u9ueAj17tZwsX6LOzZxmKDbExtIHtVdvx2\u002f3o+Qaw9cH1NPuaOR0+zZHpI0QyUWRJ+bOPfvWxl77ykafj5TqOxdLZ3e4H\u002frJ44b5JKRgPrA+u5z11t+O1+wCIZCIcGD\u002fA2cg5TLiRBct8fqezu\u002f27K201Katn\u002f0SRlabChfRSFC7Ec64oLGY1OALljXS+kMKCwHkCpsoSMDXuGh5ofoCtyS0cmjpCf7T\u002fUmWoqx5ZkjkwcYAKZwXNvmburL+D2UzYWs2\u002fyrGqslps9P7th\u002f4C+Hi5h\u002fsM0KcbetvOqh005xvy+yL9HJs5uuDej0JpkU22YVNsyJJsNczqud987F9v\u002f9bTP\u002f3m2+U6gMXS2d3+CPDx2cwszw+9wJnZs9xau4dady3vqXsPLb4W3hh7k9HEKIqkXEvPxxjwvdKP\u002fGI0Q1tQk\u002f2FQiajZRjVRhmJjyBJEk7FgT\u002ffn2UJGWtHRrBykCTpOxLSb8jz3uaUliahJYvvo01Wcasego4gVa5KKp2VBJ1BPKqbYomZtxHDNMgZOVJaimg2ykx6hunUzIf\u002fx9NbO\u002f7gsb9fVtF9CX4DuON6HuByoiZnaGT1KLPZCAOxwcIOzc93drd\u002fr1yL8nM7XpfsRWoCvtfZ3f6nwO+u1Hydcs8au03T\u002fOhCL7yqrKKZGoenjtAb6WVr5VY2V2zGpbrQDR1VUtletZ01gTUcnznO8ZkTW2PZ2F8Av1Dew1gUf4XlTX7Tops6DsXB7bW3sbliM1I+sft0+DRvjR8gnovfLIKlgA\u002f4587u9ge7OnpWhAPBl9\u002f824\u002fOpGd+FiyRaWKgmya6oaGZGjk9R9bI5ksbM2T0LFk9Q9bIFX3rL7J7vLgZ89mujp7hZTg8azdTgnBmlpeHXuH49HHr2uFfQ52nnmpXDaOJUQ5NHWIoNoSBecMIGAkJzdDZN7KPJ9Y8gd\u002fu556Ge3iq7yly+Ynm1X7\u002f8NRh4ze\u002f\u002f6my95x1dfTEP\u002fyVh74ccoZ+Z3fNbsDKbHlt9DWMvIXulbAysgzq3XVsCG2g2lWdL3Oz+nYSuYRTN\u002fUvfE975T+piv2kJEnLWjbW2d0eBP4O5ioOBmODjCXH2FqxhR1VO2j0NvJ4WyVHp49yaOoQKW3RDpNf7eromS754C\u002fBbbW3ypOpKSaSE6S1NDDnMnUlJElCYU7IZI0ck6kpxpMTHJs5jk22YZfLasctWDyvY4VRFkuLL3wfddOwLIKzEfqiffldBSsCIuQIUeWqpMJZYZWY2Vz48zsNLb6WwkLDX3\u002fn3dte\u002feDuTy1ZmeOV6Oxuvxv4g3I9\u002fmUEjQJ0d3a3\u002f0JXR8\u002f\u002fKfVz3t1wF\u002fFcnEgmQjwXJ6ml8m5nerEfSUL6LeDun+h6+Oe+1vnsiVKP4Xop6+yxwhF6TjP1\u002ftnMbCssrPGw0MCf0tK8MfYmp2fPsLNqB+sC61AVFc3QcKpObqu9jQ3BDRyZOvLzgf\u002fwH\u002fnih7\u002f7P8t5LAuhs7v9N7CcGm5aNEOj2lXNPY13U+OuASCRi\u002fPG2JucmT0D+ff3JuQu4B9ZAZ+P7x784k5VVv++2l19xVXSQtnN\u002fNDUrJElraVJ5pLEcrG8l32MeC5OKn8BtHq3ZBRJ\u002ftclPKxLUhAw0+kZXhh6kWOu4+ys2kGLv4UmXxN1njoGY4McnDzIWHK8aBG8WrjcjlFh12n\u002fyKs83PIQdZ46bq+7nVdG9lkTjasimX2xpZk7xLKx\u002f\u002f1Iy8O\u002f5lScHhOTA+MHiGSjV71OmKaJIivsrbuDTRWbirkzhmkUc0MCjgCGaew8PPzaF29pue9bpmmeBvZLknRyCQ7tUvwzFwTuKbKCbuq8O3mQ\u002ftgAt9bsYW1gLXtq99Dsa+at8bfojw0s9LOZAf5XuQZ\u002fIbfU3CKDJTbHEmMMxoeYSI6TyCWLNv8Lve\u002fP75HRTZ2UtlLbAm9Oujp6sp3d7V8F\u002ft\u002fL\u002fcylJuI5I1csDzs9expFUnAodjw2LyGn1RtTEDNu1V3nVJ1fMk3zMUmS0uU\u002fqsvT2d3eCnwZqwdkqfECX+7sbu8A\u002fgLY19XRUxLHil3Vu4pmUTk9S1rPkMgliGajRDOW6LSMApJ3Z4zMaz\u002f2f+7\u002f1W\u002f+5IvLfi+fT1lnkP\u002fwo92x7x78wjcHY0O\u002fdmjqMNOp6fMuTldifgP\u002fS8Mvc2LmJLuqd9Lia0FGLjpU3dVwF5srNv\u002ft4wcelzpu\u002feW\u002fLefxXInO7vZfAP5suZ5\u002fuSmcCBtCG7iz\u002fg5cqguAodgQ+0f2E87M3qyCZT6f6uxuj3Z19Pzacg3g9VPf3xzJRr+DRAgK7QDz+gKYs+2e\u002f2dFUlBUBSdO\u002fHb\u002feTeowgUwpaWJ5WKE02EmU1Mne\u002fp7epbquK5G4ZozkZrg2cHnqPfUs7NqB02+JtYE1tDobeBcpJdDk4fymSEK8iqwZW32NjOcGL6kAFVllb5oHwcnD3Jr7a1sqdjMVGqK4zMnFnQuLtX5+vRPv3nu04d\u002f7cvAzw\u002fHhzkTOXt10YKJLMvc33Qf6wLrMDGZTk3TF+1jJj1DztBw5C16q93VJHKJLU7VFd\u002fScLsPuMU0zXPAc5Ikld3xrkBnd\u002fvngA9f6t8KC3aRTITnBp\u002fnXKSX22r3UO2u5tHWRzkdPs3bE28TvXLGGcDXuzp6jpbtIC6gsELrs\u002fsIOAJsDG0kqSWZSE4wFB9iNDFGNBtFN\u002fRF5X0UylIFK44vYxkjLbiOb06Uzn0vY2RJp6eZTE1Bvr\u002fNoTjw2jxUOCvue37w+a76v3D8xOivZ5alVKmzu70Rq9yydTmefx4fzH8d7Oxu\u002fyHwMnAcq3881tXRs2j3sVPhU4ZLdeG1eXGqTnx2LwFHgEYsc6xCGV\u002fGEjSBWDb2xR9\u002f40MPNHobP\u002f3g1g\u002fPlu7Qrp2y35lUSf2X9cH1v9zib7GfnT3LkemjhNPhBa\u002fEzJ9w\u002fHDgWRq9jeyq3km9px6wVmaCziCY\u002fM2bvc\u002ftva3twT+QJOlUOY\u002fpQjq7238d+POlfM6VRGFl7fba29hZvRMZq7788ORh3p54xwqbFKIFANM0f\u002fXHv\u002fKg5+t\u002f+fwv8SbaUj73f\u002fn2R29\u002fY\u002fzNb6qy2miac9c7KX8uKpKCKikohaDUfFhq4c8yc+esVaJjFv+ryjb8DjsBR4BmXzMS0r\u002f8yeP\u002fa1lXzC5FYXdiJDHCWGKMZl8TO6t3UueuY3PFZlp8LZwMnyw43V1zvsZS0d76KK+Pvc7hqSOXPMcUWeHdyYNUuapo87ext25v3rZ2akWVxumm\u002fpfAx49OH3UtJLPFMA1uq7mVdYF1GKbB8ZnjvDV+gJSWKk56rUpGa1Lks3tpmnjn9r2Rc\u002fITWzpeATYAG0zTPAX8QJKk0+U6tnxz7\u002f9iAbuthfPrXOQco4lRdlXvZGvFVrZWbqXR28DbE+9yevb05XbacsCflnr8V+Js5KxR5awk4AharzkmLtVFm7+NNYE1ZLQ00+kZhuPDjCRGmEmHyepZkdmySunq6DnT2d3+bRbQu3wlLiVmskaW6XSGqdQ0siT\u002fyP1N93+Lbj661AGJnd3tG4BvUV63zcWyK\u002f\u002f161i7qlPAZGd3+wwQwwp8X8iOjP7c4PN3SJKEQ7bjUl147T4Cdj8BRyBv3+zBqbpwqZZpQL2nHt3UP5kxMnc8dfjLP\u002ffeHR8rey7b1Sj7bPLxnR8\u002f8oNDX\u002fq6XbZ\u002fdGvlVtYE1nAqfIpj08eJZqMLbj4sXKStVZxR2vyt7KjaQbWr2lrtx2AqPvKxA\u002f3P785q6b+3KY5vS5JUVlu3zu52N1ZPy8+X83lWMrqp41Qc3N1wN+uC6zBNk4ye4dXRVzkdPoMs3xzuaZejYFJQKGvx2DyEnMGf+\u002fu\u002f+oP12yu3f\u002fL+LR\u002fqX4pxdHa3f2wqPf25yeF9PoNLL9IUGvALu6KyJKNKKjZZxa44cKlO3DY3XpvX+rJ78agenKoDVbYV32fN0EbTWvoLS3Fc10rhetIfHWA4PsKaQBs7q3ZS5arilurdrA2s4eDkYc5Fzi7zSK+MJEnsrdtLRs9wKnz6IvFSCKfcP\u002fIqQUeQoCPIPQ338GTfk2T13IqZOL5v5ydO\u002fsMrf\u002fiF8eTEL1\u002fteqGbBjWuGrZVbsPE5PTsafaN7Acu2CWad2ixbJyj08c4GT5160uDL9h+9c7f+Ua9r8kLbAHWmab5JvA9SZJKat2dX7n9AvDoYn5PlVWyepbXRl+nL9rHbbW30eRt4v6m+1gTaOOt8QNMJCcuvH\u002f+a1dHz8FSjv9qvDD4omFX7FS5KmnyNtHobSToDGKTbZimiU2xU++pp8HbgGZoRDIRRhOjDMeHmUxNkdSSxbK+m\u002fk+scr4W6CTEu+JFXfx5x71CayMkU90dfQsiT3wT3Q9\u002fDjwv7HS5VcqDqAx\u002f7VoCudZwb55JhMu9qsqkoJNsVmZM7a8dbPDsm722XybXarz+e8f+rffe9\u002fOTyyrS+qSLIMPxgY+61CdP17nqbO7VBe7qnexPrie49PHOR4+QTKXXLB3vSIpmMCZ2bMMxAZZF1jLjqrthJwVGKbBRHRo26tnn\u002f7MhtqdD5im+Q3gh5IklbxRsbO7\u002fUGscLOdpX7s1YJu6vjtfh5our9onWpl87zIWGL8ptxlKexAFHah3KqLSlclde46atw1BB1BnKoTE\u002fOBhJZ47fuH\u002fu033rfzE18u13g6u9ubgD8mbw9VbKa8CrqpW82SZo5ksaDMPK8hX5EUbLINtzpn5xhyhqh0Vv5D523\u002fecUmls9HkRUMDE6FTzMQG2RTaCPbK7cTsAe5u+Eutldt40usOMf1Ilk9iyO\u002fcJDRs\u002fRH+y8672RJJpqNsn9kP4+0PkKNu4a9dXt5efiVFZVn873e7\u002f+x3+7\u002fiIRUdeWfNNlauQW7YieWjfHW+AHgyj2U8yfG52ZO7\u002fz0kz\u002fjfmjtE1\u002f8+dt+bRzLSeduYItpmt+VJOnVUhxPZ3d7J1Z9esO1\u002fH6hXHo8OcHTfU+zKbSJ3TW7afO3Ueuu5dj0MQ5PHyGZS6LK6iwLsGwtNYqsoJla0erYJtsIOUM0ehto9DZS6azEqTqK4iTkDFHpqmRr5VYSuQSTqUmG48OMJcaJZqMLdikTLB9dHT2vdXa3fxerhKnc7Ab2d3a3\u002fx7wd10dPWWpUnjx+NerftD75O+NJEZ\u002fpdCoDhQ\u002fhytlgaeUXN7pzMobjGQjDMUtb51C1qBLddq8Nu+f\u002fPw3f\u002fzeidTkL3zrJ19aFvOdJZlZ\u002fsLdv3Owo+uRf2nxt\u002fzS7urdVLuqcatubqu7jQ2hDRyZPsrp8OkFp1tLWCtSuqlzfOYEvdE+NgY3sq1yK36Hn2Q2Fjo0uP8jw+Fze9qqNj9mmua3seqZY9d7LJ3d7Xuw7PGua6t0tVNown+o+QGCzhAAo4lRXhx8kWg2dlOJlkJ\u002fj2ma2GQbQWeAOk89jd4GKp2VuG1uZEkullYBKFZpVp1maP\u002f+tQP\u002f+AvvTr77V58\u002f+oXvjZeoprezu70O+E9YGTJXmQheTPEcvND++IJTM2tkyeRXbfLp3\u002f0TyfG\u002fu8ZhLwuF\u002foKckePg5CHORXrZUbmdjRUbqXBWLPfwrkhP\u002fzPc03g3Fc5K7m+8lx49zXhi4qISN1VWGYgN8s7EO+yt28um0CYmkpMcnzm+Ys7VH3z8teHO7vY\u002fwFrRvSSmaeKzeWnyNgFWSVVskdeb\u002fGuz\u002fpkz3\u002f39ff3PPfWTu37u7cfWfzCDVbf\u002fMdM0twJflyRp9hoOQ\u002frRL9\u002f3sFN1\u002fjfgkWv4\u002fYvHKykYmByZPspgfIg9NbewPrieW2tvpc3fxtuT79Af7f\u002fj\u002f\u002fORp\u002fpK8XyLZb7VsYHBVN5l7NDUYfx2H3Xuepp9TVS7qvHY5lojPDYPXpuXtYE1ZPQs4XSY0YRlkTydniGjZ5bjcMqCdd2\u002foaTYZ4D3Y6XelxsvVmXLxzu72\u002f8\u002f4Nulsuk92b+veiA++ImUnv70PY33NGb0DLFsjHAmzEx6htn0LLFcnIyeOc9G+EYuc7ycoNFNnXg2QSwbR5Kk9zkV5+v5zJclsV6fz5LdsXTT+ExvpO8nhuMjVesD69hetZ2QM4Tf7ufuhrvYFNrIoanD9EZ6F5ytMH\u002fCcWjqEGcjZ9kc2sTmis147V6m4iPrpxPj6wKuivZKb\u002f3rE9Ghr1b7Gn+wWAGT3+5\u002fEPgY1s1oZdzplwnN0Gj0NvBg8wO4VQ8AvZFeXh5+mXRefN7ozBcrTsVBpbuKJl8jjZ5Ggo4ANsV+nlApoBlaMYRrMjXJdGqaeC5xb1pP3\u002ftg0\u002f2H6ebfsUIbTy628S5vtboXK8Trx4DK0hzt5bnERe4zL\u002f3s0dlyP285KFxPErkE+0df5WzkLJtCm67+i8vISGKEl4Zeor21HbfNwwNND\u002fBU31NE8mW481FkhUNTh6lyVrEuuI69dbcTzoQZT4yvpHP277Ea2O+71D8apkGNuwaX6kIzNMtt6xonEKqsKhkt\u002fb7Pv\u002fU3j3z\u002f5H8MfGDjhwbubX1kwGn33go0mqb5VUmSFmQF+uLxb6zL6JknotnoJ14afvm2kfjIgqsIFkLhsxnLxnhh6EXORc5xa82t1LhruL\u002fxvrcT1dH\u002f+X94qiTPdb3jnG\u002fAE8lECadnORk+gVv1UOOuttz83HX47X5k2bLKV2WVWnctdZ46dlbtJJ6Lk8jF+So\u002fXOYjKg122Y6Wt5o3TfM8+\u002fjVOAHu6uh5o7O7\u002fV+BTy3h0+4BvgYc6exu\u002fwrWffLEYkVMZ3e7Rzf1W92qu\u002fPrZ77x43Weuhqf3YdbdRNwBKhwVtBKK6ZpkDPywZm5GOH0LDPpGcKZMLFsrChmLBfNy0YC3DBcIsetEfhuZ3f7n2FlvixZ1MOSvsKd3e2\u002fYmL+jW7ouFQXmys2sbViK167t1iCMpoY5eDkQYbiw5iLzFYwTRPd1PHZfWyp2Mym0CbcNjeakcMEbIrDVGX11Gxq5oevDL\u002fyzrGZ4\u002f0OxTHjVJ1JrMYmBWvVrRJoAbYDt2KVgwVK+2qUjIe6OnqeX6on+9BXHvhmm6\u002f1Rx9sfgCH4kSSJE7OnGTfyH50U7+eOuVTwK6ujp4laeju7G5vAw5jreYsiPPEiuqkxlVNi6+FBm8DfrvfKjvKN70XLmI5PUc0G2UyNclYYoyp1DSxXIyckSs68lxi9SaL5Zf\u002fFnAIOAdMAnGsBlwZcAFBrIvHZuAWrG31a6p7LRH7gPuuxenkeunsbn+V6wwJuxDDNDAxn\u002fla57PtpXzcUtLZ3f51zdA+1Opv5eHmB7ErDkYTo\u002fT095DRsxedj4Zp4FJdPNH2OJWuSmbSMzzV9xTxXOLCnz0M7ClXacaV6Oxu3w68yiXOTc3QuKvhLnZW7SCSifDts98mY2Sve7KgmzqqpLC9anv2rsZ7pio9tVMOm3sykYl++6\u002fe+Oyr0+mZZMAeyJmYKtY9ogpYA+wwTOP2rRVbtt1Wd5vboTjI6hnenniHI9NHiyVSpUY3deyyne2V26J7626\u002f5+FtHUvSA3Ahnd3t\u002fwz83EJ+tlBCa2JdPyudFTR6G2nwNBByhrDnF3sMDCSknIS0u337R1dUaO+18vW3\u002f9f6tJ4+HMvGnLOZWSKZCNFslEQuaU2Ar0\u002fQ\u002fNeujp6\u002fKuf4L0Vnd3sL8DZLsEB2GTTgJHAA6z55lrzbFtY9FMAJ+IF6LEOOW7DmdGuA4v3artjxqG78jgAVjhAhZ4iAI4DH5sGpOIuLECYmmqGR1tLMZmZ7J1OT6bSW3jKbmSWWjZPSkmSNLLphfc7PEzOLC29ebbwK\u002fGxXR8\u002fxpXiypd45+DsJ6cOqrN6bNbK8M\u002fEuZ2bPsq1yK5tCG3GqLhq8DdS6axmMDXBw6hDjyYkFZysUaoITuQRvjL3JyfAptlZsYUNog7VCp2elnJ7Z5FSdm+5quIsadw0nwyeNaDamyZJsyJIsAzZWkRGjYS7tHHFX1S5pd\u002fUu7IoDgCNTR3ht7HUwF5bTsxoxTAPDNLDJNmrdNbQF2mjyNhFwBJDz4ZoFJCSSWpKp1BTD8RHGkmNEMhFyes6ycM1bgs5Pkb4EdiwRsvuC7+ewBLaE9TldSS94DusGuuSiBSiK5lLeGFbL51mVVfqj\u002fbw2+jp3N95Nvaeeuxru4oWhF4s3zwKyJJPUkrw88jKPtT5GhbOC+5vu55n+Z8gauRVxzF0dPUfymVj\u002feOG\u002fKZJCyBFEQiKWi5HJO1RdL4VyrHcm3rWPxEca7qy\u002fs6HGXY0JDz\u002fU\u002fBD7RvbnZjOzuiqrF90jZEnm6MwxJlOT3Fl\u002fJ3WeOu6ov4Nady2vjr626FK2hY5XMzVeG3v90\u002f\u002f94T9fFtGyWIrXPaw6+rm+GJWAI0C9p55GbyNVripcqmtFfBZLRTDvulbnqbOysTDQDK1gOWuFNmYizGYixEonaMpKV0fPQL735B+WaQgqsC3\u002fNR8t\u002fyXlf+ayq9+Fz1jOyBHOzDKTCdNr9iJJEjbZhksthGSGqHCGCDmCeO0+7LLdaPY1f6LV3xLSDP07JiZZ3co4S+QSRHOFTJQo8WyMpJZ\u002fPw19bnHzxtqluRN4tbO7\u002fde6Onq+WO4nW1Lh0tXRY3R2t\u002f8X4FUJyV0oy3ht9HVOhU+xo2oHawNrsSt22gJraPQ2cS5yjkNTh5lJzyzKQlmWZGLZGK+OvsaJmRNsrdzK+uB6nKoT3dDx2D3sqd3DpoqN8snwafvJmRNEs7FyuZtoWJPMkj+w3+4r9UNekffU7ZULJ9rByYO8Of6WdeKtkItpqSjsrgAE7AHa\u002fK2sCayhwlmBKqvniRUTsxjANhwfZiI5ORPPxSsKDfqSJJWqFMeW\u002f1qJfKaro+eN5XryBk+9NJ2eIa2lb0qHIlVWOT5zAq\u002fdyy35HohIJspb429dNGlWJIWxxDivj73OvY330uBt4J7Geyyhk98FXG66Onr+qbO7\u002fXbgZwvfMzFRZRW3zY2JSTwbZyHWyQulUI41kZrkqf6nub32NjZXbKbZ18zja95r2ze83zYQG7i07bSkMJGa5Mm+p9hTcwvbKrexLriOCmcFr468Sn9soKSlY\u002fnx\u002fvO3P\u002fby\u002fy7ZAy4h8\u002ftiTGAmHWYqNc3R6WN4bB6qXJUE7Cu1yGHx7BvZh9fuJegI4rP7cKku7LKVKO+z+6jz1BV3pDRTI6NlSGrJqwuaZT5Xuzp6PtfZ3f4+4H3LOpDzUVnk3PZSfR26qecDlqMMxoasz6ys4FJd1Liqf\u002fezT3z+FYCut\u002f7+eVVWH\u002fTYPAQcAYLOIE00FecQBYGa0pLEs3Gi2di8kMcEKS1N1sgWqzms3RnrSrHKRE0A+EJnd\u002fsDwK92dfREyvVES96r0dXRc+hjX338t8D8u8IKnyqpzBaDJk+ws3onrb5WbIqNTRWbaPW3cip8iiPTR4llYwu2UC5MYCLZKPtG9nN85jhbK7ayLriuKGCcqos9NbewKbSR0+HTnAifJJKJlHry809YN2BnqR5QMzQ2V2zinoZ7+DzfLNXDXhUTExmZdyff5a3xA6vtxLoqhd0Vu2KnydvE+uA6Gr2NuFTXRWIlmokyHB9mIDbIVGqStJYpXPT+RZGUH5Mlef1yHccS8zzwR8s5gPe2vVeOZqOci5yjN9JLODMLUPJdmJWMLMscmHgbv93P+uB6dlfvYjYzy5nZMxdNtlVZ5WT4FCFHiJ3VO1kXXEdaz7A\u002fbyu8Ql6z\u002f4xV3mH1u5igKip22QqyTmmpi3rISoEiKeT0HK+M7GMqNcXeur0E7AEeaX2Yt8YPcGTqyCVXvhVJQTM0Xht9nbHkGHfU3UHIGeKR1kc4OHmQdycPFt0GS8CLwP9VigdaCcy\u002f3yZzSfpy8WL5+I3AoSlrU0yWZOyKHbfqxm\u002f3E3QECDqC55UlqbKK3W7H7\u002fAXBY1VopQjPU\u002fQzGYiRDKzJHPJ5T5Zfwl4Hasc64bhck3qiVzijc9++9vFvKSvnf6P3\u002fTYPPt9Nq894AgSdAQIOAL4bD7cNjcOxYHH5sFn91HrttxXDdOwXDuNHGktTTKXJJaLEc1EiWajxHJxknmRmjNyF5Wgg4S0ckvPfhp4T2d3+892dfTsL8cTLEuT+Zc\u002f8uTff+6VP7pjMD74U72RXnKGjppfkZ5ITfLswHM0ehvYVb2Lek89DtXBzuqdrA2s5djMMU7MnCSlpRa8glW4KM5mIrwyso9jM8cuIWCc7K7ZzcbQRs7OnuV4+ASz6dnzGg2vka9h+YL\u002f8vU8yHys5vhG3lP3niV3BFIkmUNTh3hz\u002fK0balJYECx+u481gbWsz6+WSpJk3TjyKyGxbIyh+BB90X4mkxOk9UzxMzJvV+Us8DtA9\u002fId0ZIxAnyqq6NnIeFXZcM0TYKOILfV3sb2yu0Mx4c5HT7NSHKUnJ5b8GLHaqaQ2bJvZH\u002f+JlnLXfV3EMlEmEpfHDgpSzJvjR8g4AjQ6m9la8UWcnqWN8bfLAaSLiddHT2Zzu72jwDPkQ+DUyRlXnlH+dpvCrbhx2dOEE6HubfpXiqdldxR9x6C9gCvjb2OZmgX3RsK5VC9kT6mUzPcWX8HbYE2bqu9jSpXFftHXiWajV7vdfsY0NHV0XPj2G7No2jZfgOdrvPf75yRYzYzSzgTpi9qFlfyHXlB47P7CTj8xd2ZgqCxyTZ88wSNVXKmk9Vzyt9SNkf9q9LV0TPY2d3+SeBJVlb5cjnIyZL8q\u002fzbXNjj1z\u002f6\u002fIGPdD3ymbSW\u002fv3x5AQw17bgUB3599SL3+7Hb\u002fef957aFTtOh5OQM1TsoTFMA93QyRpZUlqKRC5R3KmJ5WLEs3FSWipfepZDnydqCn00K2BBeTPwQmd3++8Cf1Pqa9WyuWN9eMOHf\u002fHtybfXb6nYcsfhqcMMxAbRDb04+RuKDzOaGKPV38qufDCcx+Zhb91eNgQ3cHjqMGcjZ8nqWlH0XI1LCZgtFVtYF1yHS3WhGzoOxcGO6h1sCG2gN9LL8ZnjTKWtGJhruJGPYq2KVS\u002f2Fy+HZmg0eOp5qPlB7IqdnFESV8AF89Lwy+bZ2XM3jGgp+LVXOSvZFNpEW6ANj81z3gpHVs8ymhjlbOQcI4kRkrlkUaxcZgLizpe6\u002fDjwkSU7mKUnA\u002fxkV0fPkoRoXonCdUMzNGyyjbXBtawJrGEqNcXp2dP0RfqKDeg3chmZLMmk9TQvDb3M42vei9fm5d7Ge3iy7ykyeua8Y5eQ0E2dV4ZfwWvzUuGsYFf1LnJGjrcn3mEys\u002fxRPF0dPeOd3e3vB3pMzPXzy1INs\u002fxaWZVVxlMTPNn7JPc03kOrv5UtlVvw2X28NPwS8VzikvcFVVaJ5+I8O\u002fgsO1I7uKX6FtYE1hByBNk3sp+B2OC1lo71Ah\u002fo6ugZL8XxCZaey63kp7UMKS3NVHq6uFCmyAp22Y7L5sJn884FAtr9eGyeFdML1NXR09PZ3f4rwKqywr8Gfq+ro+e1C78pS\u002fIfAffJkvxw4XsGBqlcimQuyWRysthvKMuy1T+jOHHnd2ICeUHjtXtxq9YujVNx4lE9VLus6eP80rOsniWtz+3UxLIxYlnLiS+ZFzU5PVc0w4Bl6amxAZ8FwsA\u002fl\u002fKBl024VNduTnz34Bc\u002fXOOuefbhloc3jSXGODx1mMH40Hl1y2dnzzIYG2RDcD07qrYTyKc\u002f39t4L5tCmzg4dZCB6CAGC691ni9g9o3s59i0JWDWh9YXBYxNtrGl0hI1A7EBjk8fZzw5YW31ywuatOvAJ\u002fM33kbIG7lfIyagGxotvhbub7oPp+osaX33QjkZPmUoUmlrtZeDrJ41VVmlzl3L1sqttPhasCv28+pMZzOznIuc41ykl9nMbPH1XsBqaeHF+SUsZ7qtZT2Y5eNTXR09Ly73IACOTR8zGr2NVhMsoBt5QeqqosZdw86qnZyLnONU+DThjBWOvtw7CqXgUqYEiqQwnZ5m\u002f8h+Hmx+kBp3DXfUv4cXh1666PdlSSahJXlx6CXe2\u002fYYLtXFLTW34FSd0n\u002f9wZLnGV6Sro6e3s7u9seA7xumsXmuhGhprkGKpJDUUjw78By311k7es2+Zt7b+hjPD73IVGrqktcEWZIxrYZ\u002fJpOT3N1wFxWuSh5pfYR3xt\u002fh0NRhDBZVOnYKeF9XR8+5Uh6fYGVw3oRy3kc7Y2RIp9PMpGcuSjh3qU4cinNZd7sLdHX0\u002fH1nd3st8HvLPZYy8ZWujp5LJsbn+7c\u002fCbwCtMIF9sEXXKoKIY+z2QhmfE5YqJKCXbHjUl1WeZnNh8\u002fuK+7SuFQXDsWBS3XhtXmQLhA1hZ2atJYmme+piefixLIx4vnys3S+\u002fEw39fMCpYv\u002fK21lwu9hVRyVlGXNI\u002fnArk8Of+fgF55QZfWpBm\u002fDhjpPHcPxYQ5PHWY4PlJsxtRNnaPTx+iN9rGlYjNbK7bitrmpcdfwSMsjDMWGeHfyXcaS4wt2IIPze2D2j77KsZnjbK7YxIbgetw2TzFPZn1wPW3+NkYTo5yYOcFQfJhs3mr0Cs\u002f1i10dPT2leJ0Kq\u002f\u002fbq7Zze+1tqLJabOSbTE6W4ikWzI0w2QPYWrFFavG3SE2+Jmyymt9utV7TscQYJ8OnGIoPndfsvdiVra6OnpnO7vafwCp1qS3HcSwjP9\u002fV0fOV5R5EgX0j+02X6qLZ18SG4AbqPHXWtcPQ0UwNt83NrupdbA5tpj\u002fWz4mZE4wnJxZtub7S2FKxmbOz58hd4AimyirnIr1UOivZU7uHDcENTKamODJ15JLN+pOpSV4efpmHmh9CkRW2VmyVv\u002fAjfyp96rO\u002ftdSHdEm6OnrOvf\u002ff73rIa\u002fP8h2ZqdwEo8tKtNMuSjIHBq6OvEc\u002fGub3udipdVby3rZ0Xh15iMDZ0SfFSaPgfio\u002fw\u002fd4nuavhTtYG1rC3fi8VLqtxP6WnF\u002fIZfAP48a6OnqFyHJ9g5XK5HZqckSObyWISXTHNQF0dPf+js7tdBf77co+lxLzAPKOQS9HV0TPU2d3+YeCHXCU+43Lvqcncztv0PKEqSxKKpFqlZaq1E+OzW8YOXpsXr81riRrVgUOxytOqpLnc6WJPjZ4lXTAKyCXyOzWxfG5SkrSeJqdn0S4jaopC7OrEseyRv7qQH14syx6k+MFdnzr33YNfeDSejX\u002fHY\u002fPsbPW30uBpYDA2yKGpw4wlx4oX\u002f4yW4cD425yZPcuOqu1sCG7Arthp8bdQ763n3Ow5Dk4dIpwOL6qmvTApjWajvDb6Osemj7MptJENoQ347D4rYAiJJm8Tjd5GZtIznJk9Q1+0n2g2WnyMeW\u002for3R19Hx+3lPkYPFdpIVcmoAjwO21t7E2sLYoYqyb6Kscnb4hbO6XnLsa7pIUWZHypya6oXMueo4TYWtCWyhbvN4eoq6OnmOd3e0fBH7AJfzuTYB882VhS\u002ffqTalWY968v839Of8PZdwRM4Cf6+ro+UK5nuBaUGWVrJHlVPg0ZyPnqHFVszG0kVZ\u002fa9FYQTM0VFllY2gjawNrGY4Pc2z6GMOJkWXZvSwFd9XfRYuvhZeHXyGpJc87BkVWeGfyXapcVbT6W7mt9lamUlOMJ8cvOlZVVumL9vP62Ovc1XBXvqxh+UtQ5vO9n9o\u002f+rHuxx5VJfXzJuZHbfLSGuwVnLAOTR0moSW4p+EePDYvD7c8zL7hfZy+hAlCAVVWSGpJnht8jpn0bnZXW\u002f2UAXuAl4ZfvuyuTZ5urHMuXq5jE6w+VpI18ny6Onp+u7O7PQH80YXWv6uU\u002fcCHujp6Ulf7wa6Onrc6u9t\u002fDPgOi8iIm8\u002fldt5MTNJ6mpSWYoaZ84SFIinYZRtO1YlbdeO1e\u002fHafPjslqhxq24cqgO7bCeouoo9NQCmaaCbBjkjN+d+Nq+vJp6b536mZ9HNq1o6n8PqwXvrWo5\u002fISy7cAH4wK5P9T\u002f6xT0P763b27UmsObhZl8za4NrafI10Rft49DkYaZSU9ZWWj49eN\u002fwfk6FT7O7ehctvhZUSWVTxSZa\u002fC0cmz7Gsenj1o18EXXEBQETz8V5c\u002fwtjs8cZ11wHRtDGwk5QoA1qaxwVnBH\u002fR3sqtrJcGKE3kgvE8kJMnomZ1or0V+8ntej0CjuVt1sDG1ge9V2PDYPmqGhSAppPc0rw69wLtKLXbFfz1PdtBimgYpKVs9wMt\u002fLND2vl6mUpgf5lOHHgG+ZmE2FMqZCA589v0riVJ04FQd2xYFNVpGLk0uz+JkorJwUdhI0Y+4rZ2jopoZm6MWLi4l5nhCaf4G5hptJFPh4V0fPd0rxupSawgIHwFhynLHEOAHHQTYEN7A+uB6\u002fw18UMAAtvhaavE2MJcY4On2UwfgQuqEjy8qqucVqhkarvxWPzcNLQy8xOW8CXGjW3z\u002f6KiFnCL\u002fdz131d\u002fJk35Nk9dxFkx5VVjk2cxy3zc0t1bfgW2Kr9YXw5Y6nk1\u002fm6Z989uhXD6mS+oeSJC35PUyVVc7OniOtpXmg6X68dh\u002f35ct3j0wfvWz\u002fX6F07K3xA4QzYe6qv4taTy2Pt72XfSP7OBfpvfB+lQN+u6uj58+X8vgEguulq6PnMx\u002ftfmyw0lnxzzlDs6e0JLl8yjxc8yr+cvA01iR8wda+XR09z+f78r5OicM5L7dTA5AxsqQzGcKZ2fPKz2TJ6qmxdmJcRYczn22up8alOrErDqvfxhGYEzWY1lyjaOlsmQXEcpZNtNVXkyClpdAMDd3UX8Dqex0t5XFfyIoQLgDPfPLtqWd+4e3HOx569K9bvM2\u002fvKN6B\u002fWeOjaGNtLia+HM7BmOTB8lnA4XHZwmU5P8cOBZmn3N3FK9mxp3DU7Fya21t7IuuI6Dk4c4O3sWzdQWtZpaEDApLc3ByUOcDJ+ixdfMptAmatw1KJJiJRcrDtYF17EusJbZTGTywPiBj372ic8\u002fe+Hj6aZB3sDu4rJsk+Jqu2maqLJChTNEm38N64PrCDgCxYmqKqtMJCfYN7KPieTkkjuK3UiktBRnZs+Yx2dOMJOeOS8crRx0dfQc+NEv33dftbuqq95Tv7fgMGJt8TqxKXZUSc3nvsDl6\u002fdNCjqk8JkxsVZMDMPKAMgZOXK6tXqS0TOktTQpPUUylyKlpUjraTJamoyRLVxsLt4WvljUHAU+1tXRc7BsL1IJKWRERLMx3hx\u002fi6Mzx1gbWMvm0CYqnBXWBTnf3N3gbaDeW894Yowj00cvMgpZySiygm7oVDoreW\u002fbe3ll5BV6I33Fa4MsyUQyEV4bfY2Hmh+ixl3DbbW38crIPsu56QJkSeadiXcxDIP\u002f+84\u002fAH5hiY9oYTy87SN\u002f8ttP\u002fsILiqR8jouDWsuOKqsMx0d4uv8ZHmp+kJAzxB31d2BX7Lwz8e5lJ2MFcX129hzRTJR7G++l1lPLg80P4rf7OTx1pHDqvwX8l66OnteX9sgEgtLwlY6n\u002f+17B\u002f91UDO1L2X0TGMiX5oUzVqWv\u002fFsouiOtYBV\u002fOXgH7GqZxbtgNTV0fNiZ3f7g1iusptKPrJLcCVRU+ipiWajxTknUDQYsvpmrBI0b74EzWcr9NVYosZj8+B3+M8TNYZp5OcaaSaSE1\u002f4vf3\u002fzy9O\u002fKaWLfexrqyZ7z+R6\u002f6nZ\u002f7zB798z\u002f6h+PBftflbq3dWW45i26u2syawhlPhUxybPkZ0Xp7LQHSAkcQIG4Ib2FW1A78jQMAe4L7Ge9kY2sC7E+8yFB9edD17YUU8Z+Q4FT7Nucg5alw1rA+up9nXjNvmRjd0TMyXqlxVP\u002fvZJz5\u002f5lKPU++pM7J6xkhraUWbd4JaGTYKDtWJ3+6j2lVNnbuOSldlsVG8MIHKGlmOTB7h3cmDZPSMEC3XyTfPftPMGZpZcG65XkzTxMC4YijYtz72Uu\u002fQyDsPHZ85+T+R+BScP7kpChETTOYyY+Z2SPJ\u002fk+Z9XwJQUAFTMc8vSLxg8lTIA9DNuRWUgod8PBfPu5PMraDkjFzhd74AfLqcgVLlorAIkdEyHJk6wunwacv6t3ILNa4aYM5Zrs5TT62nDsso5AiD8cFik\u002f9K5eDkQbZWbMGhOnGqTh5qfog3bW9yePpIceVflVV6I30c8xxjR9UONldsYjg+zLlI70XXEcuSE96ZfNf4xac\u002fvmJq5y\u002fFHz\u002f+T691drffhVVP\u002fxuAaymfX5VVptPTPN3fw8PND1HtrubWmluxy3beGHsTUzIvO\u002fFSZZWp9DRP9T\u002fN3Q13sTawlr11e\u002fHYPIl9I\u002fv\u002fSDO1v\u002fzWT75U9gmAYGkoOErdbLx\u002f108\u002f\u002f8yRrjucqvOfQo7QE4U+vPODGVPFBnJL1MTOuwfNLawVskvkcmeYRID\u002f2tXRc11N5V0dPYc7u9vvwcrx+1BJRnaNXEnU6KZOMpckkUswydS8vhrLEn+ur8aN1+7DP6+vxqk686LH\u002fd9\u002f4e7f+ZOlOp4VOfv9zsde+fKPf+XBl0+GT\u002f3pQGywY31wHdurthNyhNhdvZv1wXUcnznBiZmTJPJ2lIZpcGz6GP3RfrZXbmdLxWYcqoM6dx3tre0MxAY4OHmQidTkohr44fwSlNHkGKOJMTw2N2sCayK7q3d\u002fNmQP\u002ftl9Wz902VCB9pZHDUmCrJ4rrnCDlYmiyjbsih1VtlbbC033haCynJGjb7aPQ1OHmUhOoEjKqqzFX2nopmFez+s4X6gosoLH5qbCWUGtuxa\u002f3S9\u002fjYs23gBoarglAfzM9w\u002f9W49hGn88k55Zk8gliOcsb\u002fasniVnaJimUbzASMiosoIiqaj5vhtVVrHJtuKXXbGf919VVq0dHFlGRma+jayKiqqoOBVnMZ16zmJ2zm5xNjN79uDkod\u002f66w\u002f82zeu+YVaIRQWITRT41T4FL2RXlr9LWyr3EaNu4aCNTBAvaeeOk8dQ7EhToVPYXkrrEzeHH+LkfgI9zfdh89urYbdUX8HXruXN8beLF5HZEnm7Yl3qHPXUeOuYW\u002fdXiaSEyS11MVZJIAkyWY4s\u002fJ1ar7u\u002fH90drd3A38I\u002fNhSPr8iKUSzUXr6n+Ghlgep99Szs3onqqzy6uhrV1zIUCSFtJbm+cEXSOQS2W2V2755W+1tf\u002fjp+\u002f\u002fo6FIew\u002fWgm3rx+iK4PDZJJWdq6IY+t5uw\u002fDsKS8Kj2zuHgPf94NCXfjGjp\u002f\u002fAwKx2KS4raFOxcmlq8941hb7enJEjo2VIaIVeiyiRbJR4NkbiUsGMpXPF+h7w610dPaeu97gBujp6poAf7+xu\u002f2XgM0CwFI9bSi4q15v38hmYVsXGZfpqHIoj0uht+OQfv\u002fefvrWUY16RwgXg6x99fgDo\u002fImuh794ZPro7\u002fdG+vZuDG1gW+U2fHYft9fezqbQRo7PnOBU+BSJXLJ4I3h97HXORs5yS\u002fVuWv2tyJLMmsAamryNnIv0cmT6CNOpmWsKl8yXoBhJLfXlZwee+3\u002f\u002fn0f\u002f9qrWlIap63bZYbhtFzeTzk9+LtzkJKygw4HYIGdmzzCVmsIEsctSQs5vb786hd2QwkTQpbqocIaoc9dR66kl5AjhVJ0okoxu6Fd97Pft\u002fETXZ5\u002f9ze+9O3XoVzRT+w3TNEPFsV04tOJGysUL4PMvOoUVEkVWLBEj23GojrxfvBu36sZj8+C2uXEplgOJTbYVhfA8wRx2qa7\u002fua1y219+6o7fWPmz10VQWIQwMDgze5b+6AAtvma2V22jxl17noBp9jXT5Gvis3z+Ko+6fNhkGyOJMZ7se4r7m+6nzlOHZmjsqNqBW3XzyvArZPOOYxk9w+tjr\u002fNY22MEHUFurb2Vl4Zfvuxjr4R8iIXS1dFzFPhQZ3f7\u002fcBvAo+zRGF4ll1ykh\u002f2P8uDzQ\u002fQ5Gtia+VWFElh38h+y9zlMpcbWZIzJuZ\u002fvDD04p\u002f91\u002fs\u002fsyrKMOezxt8mT6amiGVjxfvpzTAZXyw\u002fuv5HrRXt1BSTyQlmMjPEcwk0XcPEzJcI39hC5omdH\u002f\u002fHX\u002frWT3zPhN9WJPVTbpvLeV4oo+rGqbqwK3Ycih2n4iToDFq\u002fbFqGRHp+US2lp4lnrV2aSDaSbyKfW\u002fy7hl2aw8Dvd3X0fL0cx97V0fMPnd3tTwJ\u002fBPxkOZ6jHFhFHpc2CwBOxrKxjj9+7z8t+XVrxc+Ev9b57FOf+I\u002f39yRzqQ+\u002fM\u002fnup89Gzt2xObSJTRWbCNiDvKfuPWwObeZE+ASnw6eLIXMz6RmeHXyORm8ju6t35e1RbWyqsEIGz0XOcXx60eGSWeDbwJ9\u002ftfOHbyz0GHKGpimyqiso512czPyMVDc10nqGWDbGVGqKkfgok6lJUvnV0NU0gbiRKNRwmqaJTbERdASo89RR76kvBqLO\u002f9wYpkFaz5DWrmo+AsB\u002fe\u002fjP4sAfd3S3\u002f7sk8Wngk1xqRWYR9zLN1NB0jbSWLh6DtUhy\u002fkrJXF3rnF98vaduuN5T\u002f6+6qX\u002fuA7s+eUPbrs4XMGcj5+iPDdDqb2VH5XZq3DXn9cCsdFRZIZKN8nR\u002fD\u002fc03M264Do0Q2NdcB0OxcHzQy+Q1izL3eH4CMemj7GrehcbghsYiA2c1xOz2snnCr3Y2d1+O\u002fCfgB+lhAHAl6MQ\u002fPns4HM82PQALf4WNlVsQpZkXh55BcO4SLwMY9W\u002f\u002f3N3xzOr1hry4ZaH5aSWZDA6yLmoZVKzgKiAmw6f3Yff7qfB24BpmmTy9\u002fvp9DQTyUmm09NEs1Eyeqa4gHkj7mR97ke\u002fNgT88hNfuuPvnKrrV2SkTgkpIEkStuI9yV20+i2ImkIDuU2247K58di9VLksu9\u002fCgmLBFauQNG8Jmiix\u002fC5NWk+jGfOEonVjPQL8DfClUqe7X0hXR08v8LHO7vbPYZW3Ps5ShVGVnh7gp77xky8sbR5HnlVxt\u002fq3D3\u002fPAL76S9\u002fu+Np4YvzB18fe+JkzkbPv3RzaVLkuuA6\u002fw8\u002feur1sqdjC6fBpTs2eJpKJIEsyQ\u002fEhRhOj501K7IqdLRVbWBewwiVPzJxkPDledO26xMWiH8sh4gtdHT1HFjv+7\u002ff+wLQpNqdDcWCXbcyv88zmfbXTWpqMkbG2kq+cyn4hS1035izT4y5pffrlsLaqDSQJXIqLKlcljd5G6j31BBwB7Iq9KDwN0yCtpYlkI0wmJ5lITTCdmiGlpRY14+3u6BkAPt3Z3f6XwCeAjwFbrmX88x3D5n3zIuY166UN03g1p+e+dDJ88lsn\u002f6\u002fJ8LU87wrgmj6XBQFjYnJu9hwD0QHa\u002fK1sq9xGpasSwFHaYZYcB1gLL1k9ywtDL5LIJdhauRXN0GjyNdHe8gjPD71IPBu3LJIn3qXWXUudp469dXuZSk2TzCUvvO6tiPPxWunq6HkTeLOzu\u002f13gSeADwN3AaEr\u002fuJ1IEsyWT3Lc4PP80DT\u002fbT6W9kQ2oAiybw8so+ckRuWkF7Gupf8sKujZ7ZcY1kqZjOzNp\u002fNx5bKLWwMbWQ2M8tgbJDB2CAzmXDRwe8asLFEO2ZLgW7qkoTkLGya22Qbla5KqtxVbAptQjM1krkk4XSYqdQUU+kpIpkIKS29kAWUpfUFLwE\u002f+Phrx4Bf7Oxu\u002fwzwUeCjmqnv1nKWFe9EaqIYBC1LMjbFhlNxWEnzNi9+ux+\u002fw4\u002fP5sNts5LmC85ZAcdchMp5SfNainguwUx6JnF69vST4czsvyuS8mRXR8+S9pJ1dfS8Aryvs7v9PVjuJx+kxO5jZeYfsEwLlm1lb1UIlwKf+5FuE6vg\u002fLlHvrinbjwx\u002fnB\u002ftP\u002f926q23dHobWz12DzSnto9bK7YTG+0l5MzJ5lOz2CYBmfzk5JWfyvbKrdS7a7GJttYH1zPGv8aJlOTnIucYzA2RDwX14CzwItYftwvdXX0xK513LFcbMbImr9pmoZjzhPKonBiFraKF7nyKQOnr3Vc18g\u002fA\u002fuAa74jXQIZmCrxYy6Y+T1FHpuHOnctzb5mat21eO1eS8wiYWAJzVg2ykRqkrHEGBPJSWK5GDndMh7JT\u002f6uqam5q6NnEPhMZ3f7nwN3Az8CPARsBErpez0mIb0tSdLTwNNf63z2ZAkfe7n4S6AFuKaLacGkwTANjs+cYDQxysMtD9uqXFVnSzvMkvMvwGuAJksyhmnwxtib1Lhr5EpnpZTRM9R66theuY39o6\u002fqCpad+unwaanaVSUH7H6p1ddiHJk+aqhzzsIyMA7zHCJWKV0dPRPAF4Evdna31wN3Yp1TdwDruUpQ3GIp9CW+MPQiD7c8NNnobTzeFljzynBi5If7R159+4effPuGKr18duC5L++o2n5ybWCtARByhKh2VbG5YhPHZ05wcPKQoZmWCcoi0YGxkg94mRhLjE5VOCr+m02x24tzgHl3CQkJr81LwBFgTWANOSPHTHqGvkgfp2ZPG2k9fbnX0AY8vxTHUA7y97w\u002f7exu\u002fwsJaQ8S75OQHgG2I82dm4WFtkg2ysiF+SX5pHmvzUPRrdPuxaN68hEDThyKI+5Une9Uuiq\u002fc0vNLd\u002f8zQf\u002fZNmv63nHwNc7u9vrsBZXPoR1fapY1oFdHgPLtOBvlnsgq3Wb6jyq\u002flT2\u002ftl9n91Y667bCeySJXmzIitNaS1d1Rft8xybPmYPZ2ZtJqasGzo22WY2+5q07VXbU9Wu6gQQliV5VJbkUyPxkQM9\u002fc+8Ec\u002fFT337Yy+XdetQsHx8pOuRVsM0jsiS7PXZfTR46vNipQa3zVM0StBMjXg2zmRykuHEMOOJcSLZqLU7Jys4FMcFX3YUSf2Nz7z3c39RinHmU4g3ALfkv7ZiTdCrsAKuHFgLEIVz2cS66WeABDADjGAJ3EPAQeB4V0fPTCnGJxCsRjq72yWgAWtRYCuWZelaoB5r9dOHtYtnx9rVnn+vNLDOsSyQwso3msQq\u002fzoLHM8ZueOKpJz5aucPp5bkgASCG4jO7vZGYDuW1fl2rHOzDquU2sXceVnoPzVMzKxpmilgVpbkUbtiP1vprDy8p2b3oVp33Yn37vhY\u002f3Icy2LIi5i9wH35\u002f24Aalj+3cdp4BNdHT0\u002fWOZxADeIcLkUX3r9r9UGb4Ov2lXlOz5z3PXtc99xGabpANBNXQ+nw8kKRyj6sc0\u002fGU9pqUTn7f9l0V7dgtXLz33jx9pq3DVH1vjXeGo9tbhUV1GspPU0M6kZhuPDjCRGiGSjSIDH5iXkCBbD\u002fDw2D07FiV2xo8hKcWdGN\u002fXfenzHT\u002f1ZucaeFzM+wI8lXlzMlQzqWJOpBBADYku9FS4QrFY6u9tlwA148l9u5hYHCuSANJDEOs8SXR09ySUeqkBwU9HZ3e7Guu\u002f5mDsvZazFuixz97zojXI+dna3V2AtVK7DEm+tzC2u+JkTcfMXL6+EibXo6V7EMI4CH+nq6FkxvXg3rHARCK7Et9\u002f9lzUu1X1EkRW3YRokc0nGk+MMxYeYTk1jAkFHgBpXDZWuSvx2Pw7FgSLLgFTMRLH63s\u002fb88cwjN96YufHyyZcBAKBQCAQ3LzkF1nU\u002fNdCe50zwFexytAXwvexdlpWVIXGqupxEQhKhU22k9TyYiU2RCwbw6W6qPPUsaViCwG7H5tiA6SisxiAYZr5nAvLHc7Kc7EcqArBjoV+F4FAIBAIBIJS09XRY2DtNC2qoqKzu32hE5S\u002fxuppWXFBxEK4CG5Knht8zgRMn91Hq7+Valc1LtWFJM0JFd00kLGME0xMckaOVG4u5TeW945P5pKk9Qw5wwqPNMwVHrcuEAgEAoFAcDEalmvY55Z7IJdDCBfBTcnu6t2S3+HHpToxzXnOYnmhopv6nD1lepqZ1DSz2QjJXJKsnrXEzbxslEvaEAsEAoFAIBCsDiaAn+rq6HlmuQdyJYRwEdyUBB0BFFmV9LwNsoxMSksxnZ5mLDHGWHKc2cwsaS1tJV8jWQIl\u002f7XAwFKBQCAQCASClc67QEdXR8+p5R7I1RDCRXBTokgKsiSTyCUYS4wxGBtkPDlBIhfPB1BKxd0XkQAtEAgEAoHgBuWbwKe6OnpWRc6UEC6Cm5Ij00fMqdS0OZYcJ6klMU2KIkW9hFCxvOKLfyo26xeQkIRHn0AgEAgEgtXEn3Z19Py35R7EYhDCRXBT8vrYm6YkSaaMbJV9zRMdBWFimCZgIksyNtmGQ3XgUp24VBcu1VUMnbTJNlRZQc7v4pggf41nl+3YBAKBQCAQCK5AFvjlro6ef1nugSwWIVwENyWqrJ63P2IJFQMAm2LD7\u002fBR4aygwllByBHCa\u002ffmwyZteYEicbktFt3Qxd6LQCAQCASClYYLCAM\u002f1tXR8+JyD+ZaEMJFcNNiMidWPKqHWk8Njd5Galw1+Ow+bLLtsi5hVgClkc9xMeZCKCUJwzCW6hAEAoFAIBAIFsrLwH\u002fr6ug5utwDuVaEcBHclGT1rOlSXdR761gbWEu9px6PzYMkSZiYRXtj3dTJ6lmSuSTxXJx4Nk48lyClJcnoGbJGDs3QMPMCSJZkJEkWOS4CgUAgEAhWDJ3d7VJXR89nl3sc14sQLoKbkvub7pNr3DVShbPC6ksxTSRJQjd1ErkE06lpJpITTKeniWajpLQ0mhUuWXyMwm6MdEHJWCHfRSAQCAQCgWAl0NXRc0NMToRwEdyUrA+uR5VVqRA2GUlHGIoPMRQfYjo1Q1rP57fkwyUlSRLWyAKBQCAQCATLiBAugpsSRVLIaGmG4sOcmT3DeHKCjJ45T6BcSqTMt0Iu7KxcaI0MYstFIBAIBAKBoNQI4SK4KXlh6AVzOjVtzmatvCVZklHly58OhmkgSzJ22Y5dsWGXHTgUO3bFgV2x5S2RVSRJRgL5P3huqQ5FIBAIBAKB4KZACBfBTcmZ2bOmLMmmIilX\u002fVnDNNhSsZkNoQ15S2Q7qqSetysz331MN3RRTyYQCAQCgUBQYoRwEdyUXJjjcjWavE00eZvI6Jm8FbJVKqaberE5X0a+XLSLQCAQCAQCgeA6EcJFILgKEhKvjr5GzsjR7GvGoTiQJCu6xcRENzTSWoZ4Lk4sGyOtpUWPi0AgEAgEAkGJEcJFILgKkiQRz8V5YehF\u002fHY\u002fIWcQp+LEMA3SeoZkLkFSS5LRs+imjmmaIsdFIBAIBAKBoMQI4SIQLIBCL0s0GyWSjRSdxIp2yXnLZEVSLg52EQgEAoFAIBBcN0K4CG5KTEzzWvRF0SJZSBOBQCAQCASCJUUIF8FNiU1WJd0wrNKuedkscxSUiXnBd6XiP11O+JgixkUgEAgEAoGg5AjhIrgpeV\u002fb+yQDQ8roaVJamrSWJqNnyBk5coaGkW9TkSUFu2zDoTqwy3Zssg1FVlEk2QqrZM752MTANEE3dflrPLtchyYQCAQCgUBwQyKEi+CmxGf3YlPsUmEH5cLdkwt7WBaDbuqikEwgEAgEAoGgxAjhIrgpsRLupfOCIwtYOS0mhmlg5MvJDNNAN3R0Uy\u002f+\u002fULk\u002fGMKBAKBQCAQCEqPEC6Cm5LT4dPIkmwWBErOyJHVs2T1LBkjS07PkjVy5IwcmqGhGzqGqaObxmV6Ygq7MwCSsEMWCAQCgUAgKDFCuAhuSl4Z2WdwYed9nrkG\u002fLn9k\u002flN+fO+U8QEuMQujEAgEAgEAoGgNAjhIrgpUWW1pDVd0rz\u002fFwgEAoFAIBCUHvnqPyIQCAQCgUAgEAgEy4vYcRHclGiGZgLF5nwp\u002f79LOYwJBAKBQCAQCJYfIVwENyV7am6RsnpWSmkpUnqajJYha2TI6rmia9h85zAhcAQCgUAgEAiWFyFcBDclu6t3SapskwDL6tjUi85iGT1DWkuT0lIktWT+vynSWoqMniGrZ8kZWl7g6BjzHMYuZa8sEAgEAoFAILh+hHAR3JQUsloAkECRFBRZwaW6ijsp80WIaRroBYGj58ga8wVOmrSWIqWnSGtpsnpOqBeBQCAQCASCEiOEi+CmZCQxilN1mg7FgV2xY5NVFEm1sljOEyxzAkeSJFRJRZVV3LgvI3BMNEOT\u002f5IvLunxCAQCgUAgENzoCOEiuCl5qv9pQ5Zk0yar2GQ7DsWBU3XiUpy4VBdumxuX6sKlunAqThyqA7tsQ5VtKJJyRYEjEAgEAoFAICg9QrgIbko2BTfKGSPjsnpX0iRyCSKZWQxMzHzPioQlTmRJRpVVbLINu2zDoTpxKo45YaM6cSkuHKoDh+JARlKW+fAEAoFAIBAIbjiEcBHclNzfdN8E8NGkllTD6bA5nhxnIDbITCZsXNhgb5omGT1LWksX3cYMjOIui4SEKqvYZTtum1txKc4Dy3NUAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEKxE\u002fn+fVd4Mp1QmkgAAAABJRU5ErkJggg=="

    // ***********
    // * GLOBALS *
    // ***********
    var globals = {
      init: true,
      elemId: "plotly",
      elem: null,
      currentYear: null,

      // Scenario info as base64-encoded zlib data, filled in Python
      // rawScenarioInfo: {rawScenarioInfo},

      // Scenario data as base64-encoded zlib data, filled in Python
      // rawScenarioData: {rawScenarioData},

      // Development scenario info as base64-encoded zlib data
      devRawScenarioInfo: "eJyrVnJKLE7NycxLVbJSqFYqTk7NSyzKzI/PS8wFiSBkdRSUkqDs+LLEnNJUuJLg/JzMFIXy/PwUhdTC0kygZGpeCYr60rzMErhy31xjpVqgbFBqSmlyqkJxYnluZg5QWbpCUWpxZkpparFCUqWCqYEqdgcR1kZdl9YCAOSEZAs=",

      // Development scenario data as base64-encoded zlib data
      devRawScenarioData: "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",

      // Year to data
      yearToData: new Map(),

      // Copy of original year to data
      originalYearToData: new Map(),

      // Scenario name -> year -> scenario data
      scenarioNameToYearToData: new Map(),

      // Original scenario nam -> year -> scenario data
      originalScenarioNameToYearToData: new Map(),

      // Global settings
      settings: {
        // Show sidebar menu?
        showMenu: false,

        // Is dragging node?
        isDragging: false,

        // Number of decimal places shown for normalized node position
        numDecimalPlaces: 3,

        // Treat values that have difference less than this as same value
        // Also used when trying to format value as whole number
        formatValueEps: 0.001,

        // How many milliseconds toast is visible?
        toastDurationInMs: 1000,

        // Menu settings
        showVirtualProcesses: true,

        // If true, show process labels instead of ID (default: true)
        // showProcessLabel: true,
        showProcessLabel: false,

        // Windows related
        showSettings: false,
        showTools: false,
        showData: false,

        windowIdToPropName: new Map([
          ["window-settings", "showSettings"],
          ["window-tools", "showTools"],
          ["window-data", "showData"],
        ]),

        // Tab related
        currentTabId: "tab-processes",
        // currentTabId: "tab-flows",
        // currentTabId: "tab-stocks",
        // currentTabId: null,

        // Context menu
        showContextMenu: false,
        showInfoWindow: false,

        // Line graph colors
        colors: [""],

        // Sankey graph font size
        fontSize: 12,
      },

      // Currently selected Scenario info
      scenario: {
        name: "From globals.getScenarioName()",
        baselineValueName: "Solid wood equivalent",
        baselineUnitName: "Mm3",
      },

      // Currently selected scenario data
      getScenarioName() {
        return this.scenario.name
      },

      getScenarioBaselineValueName() {
        return this.scenario.baselineValueName
      },

      getScenarioBaselineUnitName() {
        return this.scenario.baselineUnitName
      },

      // Currently selected yearly data
      getYears() {
        return [...this.yearToData.keys()]
      },

      getYearData(year) {
        return this.yearToData.get(year)
      },

      getCurrentYearData() {
        return this.yearToData.get(this.currentYear)
      },

      getYearForIndex(index) {
        const years = this.getYears()
        if (index < 0) {
          return -1
        }

        if (index > years.length - 1) {
          return -1
        }

        return years[index]
      },

      getIndexForYear(year) {
        return this.getYears().indexOf(year)
      },

      updateNodePosition(year, nodeId, x, y) {
        const yearData = this.getYearData(year)
        const targetNodeIndex = yearData.graphNodeIdToGraphNodeIndex.get(nodeId)
        yearData.nodePositionsX[targetNodeIndex] = formatValue(x)
        yearData.nodePositionsY[targetNodeIndex] = formatValue(y)
      },

      toast(msg = "This is toast", durationInMs = 1000, type = "success") {
        // Create toast
        const toast = document.getElementById("toast")
        const div = document.createElement("div")
        div.classList.toggle("toast", true)
        if (type === "success") {
          div.classList.toggle("toast-success", true)
        }
        if (type === "error") {
          div.classList.toggle("toast-error", true)
        }

        const i = document.createElement("i")
        if (type === "success") {
          i.style.color = "green"
          i.classList.toggle("icon", true)
          i.classList.toggle("icon-check", true)
        }

        if (type === "error") {
          i.style.color = "black"
          i.classList.toggle("icon", true)
          i.classList.toggle("icon-close", true)
        }

        div.appendChild(i)

        const span = document.createElement("span")
        span.textContent = msg
        div.appendChild(span)
        toast.appendChild(div)

        // Add toast show transition
        setTimeout(() => {
          div.classList.toggle("toast-show", true)
        }, 1)

        // Change to toast hide transition
        setTimeout(() => {
          div.classList.toggle("toast-show", false)
          div.classList.toggle("toast-hide", true)

          setTimeout(() => {
            toast.removeChild(div)
          }, durationInMs)
        }, durationInMs)
      },

      // Scenario related
      getScenarioNames() {
        return [...this.scenarioNameToYearToData.keys()]
      },

      getScenarioNameForIndex(index) {
        const scenarioNames = this.getScenarioNames()
        return scenarioNames[index]
      },

      getIndexForScenarioName(scenarioName) {
        const scenarioNames = this.getScenarioNames()
        return scenarioNames.indexOf(scenarioName)
      },

      getScenarioData(scenarioName) {
        return this.scenarioNameToYearToData.get(scenarioName)
      },

      // Scenario info
      getScenarioInfo(scenarioName) {
        return this.scenarioNameToInfo.get(scenarioName)
      },

      // Uncompress target base64-encoded zlib data
      uncompress(target) {
        return JSON.parse(pako.inflate(Uint8Array.fromBase64(target), { to: "string" }))
      }
    }

    // ****************************
    // * GLOBAL UTILITY FUNCTIONS *
    // ****************************
    function debounce(func, delayInMs) {
      let timeout
      return function (...args) {
        clearTimeout(timeout)
        timeout = setTimeout(() => {
          func.apply(this, args)
        }, delayInMs)
      }
    }

    async function sleep(ms = 1) {
      return new Promise((resolve) => setTimeout(resolve, ms))
    }

    // Simulate drag event (= mousedown, mousemove, mouseup) for first
    // Sankey node so node positions are computed
    // @param {Number} nodeIndex Target node index in year data
    // @param {Number} nodeIndex Target node index in year data
    /**
     *
     */
    function simulateNodeDrag(target, nodeIndex, dx = 0, dy = 0) {
      const sankeyNodes = target.querySelectorAll('.sankey-node')

      // Map graph node index to node ID
      // Graph node index is index of parent SVG element
      const graphNodeIndexToNodeId = new Map()
      const nodeIdToGraphNodeIndex = new Map()
      for (const [graphNodeIndex, elem] of sankeyNodes.entries()) {
        const node = elem.__data__.node
        const nodeLabel = node.label
        const nodeId = node.customdata.node_id
        graphNodeIndexToNodeId.set(graphNodeIndex, nodeId)
        nodeIdToGraphNodeIndex.set(nodeId, graphNodeIndex)
      }

      const targetNodeCustomData = target.data[0].node.customdata[nodeIndex]
      const graphNodeIndex = nodeIdToGraphNodeIndex.get(targetNodeCustomData.node_id)
      const nodeEl = sankeyNodes[graphNodeIndex]
      if (!nodeEl) {
        console.warn(`Node index ${graphNodeIndex} not found`);
        return;
      }

      // Bounding box to calculate realistic coordinates
      const bbox = nodeEl.getBoundingClientRect();
      const startX = bbox.left + bbox.width / 2;
      const startY = bbox.top + bbox.height / 2;

      // Simulate the exact sequence Plotly's D3 drag expects
      const mousedown = new MouseEvent('mousedown',
        {
          bubbles: true, clientX: startX, clientY: startY
        });

      const mousemove = new MouseEvent('mousemove', {
        bubbles: true, clientX: startX + dx, clientY: startY + dy
      });

      const mouseup = new MouseEvent('mouseup', {
        bubbles: true, clientX: startX + dx, clientY: startY + dy
      });

      // Dispatch events in the right order
      nodeEl.dispatchEvent(mousedown);
      document.dispatchEvent(mousemove); // D3 listens on document for drag moves
      document.dispatchEvent(mouseup);   // D3 listens on document for drag end
    }

    // **********************************
    // * GLOBAL DATA BUILDING FUNCTIONS *
    // **********************************
    function parseRawData() {
      // All scenario info
      const propNameScenarioInfo = "rawScenarioInfo"
      const propNameDevScenarioInfo = "devRawScenarioInfo"
      let targetScenarioInfo = globals[propNameScenarioInfo]
      let targetScenarioInfoPropName = ""
      if (targetScenarioInfo !== undefined) {
        targetScenarioInfoPropName = propNameScenarioInfo
      } else {
        targetScenarioInfoPropName = propNameDevScenarioInfo
      }
      globals[targetScenarioInfoPropName] = globals.uncompress(globals[targetScenarioInfoPropName])

      // All scenario data
      const propNameScenarioData = "rawScenarioData"
      const propDevNameScenarioData = "devRawScenarioData"
      let targetScenarioData = globals[propNameScenarioData]
      let targetScenarioDataPropName = ""
      if (targetScenarioData !== undefined) {
        targetScenarioDataPropName = propNameScenarioData
      } else {
        targetScenarioDataPropName = propDevNameScenarioData
      }
      globals[targetScenarioDataPropName] = globals.uncompress(globals[targetScenarioDataPropName])

      // Parse raw data (current)
      const targetRawData = globals[targetScenarioDataPropName]
      const firstScenarioName = [...Object.keys(targetRawData)][0]
      const result = parseRawScenarioData(targetRawData[firstScenarioName])
      globals.yearToData = result.yearToData
      globals.originalYearToData = result.yearToData

      // Parse all raw scenario info
      const targetRawScenarioInfo = globals[targetScenarioInfoPropName]
      globals.scenarioNameToInfo = parseAllRawScenarioInfo(targetRawScenarioInfo)

      // Parse all raw scenario data
      globals.scenarioNameToYearToData = parseAllRawScenarioData(targetRawData)
    }

    function parseAllRawScenarioInfo(targetData) {
      const scenarioNames = Object.keys(targetData)
      const scenarioNameToInfo = new Map()
      for (const scenarioName of scenarioNames) {
        const rawScenarioInfo = targetData[scenarioName]
        const result = parseScenarioInfo(rawScenarioInfo)
        scenarioNameToInfo.set(scenarioName, result)
      }

      return scenarioNameToInfo
    }

    function parseAllRawScenarioData(targetData) {
      const scenarioNames = Object.keys(targetData)
      const scenarioNameToYearToData = new Map()
      for (const scenarioName of scenarioNames) {
        const rawYearToData = targetData[scenarioName]
        const result = parseRawScenarioData(rawYearToData)
        scenarioNameToYearToData.set(scenarioName, result.yearToData)
      }

      return scenarioNameToYearToData
    }

    function parseScenarioInfo(targetData) {
      return {
        baselineValueName: targetData["baseline_value_name"],
        baselineUnitName: targetData["baseline_unit_name"],
        name: targetData["scenario_name"],
      }
    }

    function parseRawScenarioData(targetData) {
      // Parse data and build mappings
      const years = []
      const yearToData = new Map()
      Object.keys(targetData).map(x => {
        const year = x
        years.push(year)

        const rawYearData = targetData[year]
        const labels = rawYearData["labels"]
        const sources = rawYearData["sources"]
        const targets = rawYearData["targets"]
        const values = rawYearData["values"]
        const nodeColors = rawYearData["node_colors"]
        const linkColors = rawYearData["link_colors"]
        const linkCustomData = rawYearData["link_custom_data"]
        const nodePositionsX = rawYearData["node_positions_x"]
        const nodePositionsY = rawYearData["node_positions_y"]
        const nodeCustomData = rawYearData["node_custom_data"]

        const stockIds = rawYearData["stock_ids"]
        const stockIndicatorNames = rawYearData["stock_indicator_names"]
        const stockIndicatorUnits = rawYearData["stock_indicator_units"]
        const stockInflows = rawYearData["stock_inflows"]
        const stockOutflows = rawYearData["stock_outflows"]
        const stockTotals = rawYearData["stock_totals"]

        let numEmpty = 0
        for (let i = 0; i < nodeCustomData.length; i++) {
          let nodeX = nodeCustomData[i].x
          let nodeY = nodeCustomData[i].y

          let isEmpty = false
          if (isNaN(nodeX) || nodeX == null) {
            nodeX = null
            isEmpty = true
          }

          if (isNaN(nodeY) || nodeY == null) {
            nodeY = null
            isEmpty = true
          }

          if (isEmpty) {
            numEmpty++
          }

          nodePositionsX[i] = nodeX
          nodePositionsY[i] = nodeY
        }

        // No positions for either X or Y
        if (numEmpty == nodeCustomData.length) {
          nodePositionsX.length = 0
          nodePositionsY.length = 0
        }

        // NOTE: Inject more properties to Sankey nodes, could be also done in Python side
        for (const [index, data] of nodeCustomData.entries()) {
          data.label = labels[index]
          data.color = nodeColors[index]
        }

        // NOTE: Inject more properties to Sankey links, could be also done in Python side
        for (const [index, data] of linkCustomData.entries()) {
          data.color = linkColors[index]
        }

        // Build node ID -> Node index -> Node ID mappings
        const nodeIndexToNodeId = new Map()
        const nodeIdToNodeIndex = new Map()
        for (const [nodeIndex, nodeData] of nodeCustomData.entries()) {
          const nodeId = nodeData.node_id
          nodeIndexToNodeId.set(nodeIndex, nodeId)
          nodeIdToNodeIndex.set(nodeId, nodeIndex)
        }

        // Build inflows and outflows: node ID to array
        const nodeIdToInflows = new Map()
        const nodeIdToOutflows = new Map()
        for (let linkIndex = 0; linkIndex < sources.length; linkIndex++) {
          const sourceNodeIndex = sources[linkIndex]
          const targetNodeIndex = targets[linkIndex]
          const sourceNodeId = nodeCustomData[sourceNodeIndex].node_id
          const targetNodeId = nodeCustomData[targetNodeIndex].node_id

          // Inflows to node ID
          if (!nodeIdToInflows.has(targetNodeId)) {
            nodeIdToInflows.set(targetNodeId, [])
          }
          const inflows = nodeIdToInflows.get(targetNodeId)
          inflows.push(linkCustomData[linkIndex])

          // Outflows from node ID
          if (!nodeIdToOutflows.has(sourceNodeId)) {
            nodeIdToOutflows.set(sourceNodeId, [])
          }
          const outflows = nodeIdToOutflows.get(sourceNodeId)
          outflows.push(linkCustomData[linkIndex])
        }

        const entry = {
          labels: labels,
          sources: sources,
          targets: targets,
          values: values,
          nodeColors: nodeColors,
          linkColors: linkColors,
          linkCustomData: linkCustomData,
          nodePositionsX: nodePositionsX,
          nodePositionsY: nodePositionsY,
          nodeCustomData: nodeCustomData,

          // Node ID -> Node index -> Node ID
          nodeIndexToNodeId: nodeIndexToNodeId,
          nodeIdToNodeIndex: nodeIdToNodeIndex,

          // Node ID to flows
          nodeIdToInflows: nodeIdToInflows,
          nodeIdToOutflows: nodeIdToOutflows,

          // Order of node IDs on Sankey graph
          graphNodeIds: [],
          graphNodeIdToGraphNodeIndex: new Map(),
          graphNodePositionsX: [],
          graphNodePositionsY: [],

          // Stock data
          stockIds: stockIds,
          stockIndicatorNames: stockIndicatorNames,
          stockIndicatorUnits: stockIndicatorUnits,
          stockInflows: stockInflows,
          stockOutflows: stockOutflows,
          stockTotals: stockTotals,
        }

        yearToData.set(year, entry)
      })

      return {
        yearToData: yearToData,
        originalYearToData: new Map(JSON.parse(JSON.stringify(Array.from(yearToData))))
      }
    }

    async function buildVisualizationData() {
      // Go through all the years and create hidden Sankey graph
      // to automatically calculate node positions.
      // This also enables to precompute node-arrays
      // so node data can be directly used when generating
      // Sankey graph later.
      const years = globals.getYears()
      for (const [yearIndex, year] of years.entries()) {
        // Create graph and render once to get find out how many nodes and links
        // are used in Sankey graph. It will also compute the node positions
        const yearData = globals.getYearData(year)

        const data = [{
          type: 'sankey',
          orientation: 'h',
          arrangement: 'freeform',
          node: {
            label: yearData.labels,
            color: yearData.nodeColors,
            customdata: yearData.nodeCustomData,
            align: "justify",
            thickness: 20,
            x: [],
            y: [],
            hoverinfo: 'none',
            line: {
              color: "#555",
              width: [0.5],
            },
          },
          link: {
            source: yearData.sources,
            target: yearData.targets,
            value: yearData.values,
            color: yearData.linkColors,
            customdata: yearData.linkCustomData,
            hoverinfo: 'none',
          },
        }]

        const layout = {
          title: {
            text: "Scenario: " + globals.getScenarioName(),
            font: {
              color: "#000",
              size: 20,
            }
          },
          sliders: [{
            active: globals.getIndexForYear(year),
            pad: {
              t: 30,
            },
            currentvalue: {
              xanchor: 'left',
              prefix: "Selected year: ",
              font: {
                color: '#000',
                size: 20,
              }
            },

            steps: years.map(x => ({
              label: x,
              method: 'update',
              args: [],
              execute: false,
            }))
          }],
          transition: {
            duration: 0,
          },
          frame: {
            duration: 0,
          },
          font: {
            size: globals.settings.fontSize,
          }
        }

        const config = {
          editable: false,
          showlegend: false,
          displayModeBar: false,
          responsive: true,
        }

        // Create graph and simulate node drag to filling node positions
        const elem = document.getElementById(globals.elemId)
        await Plotly.newPlot(elem, data, layout, config)
        simulateNodeDrag(elem, 0, 0, 0)

        // Get computed node X and Y position and update yearly node positions
        const fullData = elem._fullData[0]
        const sankey = fullData._sankey
        const nodes = sankey.graph.nodes

        // Calculated node X and Y positions (available after first render)
        const computedNodeX = sankey.trace.node.x
        const computedNodeY = sankey.trace.node.y

        const newNodeX = []
        const newNodeY = []
        const graphNodeIds = [] // Order of the node IDs for each year
        const graphNodeIdToGraphNodeIndex = new Map()
        for (const [nodeIndex, node] of nodes.entries()) {
          const nodeId = node.customdata.node_id
          const targetNodeIndex = yearData.nodeIdToNodeIndex.get(nodeId)
          let x = yearData.nodePositionsX[targetNodeIndex]
          let y = yearData.nodePositionsY[targetNodeIndex]

          // Use computed position if position is not defined
          if (x === undefined || x === null) {
            x = computedNodeX[nodeIndex]
          }

          if (y === undefined || y === null) {
            y = computedNodeY[nodeIndex]
          }

          newNodeX.push(x)
          newNodeY.push(y)
          graphNodeIds.push(nodeId)
          graphNodeIdToGraphNodeIndex.set(nodeId, nodeIndex)
        }

        // Store node X and Y positions and array of used node IDs for this year
        yearData.nodePositionsX = newNodeX
        yearData.nodePositionsY = newNodeY
        yearData.graphNodeIds = graphNodeIds
        yearData.graphNodeIdToGraphNodeIndex = graphNodeIdToGraphNodeIndex

        // Update progress text
        const progressText = document.getElementById("progress-text")
        let progressPercent = ((yearIndex / (years.length - 1)) * 100.0).toFixed(0)
        progressText.textContent = `Building visualizations ${progressPercent}% (${year}/${years[years.length - 1]})`

        // Sleep for one tick to allow updating main thread for UI changes
        await sleep(1)
      }

      setTimeout(() => {
        hideLoadingOverlay()
      }, 250)
    }

    async function buildAllScenarioVisualizationData() {
      // TODO: Go through all the scenarios

      // Go through all the years and create hidden Sankey graph
      // to automatically calculate node positions.
      // This also enables to precompute node-arrays
      // so node data can be directly used when generating
      // Sankey graph later.

      const scenarioNames = globals.getScenarioNames()
      const numYears = globals.getYears().length
      const numScenarios = scenarioNames.length
      const numTotalSteps = numYears * numScenarios

      const years = globals.getYears()
      let totalYearIndex = 0
      const totalYears = []
      for (const _ of scenarioNames) {
        totalYears.push(...years)
      }

      totalYears.sort((a, b) => {
        const intA = parseInt(a)
        const intB = parseInt(b)
        if (intA > intB) {
          return 1
        }
        if (intA < intB) {
          return -1
        }
        return 0
      })

      initProgressOverlay(numTotalSteps)
      for (const scenarioName of scenarioNames) {
        selectScenario(scenarioName)
        const years = globals.getYears()
        for (const [yearIndex, year] of years.entries()) {
          // Create graph and render once to get find out how many nodes and links
          // are used in Sankey graph. It will also compute the node positions
          const yearData = globals.getYearData(year)

          const data = [{
            type: 'sankey',
            orientation: 'h',
            arrangement: 'freeform',
            node: {
              label: yearData.labels,
              color: yearData.nodeColors,
              customdata: yearData.nodeCustomData,
              align: "justify",
              thickness: 20,
              x: [],
              y: [],
              hoverinfo: 'none',
              line: {
                color: "#555",
                width: [0.5],
              },
            },
            link: {
              source: yearData.sources,
              target: yearData.targets,
              value: yearData.values,
              color: yearData.linkColors,
              customdata: yearData.linkCustomData,
              hoverinfo: 'none',
            },
          }]

          const layout = {
            title: {
              text: "Scenario: " + globals.getScenarioName(),
              font: {
                color: "#000",
                size: 20,
              }
            },
            sliders: [{
              active: globals.getIndexForYear(year),
              pad: {
                t: 30,
              },
              currentvalue: {
                xanchor: 'left',
                prefix: "Selected year: ",
                font: {
                  color: '#000',
                  size: 20,
                }
              },

              steps: years.map(x => ({
                label: x,
                method: 'update',
                args: [],
                execute: false,
              }))
            }],
            transition: {
              duration: 0,
            },
            frame: {
              duration: 0,
            },
            font: {
              size: globals.settings.fontSize,
            }
          }

          const config = {
            editable: false,
            showlegend: false,
            displayModeBar: false,
            responsive: true,
          }

          // Create graph and simulate node drag to filling node positions
          const elem = document.getElementById(globals.elemId)
          await Plotly.newPlot(elem, data, layout, config)
          simulateNodeDrag(elem, 0, 0, 0)

          // Get computed node X and Y position and update yearly node positions
          const fullData = elem._fullData[0]
          const sankey = fullData._sankey
          const nodes = sankey.graph.nodes

          // Calculated node X and Y positions (available after first render)
          const computedNodeX = sankey.trace.node.x
          const computedNodeY = sankey.trace.node.y

          const newNodeX = []
          const newNodeY = []
          const graphNodeIds = [] // Order of the node IDs for each year
          const graphNodeIdToGraphNodeIndex = new Map()
          for (const [nodeIndex, node] of nodes.entries()) {
            const nodeId = node.customdata.node_id
            const targetNodeIndex = yearData.nodeIdToNodeIndex.get(nodeId)
            let x = yearData.nodePositionsX[targetNodeIndex]
            let y = yearData.nodePositionsY[targetNodeIndex]

            // Use computed position if position is not defined
            if (x === undefined || x === null) {
              x = computedNodeX[nodeIndex]
            }

            if (y === undefined || y === null) {
              y = computedNodeY[nodeIndex]
            }

            newNodeX.push(x)
            newNodeY.push(y)
            graphNodeIds.push(nodeId)
            graphNodeIdToGraphNodeIndex.set(nodeId, nodeIndex)
          }

          // Store node X and Y positions and array of used node IDs for this year
          yearData.nodePositionsX = newNodeX
          yearData.nodePositionsY = newNodeY
          yearData.graphNodeIds = graphNodeIds
          yearData.graphNodeIdToGraphNodeIndex = graphNodeIdToGraphNodeIndex


          updateProgressOverlay(1, ` (${totalYears[totalYearIndex]}/${totalYears[totalYears.length - 1]})`)
          totalYearIndex += 1

          // Sleep for one tick to allow updating main thread for UI changes
          await sleep(1)
        }
      }

      setTimeout(() => {
        hideLoadingOverlay()
      }, 250)
    }

    // ***************
    // * GLOBAL INIT *
    // ***************
    function init() {
      selectScenario(globals.getScenarioNames()[0])

      // Activate first year on start
      selectYear(globals.getYears()[0], { init: true, calculateNodePositions: true })
      toggleMenu(globals.settings.showMenu)
      populateSelectScenarios()

      // TODO: Populate menu?
      updateWindowMenu()


      // Add global event callbacks
      addEventListener("keydown", onKeyDown)
      addEventListener("resize", debounce(onResize, 100))
      addEventListener("contextmenu", onContextMenu)

      // Add menu event callbacks
      const elemShowVirtualProcesses = document.getElementById("showVirtualProcesses")
      elemShowVirtualProcesses.addEventListener("change", toggleShowVirtualProcesses)

      // Show process label / ID
      const elemShowProcessLabel = document.getElementById("showProcessLabel")
      elemShowProcessLabel.addEventListener("change", toggleShowProcessLabel)
    }

    function initWindows() {
      const windowIdToPropName = globals.settings.windowIdToPropName
      for (const [id, propName] of windowIdToPropName.entries()) {
        const elem = document.getElementById(id)
        const state = globals.settings[propName]
        elem.dataset.show = state
      }
    }

    function initTabs() {
      const id = globals.settings.currentTabId
      const hasId = (id !== undefined) || (id !== null)
      if (!hasId) {
        return
      }

      // Populate tab
      toggleTab(null, id)
    }

    // *******************
    // * OTHER FUNCTIONS *
    // *******************
    function hideLoadingOverlay() {
      const elem = document.getElementById("overlay-wrapper")
      elem.addEventListener("transitionend", () => {
        elem.style.display = "none"
      }, true)

      elem.style.opacity = "0%"
    }

    function toggleWindow(targetId, newState = undefined) {
      const target = document.getElementById(targetId)
      if (target === undefined || target === null) {
        console.log("Element with id", id, "not found")
        return
      }

      const hasNewState = (newState !== undefined) || (newState !== null)
      const windowIdToPropName = globals.settings.windowIdToPropName

      // Hide all existing windows
      const allWindowElems = document.querySelectorAll(`[id^='window-']`)
      for (const elem of allWindowElems) {
        const id = elem.id
        if (id == targetId && hasNewState) {
          continue
        }

        elem.dataset.show = false
        globals.settings[windowIdToPropName.get(elem.id)] = false
      }

      if (newState === undefined || newState === null) {
        // Toggle existing value
        const prevState = globals.settings[windowIdToPropName.get(targetId)]
        newState = !prevState
        globals.settings[windowIdToPropName.get(targetId)] = newState
      } else {
        // Set to new state
        globals.settings[windowIdToPropName.get(targetId)] = newState
      }

      // Change all buttons states to show=false
      const targetButtonId = "button-" + targetId.split("-")[1]
      const allButtonElems = document.querySelectorAll(`[id^='button-']`)
      for (const elem of allButtonElems) {
        if (elem.id == targetButtonId) {
          elem.dataset.show = newState
        } else {
          elem.dataset.show = false
        }
      }

      target.dataset.show = newState
    }

    function useArrangementMode(event) {
      // Change Plotly Sankey chart arrangement mode (freeform/perpendicular)
      Plotly.update(globals.elem, { arrangement: event.target.value })
    }

    function toggleTab(event, id = undefined) {
      let elem = null
      let targetId = null
      const prefix = "tab-"
      const tabIdToElem = new Map()

      const hasEvent = (event !== undefined) || (event !== null)
      const hasId = (id !== undefined) || (id !== null)
      if (hasId) {
        // Use always parameter "id" if provided instead of event
        targetId = id
        elem = document.getElementById(targetId)
        if (elem == undefined || elem == null) {
          console.log("No element", targetId)
          return
        }

        const parentElem = elem.parentElement
        for (const childElem of parentElem.children) {
          const childId = childElem.id
          if (childId) {
            tabIdToElem.set(childId, childElem)
          }
        }
      } else {
        // Use event
        // Get all children of with ID starting "tab-"
        const parentElem = event.target.parentElement
        for (const childElem of parentElem.children) {
          const childId = childElem.id
          if (childId) {
            tabIdToElem.set(childId, childElem)
          }
        }

        targetId = event.target.id
        elem = event.target
      }

      // Hide all tabs except the one that one clicked
      for (const [id, elem] of tabIdToElem) {
        if (id == targetId) {
          elem.dataset.show = true
        } else {
          elem.dataset.show = false
        }
      }

      // Hide all tab contents
      const tabContentElems = document.querySelectorAll(`[id^=tab-content-]`)
      for (const elem of tabContentElems) {
        elem.dataset.show = false
      }

      // Populate active tab and show it
      const yearData = globals.getCurrentYearData()
      if (targetId == "tab-processes") {
        populateTabProcesses("tab-content-processes", yearData)
      }
      if (targetId == "tab-flows") {
        populateTabFlows("tab-content-flows", yearData)
      }
      if (targetId == "tab-stocks") {
        populateTabStocks("tab-content-stocks", yearData)
      }

      globals.settings.currentTabId = targetId
    }

    function populateTabProcesses(id, yearData, filter = null, numDecimals = 3) {
      const elem = document.getElementById(id)
      elem.dataset.show = true

      // Make data rows
      const tableElem = document.getElementById("table-data")
      const headElem = document.getElementById("table-data-head")
      const bodyElem = document.getElementById("table-data-body")
      headElem.replaceChildren()
      bodyElem.replaceChildren()

      const baselineUnitName = globals.getScenarioBaselineUnitName()
      const propNameToColName = new Map([
        ["node_id", "ID"],
        ["label", "Label"],
        ["total_inflows", `Total inflows, ${baselineUnitName}`],
        ["total_outflows", `Total outflows, ${baselineUnitName}`],
        ["has_stock", "Has stock?"],
        ["transformation_stage", "Transformation stage"],
      ])

      // Make headers
      const rowElem = document.createElement("tr")
      for (const [propName, colName] of propNameToColName.entries()) {
        const dataElem = document.createElement("th")
        dataElem.textContent = colName
        rowElem.appendChild(dataElem)
      }
      headElem.appendChild(rowElem)

      // Sort by ascending process ID
      const nodeCustomData = yearData.nodeCustomData.slice()
      const sortedNodeCustomData = nodeCustomData.sort((a, b) => {
        const lowerA = a.node_id.toLowerCase()
        const lowerB = b.node_id.toLowerCase()
        if (lowerA > lowerB) return 1
        if (lowerA < lowerB) return -1
        return 0
      })

      const hasFilter = (filter != null) || (filter != undefined)
      for (const entry of sortedNodeCustomData) {
        if (hasFilter && filter.length > 0) {
          if (!entry.node_id.includes(filter)) {
            continue
          }
        }

        const rowElem = document.createElement("tr")
        rowElem.dataset.type = "process"
        rowElem.dataset.processId = entry.node_id

        for (const propName of propNameToColName.keys()) {
          if (!(propName in entry)) {
            console.log("Property", propName, "not found in process entry")
            continue
          }

          const value = entry[propName]
          const dataElem = document.createElement("td")

          if (propName == "node_id") {
            dataElem.textContent = value
            // dataElem.dataset.processId = entry.node_id
            // dataElem.style.cursor = "default";
            rowElem.appendChild(dataElem)
            continue
          }
          if (propName == "label") {
            dataElem.textContent = value
            rowElem.appendChild(dataElem)
            continue
          }
          if (propName == "total_inflows") {
            dataElem.textContent = formatValue(value)
            rowElem.appendChild(dataElem)
            continue
          }
          if (propName == "total_outflows") {
            dataElem.textContent = formatValue(value)
            rowElem.appendChild(dataElem)
            continue
          }
          if (propName == "has_stock") {
            dataElem.dataset.type = "process-stock"
            dataElem.dataset.hasStock = value
            dataElem.textContent = formatBool(value)

            dataElem.addEventListener("click", (event) => {
              const hasStock = JSON.parse(dataElem.dataset.hasStock)
              if (!hasStock) {
                return
              }

              toggleTab(event, "tab-stocks")
              highlightTableRow("table-stocks-body", "stockId", entry.node_id)
            })

            rowElem.appendChild(dataElem)
            continue
          }

          if (propName == "transformation_stage") {
            dataElem.textContent = value
            rowElem.appendChild(dataElem)
            continue
          }
        }

        bodyElem.appendChild(rowElem)
      }

      if (bodyElem.children.length == 0) {
        const rowElem = document.createElement("tr")
        const tdElem = document.createElement("td")
        tdElem.setAttribute("colspan", propNameToColName.size)
        tdElem.textContent = "No results"
        tdElem.classList.toggle("tab-table-empty-message", true)
        rowElem.appendChild(tdElem)
        bodyElem.appendChild(rowElem)
      }
    }

    function populateTabFlows(id, yearData, filter, numDecimals = 3) {
      const elem = document.getElementById(id)
      elem.dataset.show = true

      // Make data rows
      const tableElem = document.getElementById("table-flows")
      const headElem = document.getElementById("table-flows-head")
      const bodyElem = document.getElementById("table-flows-body")
      headElem.replaceChildren()
      bodyElem.replaceChildren()

      // Get column names from first entry
      const baselineUnitName = globals.getScenarioBaselineUnitName()
      const propNameToColName = new Map([
        ["source_process_id", "Source process ID"],
        ["target_process_id", "Target process ID"],
        ["unit", "Unit"],
        ["baseline_value_name", "Baseline unit name"],
        ["evaluated_value", "Evaluated value"],
        ["evaluated_share", "Evaluated share"],
        ["is_virtual", "Is virtual?"],
      ])

      // Make headers
      const rowElem = document.createElement("tr")
      for (const [propName, colName] of propNameToColName.entries()) {
        const dataElem = document.createElement("th")
        dataElem.textContent = colName
        rowElem.appendChild(dataElem)
      }
      headElem.appendChild(rowElem)

      const linkCustomData = yearData.linkCustomData.slice()
      const sortedLinkCustomData = linkCustomData.sort((a, b) => {
        const lowerA = `${a.source_process_id} ${a.target_process_id}`.toLowerCase()
        const lowerB = `${b.source_process_id} ${b.target_process_id}`.toLowerCase()
        if (lowerA > lowerB) return 1
        if (lowerA < lowerB) return -1
        return 0
      })

      // Populate data
      const hasFilter = (filter != null) || (filter != undefined)
      for (const entry of sortedLinkCustomData) {
        const flow_id = `${entry.source_process_id} ${entry.target_process_id}`
        if (hasFilter && filter.length > 0) {
          if (!flow_id.includes(filter)) {
            continue
          }
        }

        const rowElem = document.createElement("tr")
        rowElem.dataset.type = "flow"
        rowElem.dataset.flowId = `${entry.source_process_id} ${entry.target_process_id}`

        for (const propName of propNameToColName.keys()) {
          const value = entry[propName]
          const dataElem = document.createElement("td")

          if (propName == "source_process_id") {
            dataElem.textContent = value
            rowElem.appendChild(dataElem)
            continue
          }

          if (propName == "target_process_id") {
            dataElem.textContent = value
            rowElem.appendChild(dataElem)
            continue
          }

          if (propName == "unit") {
            dataElem.textContent = value
            rowElem.appendChild(dataElem)
            continue
          }

          if (propName == "baseline_value_name") {
            dataElem.textContent = value
            rowElem.appendChild(dataElem)
            continue
          }

          if (propName == "evaluated_value") {
            dataElem.textContent = formatValue(value)
            rowElem.appendChild(dataElem)
            continue
          }

          if (propName == "evaluated_share") {
            dataElem.textContent = formatValue(value)
            rowElem.appendChild(dataElem)
            continue
          }

          if (propName == "is_virtual") {
            dataElem.textContent = formatBool(value)
            rowElem.appendChild(dataElem)
            continue
          }
        }
        bodyElem.appendChild(rowElem)
      }
    }

    function populateTabStocks(id, yearData, filter) {
      const elem = document.getElementById(id)
      elem.dataset.show = true

      // Make data rows
      const tableElem = document.getElementById("table-stocks")
      const headElem = document.getElementById("table-stocks-head")
      const bodyElem = document.getElementById("table-stocks-body")
      headElem.replaceChildren()
      bodyElem.replaceChildren()

      // Make headers
      const stockIndicatorNames = yearData.stockIndicatorNames
      const stockIndicatorUnits = yearData.stockIndicatorUnits

      let colNames = [
        "Process ID",
        "Lifetime",
        "Distribution type",
        "Distribution type parameters",
      ]

      const rowElem = document.createElement("tr")
      for (const [index, colName] of colNames.entries()) {
        const dataElem = document.createElement("th")
        dataElem.textContent = colName
        rowElem.appendChild(dataElem)
      }
      headElem.appendChild(rowElem)

      // Add stock inflow, outflow, and total
      colNames = [
        "Inflow",
        "Outflow",
        "Total"
      ]

      for (let i = 0; i < stockIndicatorNames.length; i++) {
        for (const colName of colNames) {
          const indicatorElem = document.createElement("th")
          const indicatorName = stockIndicatorNames[i]
          const indicatorUnit = stockIndicatorUnits[i]
          indicatorElem.textContent = `${colName} (${indicatorName}, ${indicatorUnit})`
          rowElem.appendChild(indicatorElem)
        }
      }

      // Get list of processes with lifetime > 0
      const processesWithStock = []
      for (const entry of yearData.nodeCustomData) {
        if (entry.has_stock) {
          processesWithStock.push(entry)
        }
      }

      const sortedProcessesWithStocks = processesWithStock.sort((a, b) => {
        const lowerA = a.node_id.toLowerCase()
        const lowerB = b.node_id.toLowerCase()
        if (lowerA > lowerB) return 1
        if (lowerA < lowerB) return -1
        return 0
      })

      const hasFilter = (filter != null) || (filter != undefined)
      for (const entry of sortedProcessesWithStocks) {
        const rowElem = document.createElement("tr")
        if (hasFilter && filter.length > 0) {
          if (!entry.node_id.toLowerCase().includes(filter)) {
            return
          }
        }

        const stockId = entry.node_id

        rowElem.dataset.type = "stock"
        rowElem.dataset.stockId = stockId

        const stockData = entry.stock
        const stockLifetime = entry.stock.lifetime
        const stockDistributionType = entry.stock.distribution_type
        const stockDistributionParams = entry.stock.distribution_params

        const dataIdElem = document.createElement("td")
        dataIdElem.textContent = entry.node_id
        rowElem.appendChild(dataIdElem)

        // Lifetime
        const dataLifetimeElem = document.createElement("td")
        dataLifetimeElem.textContent = stockLifetime
        rowElem.appendChild(dataLifetimeElem)

        // Distribution type
        const dataDistributionTypeElem = document.createElement("td")
        dataDistributionTypeElem.textContent = stockDistributionType
        rowElem.appendChild(dataDistributionTypeElem)

        // Distribution type element
        const dataDistributionParamsElem = document.createElement("td")

        let text = ""

        // Fixed
        if (stockDistributionType == "Fixed") {
          text = ""
        }

        // Normal: stddev (float)
        if (stockDistributionType == "Normal") {
          text = `stddev=${stockDistributionParams.stddev}`
        }

        // LogNormal: stddev (float)
        if (stockDistributionType == "LogNormal") {
          text = `stddev=${stockDistributionParams.stddev}`
        }

        // FoldedNormal: stddev (float)
        if (stockDistributionType == "FoldedNormal") {
          text = `stddev=${stockDistributionParams.stddev}`
        }

        // Weibull: shape (float), scale (float)
        if (stockDistributionType == "Weibull") {
          text = `shape=${stockDistributionParams.shape}, scale=${stockDistributionParams.scale}`
        }

        // Simple
        if (stockDistributionType == "Simple") {
          text = ""
        }

        // LandfillDecayWood: condition (string)
        if (stockDistributionType == "LandfillDecayWood") {
          text = `condition=${stockDistributionParams.condition}`
        }

        // LandfillDecayPaper: condition (string)
        if (stockDistributionType == "LandfillDecayPaper") {
          text = `condition=${stockDistributionParams.condition}`
        }

        dataDistributionParamsElem.textContent = text
        rowElem.appendChild(dataDistributionParamsElem)

        const stockInflows = yearData.stockInflows[stockId]
        const stockOutflows = yearData.stockOutflows[stockId]
        const stockTotals = yearData.stockTotals[stockId]

        const targets = [
          stockInflows,
          stockOutflows,
          stockTotals,
        ]

        for (let indicatorIndex = 0; indicatorIndex < stockInflows.length; indicatorIndex++) {
          for (const target of targets) {
            const indicatorName = stockIndicatorNames[indicatorIndex]
            const indicatorUnit = stockIndicatorUnits[indicatorIndex]
            const value = target[indicatorIndex]
            const dataIndicatorInflow = document.createElement("td")
            dataIndicatorInflow.textContent = formatValue(value)
            rowElem.appendChild(dataIndicatorInflow)
          }
        }

        bodyElem.appendChild(rowElem)
      }
    }

    function filterProcesses(event, id = "search-processes") {
      const elem = document.getElementById(id)
      const hasElem = (elem !== undefined) || (elem !== null)
      if (!hasElem) {
        console.log("No element", id)
        return
      }

      let filter = ""
      if (event === null) {
        elem.value = ""
        filter = ""
      } else {
        filter = event.target.value
      }

      const yearData = globals.getCurrentYearData()
      populateTabProcesses("tab-content-processes", yearData, filter)
    }

    function filterFlows(event, id = "search-flows") {
      const elem = document.getElementById(id)
      const hasElem = (elem !== undefined) || (elem !== null)
      if (!hasElem) {
        console.log("No element", id)
        return
      }

      let filter = ""
      if (event == null) {
        elem.value = ""
        filter = ""
      } else {
        filter = event.target.value
      }

      const yearData = globals.getCurrentYearData()
      populateTabFlows("tab-content-flows", yearData, filter)
    }

    function filterStocks(event, id = "search-stocks") {
      const elem = document.getElementById(id)
      const hasElem = (elem !== undefined) || (elem !== null)
      if (!hasElem) {
        console.log("No element", id)
        return
      }

      let filter = ""
      if (event == null) {
        elem.value = ""
        filter = ""
      } else {
        filter = event.target.value
      }

      const yearData = globals.getCurrentYearData()
      populateTabStocks("tab-content-stocks", yearData, filter)
    }

    function clearFilterProcesses(event, id = "search-processes") {
      const elem = document.getElementById(id)
      elem.value = ""
      const yearData = globals.getCurrentYearData()
      populateTabProcesses("tab-content-processes", yearData, "")
    }

    function clearFilterFlows(event, id = "search-flows") {
      const elem = document.getElementById(id)
      elem.value = ""
      const yearData = globals.getCurrentYearData()
      populateTabFlows("tab-content-flows", yearData, "")
    }

    function clearFilterStocks(event, id = "search-stocks") {
      const elem = document.getElementById(id)
      elem.value = ""
      const yearData = globals.getCurrentYearData()
      populateTabStocks("tab-content-stocks", yearData, "")
    }

    function populateSelectScenarios(id = "select-scenario") {
      const selectElem = document.getElementById(id)
      const scenarioNames = globals.getScenarioNames()
      const selectedScenarioName = globals.scenario.name
      selectElem.value = selectedScenarioName
      for (const scenarioName of scenarioNames) {
        const optionElem = document.createElement("option")
        optionElem.value = scenarioName
        optionElem.textContent = scenarioName
        selectElem.appendChild(optionElem)
      }
    }

    function highlightTableRow(id, key, value) {
      // Find data element that has key-value pair in dataset
      const tableElem = document.getElementById(id)
      let found = false
      let targetRowElem = undefined
      for (let rowIndex = 0; rowIndex < tableElem.children.length && !found; rowIndex++) {
        const rowElem = tableElem.children[rowIndex]

        // Check if row has key in dataset
        const rowValue = rowElem.dataset[key]
        if (rowValue != undefined) {
          if (rowValue == value) {
            found = true
            targetRowElem = rowElem
            continue
          }
        }

        // Key not found in row dataset, check all data elements in row
        for (let dataIndex = 0; dataIndex < rowElem.children.length; dataIndex++) {
          const dataElem = rowElem.children[dataIndex]
          const dataValue = dataElem.dataset[key]
          if (dataValue !== undefined) {
            if (dataValue == value) {
              found = true
              targetRowElem = rowElem
              continue
            }
          }
        }
      }

      if (found) {
        const elemStyle = getComputedStyle(targetRowElem)
        const originalBackground = elemStyle.background
        setTimeout(() => {
          targetRowElem.classList.toggle("highlight", true)
          const globalStyle = window.getComputedStyle(document.documentElement)
          const background = globalStyle.getPropertyValue('--highlight-background');
          targetRowElem.style.background = background
          targetRowElem.ontransitionend = (event) => {
            targetRowElem.ontransitionend = null
            targetRowElem.style.background = originalBackground
          }
        }, 1)
      }
    }

    function showContextMenu(elem, x, y) {
      const contextMenuOverlay = document.getElementById("context-menu-overlay")
      contextMenuOverlay.dataset.show = true

      const clickListener = (event) => {
        hideContextMenu()
        contextMenuOverlay.dataset.show = false
        contextMenuOverlay.removeEventListener("click", clickListener)
        contextMenuOverlay.removeEventListener("contextmenu", clickListener)
        event.preventDefault()
        return
      }

      contextMenuOverlay.addEventListener("click", clickListener)
      contextMenuOverlay.addEventListener("contextmenu", clickListener)

      const contextMenuElem = document.getElementById("context-menu")
      contextMenuElem.replaceChildren()
      contextMenuElem.style.left = `${x}px`
      contextMenuElem.style.top = `${y}px`

      let processId = null
      let flowId = null
      let stockId = null

      // Table rows
      if (elem.tagName == "TR") {
        processId = elem.dataset.processId
        flowId = elem.dataset.flowId
        stockId = elem.dataset.stockId
      }

      // Sankey node
      if (elem.tagName == "rect") {
        const nodeCustomData = elem.__data__.node.customdata
        processId = nodeCustomData.node_id
      }

      // Sankey link
      if (elem.tagName == "path") {
        const linkCustomData = elem.__data__.link.customdata
        flowId = `${linkCustomData.source_process_id} ${linkCustomData.target_process_id}`
      }

      if (processId) {
        contextMenuElem.appendChild(createProcessContextMenu(elem, processId))
        contextMenuElem.dataset.show = true
      }

      if (flowId) {
        contextMenuElem.appendChild(createFlowContextMenu(elem, flowId))
        contextMenuElem.dataset.show = true
      }

      if (stockId) {
        contextMenuElem.appendChild(createStockContextMenu(elem, stockId))
        contextMenuElem.dataset.show = true
      }

      // Check if context menu goes outside viewport right edge
      const windowW = window.innerWidth
      const rect = contextMenuElem.getBoundingClientRect()
      if (rect.right > windowW) {
        x = windowW - rect.width
        contextMenuElem.style.left = `${x}px`
      }
    }

    function hideContextMenu() {
      const contextMenuElem = document.getElementById("context-menu")
      contextMenuElem.replaceChildren()
      contextMenuElem.dataset.show = false

      const contextMenuOverlay = document.getElementById("context-menu-overlay")
      contextMenuOverlay.dataset.show = false
      globals.settings.showContextMenu = false
    }

    function createProcessContextMenu(elem, processId) {
      const wrapper = document.createElement("div")

      let item = null
      item = document.createElement("div")
      item.classList.toggle("context-menu-item-title", true)
      item.textContent = `Process ${processId}`
      wrapper.appendChild(item)
      item = null

      // Show item for process data
      item = document.createElement("div")
      item.classList.toggle("context-menu-item")
      item.textContent = "Show detailed process data"
      item.addEventListener("click", (event) => {
        createProcessInfoWindow(processId)
        hideContextMenu()
        return
      })
      wrapper.appendChild(item)
      item = null

      // Show item for stock data if process contains stock
      const yearData = globals.getCurrentYearData()
      if (yearData.stockIds.includes(processId)) {
        item = document.createElement("div")
        item.classList.toggle("context-menu-item")
        item.textContent = "Show detailed stock data"
        item.addEventListener("click", (event) => {
          createStockInfoWindow(processId)
          hideContextMenu()
          return
        })
        wrapper.appendChild(item)
        item = null
      }

      globals.settings.showContextMenu = true
      return wrapper
    }

    function createProcessInfoWindow(processId) {
      const years = globals.getYears()

      const yearToIndicatorNames = new Map()
      const yearToIndicatorUnits = new Map()
      const yearToInflows = new Map()
      const yearToOutflows = new Map()

      // Accumulator function for flow indicator values
      const accumulateIndicatorValues = (indicators, flows, indicatorNames, indicatorUnits) => {
        const indicatorTotal = []
        const firstEntry = flows[0]

        let firstEntryIndicatorNames = []
        let firstEntryIndicatorUnits = []
        if (firstEntry == undefined) {
          for (let i = 0; i < indicators.stockIndicatorNames.length; i++) {
            const name = indicators.stockIndicatorNames[i]
            const unit = indicators.stockIndicatorUnits[i]
            firstEntryIndicatorNames.push(name)
            firstEntryIndicatorUnits.push(unit)
          }
        } else {
          firstEntryIndicatorNames = firstEntry.indicator_names
          firstEntryIndicatorUnits = firstEntry.indicator_units
        }

        const flowIndicatorNames = [globals.getScenarioBaselineValueName(), ...firstEntryIndicatorNames]
        const flowIndicatorUnits = [globals.getScenarioBaselineUnitName(), ...firstEntryIndicatorUnits]

        indicatorNames.length = 0
        for (const entry of flowIndicatorNames) {
          indicatorNames.push(entry)
        }

        indicatorUnits.length = 0
        for (const entry of flowIndicatorUnits) {
          indicatorUnits.push(entry)
        }

        // Initialize total indicator values to 0.0
        for (let i = 0; i < indicatorNames.length; i++) {
          indicatorTotal.push(0.0)
        }

        for (const flow of flows) {
          const indicatorValues = flow.evaluated_indicator_values
          for (let i = 0; i < indicatorValues.length; i++) {
            indicatorTotal[i] += indicatorValues[i]
          }
        }

        return indicatorTotal
      }

      for (const year of years) {
        const yearData = globals.getYearData(year)

        let inflows = yearData.nodeIdToInflows.get(processId)
        if (inflows == undefined) {
          inflows = []
        }

        let outflows = yearData.nodeIdToOutflows.get(processId)
        if (outflows == undefined) {
          outflows = []
        }

        const nodeIndex = yearData.nodeIdToNodeIndex.get(processId)
        const nodeCustomData = yearData.nodeCustomData[nodeIndex]
        const indicators = {
          stockIndicatorNames: yearData.stockIndicatorNames,
          stockIndicatorUnits: yearData.stockIndicatorUnits
        }

        // Accumulate inflow indicator values
        const indicatorNames = []
        const indicatorUnits = []
        const inflowValues = accumulateIndicatorValues(indicators, inflows, indicatorNames, indicatorUnits)
        const outflowValues = accumulateIndicatorValues(indicators, outflows, indicatorNames, indicatorUnits)

        // Format inflow and outflow indicator values
        for (let i = 0; i < inflowValues.length; i++) {
          inflowValues[i] = formatValue(inflowValues[i])
        }
        for (let i = 0; i < outflowValues.length; i++) {
          outflowValues[i] = formatValue(outflowValues[i])
        }

        yearToIndicatorNames.set(year, indicatorNames)
        yearToIndicatorUnits.set(year, indicatorUnits)
        yearToInflows.set(year, inflowValues)
        yearToOutflows.set(year, outflowValues)
      }

      const wrapper = document.getElementById("info-window-wrapper")
      wrapper.dataset.show = true

      const baselineUnitName = globals.getScenarioBaselineUnitName()
      const baselineValueName = globals.getScenarioBaselineValueName()

      const elem = document.getElementById("info-window")

      const data = []
      const firstYear = [...yearToIndicatorNames.keys()][0]
      const indicatorNames = yearToIndicatorNames.get(firstYear)
      const indicatorUnits = yearToIndicatorUnits.get(firstYear)
      for (let i = 0; i < indicatorNames.length; i++) {
        const indicatorName = indicatorNames[i]
        const indicatorUnit = indicatorUnits[i]
        const totalInflows = []
        const totalOutflows = []
        for (const year of years) {
          const inflows = yearToInflows.get(year)
          const outflows = yearToOutflows.get(year)
          totalInflows.push(inflows[i])
          totalOutflows.push(outflows[i])
        }

        const dataInflows = {
          x: years,
          y: totalInflows,
          type: 'scatter',
          name: `Total inflows (${indicatorName}, ${indicatorUnit})`,
          line: {
            width: 3,
          },
          hovertemplate: `%{y} ${indicatorUnit}`
        }
        data.push(dataInflows)

        const dataOutflows = {
          x: years,
          y: totalOutflows,
          type: 'scatter',
          name: `Total outflows (${indicatorName}, ${indicatorUnit})`,
          line: {
            width: 3,
          },
          hovertemplate: `%{y} ${indicatorUnit}`
        }
        data.push(dataOutflows)
      }

      const layout = {
        title: {
          text: `Process ${processId} inflows and outflows`
        },
        xaxis: {
          title: {
            text: "Year"
          },
        },
        yaxis: {
          title: {
            text: `Value`
          }
        },
        hovermode: 'x unified',
        autorange: true,
        shapes: [{
          type: "line",
          x0: globals.currentYear,
          x1: globals.currentYear,
          y0: 0,
          y1: 1,
          xref: "x",
          yref: "paper",
          line: {
            color: "black", width: 2,
          }
        }],

        annotations: [{
          x: globals.currentYear,
          y: 1.01,
          xref: "x",
          yref: "paper",
          text: `Selected year: ${globals.currentYear}`,
          showarrow: true,
          arrowhead: 2,
          arrowsize: 1,
          ax: 0,
          ay: -40,
        }],
      }

      const config = {
        editable: false,
        showlegend: false,
        displayModeBar: false,
        responsive: true,
      }

      Plotly.newPlot(elem, data, layout, config)
      globals.settings.showInfoWindow = true
    }

    function closeInfoWindow() {
      const wrapper = document.getElementById("info-window-wrapper")
      wrapper.dataset.show = false
      globals.settings.showInfoWindow = false
    }

    function createFlowContextMenu(elem, flowId) {
      const wrapper = document.createElement("div")

      let item = null
      item = document.createElement("div")
      item.classList.toggle("context-menu-item-title", true)
      item.textContent = `Flow ${flowId}`
      wrapper.appendChild(item)
      item = null

      item = document.createElement("div")
      item.classList.toggle("context-menu-item")
      item.textContent = "Show detailed flow data"
      item.addEventListener("click", (event) => {
        createFlowInfoWindow(flowId)
        hideContextMenu()
        return
      })
      wrapper.appendChild(item)
      item = null

      globals.settings.showContextMenu = true
      return wrapper
    }

    function createFlowInfoWindow(flowId) {
      const years = globals.getYears()
      const yearToEntry = new Map()
      for (const year of years) {
        const yearData = globals.getYearData(year)

        // Find linkCustomData for flowId
        let targetEntry = null
        for (let i = 0; i < yearData.linkCustomData.length && !targetEntry; i++) {
          const entry = yearData.linkCustomData[i]
          const entryFlowId = entry.source_process_id + " " + entry.target_process_id

          if (flowId == entryFlowId) {
            targetEntry = entry
          }
        }

        if (targetEntry) {
          yearToEntry.set(year, targetEntry)
        }
      }

      const wrapper = document.getElementById("info-window-wrapper")
      wrapper.dataset.show = true

      const elem = document.getElementById("info-window")

      // Map indicator index to indicator names
      const firstEntry = yearToEntry.get([...yearToEntry.keys()][0])

      // Indicator names
      const indicatorNames = [firstEntry.baseline_value_name, ...firstEntry.indicator_names]
      const indicatorIndexToName = new Map()
      for (const [index, name] of indicatorNames.entries()) {
        indicatorIndexToName.set(index, name)
      }

      // Indicator units
      const indicatorUnits = [firstEntry.baseline_unit_name, ...firstEntry.indicator_units]
      const indicatorIndexToUnit = new Map()
      for (const [index, name] of indicatorUnits.entries()) {
        indicatorIndexToUnit.set(index, name)
      }

      // Map indicator index to values
      const indicatorIndexToValues = new Map()
      for (const [year, entry] of yearToEntry.entries()) {
        for (let i = 0; i < entry.evaluated_indicator_values.length; i++) {
          const indicatorName = entry.indicator_names[i]
          const indicatorValue = formatValue(entry.evaluated_indicator_values[i])

          if (!indicatorIndexToValues.has(i)) {
            indicatorIndexToValues.set(i, [])
          }

          const indicatorValues = indicatorIndexToValues.get(i)
          indicatorValues.push(indicatorValue)
        }
      }

      // Make line graphs for each indicator (baseline + others)
      const data = []
      for (const index of indicatorIndexToName.keys()) {
        const indicatorName = indicatorIndexToName.get(index)
        const indicatorUnit = indicatorIndexToUnit.get(index)
        const name = `${indicatorName}, ${indicatorUnit}`
        const values = indicatorIndexToValues.get(index)

        const graphData = {
          x: years,
          y: values,
          type: "scatter",
          name: name,
          line: {
            width: 3,
          },
          hovertemplate: `%{y} ${indicatorUnit}`
        }

        data.push(graphData)
      }

      const layout = {
        title: {
          text: `Flow ${flowId} evaluated values`
        },
        xaxis: {
          title: {
            text: "Year"
          }
        },
        yaxis: {
          title: {
            text: `Value`
          }
        },
        hovermode: 'x unified',
        autorange: true,
        shapes: [{
          type: "line",
          x0: globals.currentYear,
          x1: globals.currentYear,
          y0: 0,
          y1: 1,
          xref: "x",
          yref: "paper",
          line: {
            color: "black", width: 2,
          }
        }],

        annotations: [{
          x: globals.currentYear,
          y: 1.01,
          xref: "x",
          yref: "paper",
          text: `Selected year: ${globals.currentYear}`,
          showarrow: true,
          arrowhead: 2,
          arrowsize: 1,
          ax: 0,
          ay: -40,
        }],
      }

      const config = {
        editable: false,
        showlegend: false,
        displayModeBar: false,
        responsive: true,
      }

      Plotly.newPlot(elem, data, layout, config)
      globals.settings.showInfoWindow = true
    }

    function createStockContextMenu(elem, stockId) {
      const wrapper = document.createElement("div")

      let item = null
      item = document.createElement("div")
      item.classList.toggle("context-menu-item-title", true)
      item.textContent = `Stock ${stockId}`
      wrapper.appendChild(item)
      item = null

      item = document.createElement("div")
      item.classList.toggle("context-menu-item")
      item.textContent = "Show detailed stock data"
      item.addEventListener("click", (event) => {
        createStockInfoWindow(stockId)
        hideContextMenu()
        return
      })
      wrapper.appendChild(item)
      item = null

      globals.settings.showContextMenu = true
      return wrapper
    }

    function createStockInfoWindow(stockId) {
      const years = globals.getYears()
      const yearToEntry = new Map()
      for (const year of years) {
        const yearData = globals.getYearData(year)
        const entry = {
          indicatorNames: yearData.stockIndicatorNames,
          indicatorUnits: yearData.stockIndicatorUnits,
          inflows: yearData.stockInflows[stockId],
          outflows: yearData.stockOutflows[stockId],
          totals: yearData.stockTotals[stockId],
        }
        yearToEntry.set(year, entry)
      }

      const wrapper = document.getElementById("info-window-wrapper")
      wrapper.dataset.show = true

      const elem = document.getElementById("info-window")

      // Create graphs for inflows, outflows, and totals for every indicator
      const data = []
      const firstEntry = yearToEntry.get([...yearToEntry.keys()][0])
      const indicatorNames = firstEntry.indicatorNames
      const indicatorUnits = firstEntry.indicatorUnits
      const indicatorNameToInflows = new Map()
      const indicatorNameToOutflows = new Map()
      const indicatorNameToTotals = new Map()
      for (const [index, indicatorName] of indicatorNames.entries()) {
        const indicatorUnit = indicatorUnits[index]
        const valuesInflows = []
        const valuesOutflows = []
        const valuesTotals = []
        for (const [year, entry] of yearToEntry.entries()) {
          const valueInflow = formatValue(entry.inflows[index])
          const valueOutflow = formatValue(entry.outflows[index])
          const valueTotal = formatValue(entry.totals[index])
          valuesInflows.push(valueInflow)
          valuesOutflows.push(valueOutflow)
          valuesTotals.push(valueTotal)
        }

        const dataInflows = {
          x: years,
          y: valuesInflows,
          type: "scatter",
          name: `Inflow (${indicatorName}, ${indicatorUnit})`,
          line: {
            width: 3,
          },
          hovertemplate: `%{y} ${indicatorUnit}`,
        }
        data.push(dataInflows)

        const dataOutflows = {
          x: years,
          y: valuesOutflows,
          type: "scatter",
          name: `Outflow (${indicatorName}, ${indicatorUnit})`,
          line: {
            width: 3,
          },
          hovertemplate: `%{y} ${indicatorUnit}`,
        }
        data.push(dataOutflows)

        const dataTotals = {
          x: years,
          y: valuesTotals,
          type: "scatter",
          name: `Total (${indicatorName}, ${indicatorUnit})`,
          line: {
            width: 3,
          },
          hovertemplate: `%{y} ${indicatorUnit}`,
        }
        data.push(dataTotals)
      }

      const layout = {
        title: {
          text: `Stock ${stockId} evaluated values`
        },
        xaxis: {
          title: {
            text: "Year"
          },

          autorange: true,
          // rangeslider: { range: [years[0], years[years.length - 1]] }
        },
        yaxis: {
          title: {
            text: `Stock values`
          }
        },
        hovermode: 'x unified',

        shapes: [{
          type: "line",
          x0: globals.currentYear,
          x1: globals.currentYear,
          y0: 0,
          y1: 1,
          xref: "x",
          yref: "paper",
          line: {
            color: "black", width: 2,
          }
        }],

        annotations: [{
          x: globals.currentYear,
          y: 1.01,
          xref: "x",
          yref: "paper",
          text: `Selected year: ${globals.currentYear}`,
          showarrow: true,
          arrowhead: 2,
          arrowsize: 1,
          ax: 0,
          ay: -40,
        }],
      }

      const config = {
        editable: false,
        showlegend: false,
        displayModeBar: false,
        responsive: true,
      }

      Plotly.newPlot(elem, data, layout, config)
      globals.settings.showInfoWindow = true
    }

    function closeInfoWindow() {
      const wrapper = document.getElementById("info-window-wrapper")
      wrapper.dataset.show = false
      globals.settings.showInfoWindow = false
    }

    function toggleMenu(newState, opts = { keepPosition: false }) {
      const elem = document.getElementById("menu-wrapper")

      // Toggle menu state if not parameter defined
      if (newState === undefined) {
        globals.settings.showMenu = !globals.settings.showMenu
      } else {
        globals.settings.showMenu = newState
      }

      const showMenu = globals.settings.showMenu
      if (showMenu) {
        // Open menu
        elem.dataset.show = true
        globals.settings.showMenu = true

        if (!opts.keepPosition) {
          // Reset to default X and Y position when opening menu
          const style = window.getComputedStyle(document.documentElement)
          const defaultX = parseFloat(style.getPropertyValue("--menu-x-default"), 10)
          const defaultY = parseFloat(style.getPropertyValue("--menu-y-default"), 10)
          document.documentElement.style.setProperty("--menu-x", `${defaultX}px`)
          document.documentElement.style.setProperty("--menu-y", `${defaultY}px`)
        }

        updateMenu()
      } else {
        // Close menu
        elem.dataset.show = false
        globals.settings.showMenu = false
      }
    }

    function toggleShowVirtualProcesses(event) {
      let showVirtualProcesses = false
      if (typeof event == "boolean") {
        showVirtualProcesses = event
      } else {
        showVirtualProcesses = event.target.value == "yes" ? true : false
      }
      globals.settings.showVirtualProcesses = showVirtualProcesses

      // Map nodes
      const virtualNodeIndices = []
      const nodeIndexToDataIndex = new Map()
      const elemNodes = document.querySelectorAll(`#${globals.elemId} .sankey-node`)
      for (const [graphNodeIndex, graphNode] of elemNodes.entries()) {
        const nodeData = graphNode.__data__.node
        const dataIndex = nodeData.pointNumber
        nodeIndexToDataIndex.set(graphNodeIndex, dataIndex)
        if (nodeData.customdata.is_virtual) {
          virtualNodeIndices.push(graphNodeIndex)
        }
      }

      // Map links
      const virtualLinkIndices = []
      const linkIndexToDataIndex = new Map()
      const elemLinks = document.querySelectorAll(`#${globals.elemId} .sankey-link`)
      for (const [graphNodeIndex, graphNode] of elemLinks.entries()) {
        const linkData = graphNode.__data__.link
        const dataIndex = linkData.pointNumber
        linkIndexToDataIndex.set(graphNodeIndex, dataIndex)
        if (linkData.customdata.is_virtual) {
          virtualLinkIndices.push(graphNodeIndex)
        }
      }

      // Gather list of node IDs that are virtual nodes
      const yearData = globals.getCurrentYearData()
      if (showVirtualProcesses) {
        // Show virtual processes
        for (const graphNodeIndex of virtualNodeIndices) {
          const graphNode = elemNodes[graphNodeIndex]
          for (const childNode of graphNode.children) {
            childNode.style.opacity = 1
            childNode.style.pointerEvents = "auto"
          }

          const dataIndex = nodeIndexToDataIndex.get(graphNodeIndex)
          yearData.nodeColors[dataIndex] = yearData.nodeCustomData[dataIndex].color
          yearData.nodeCustomData[dataIndex].is_visible = true
        }

        // Show virtual flows
        for (const linkNodeIndex of virtualLinkIndices) {
          const graphNode = elemLinks[linkNodeIndex]
          graphNode.style.opacity = 1
          graphNode.style.pointerEvents = "auto"

          const dataIndex = linkIndexToDataIndex.get(linkNodeIndex)
          yearData.linkColors[dataIndex] = yearData.linkCustomData[dataIndex].color
          yearData.linkCustomData[dataIndex].is_visible = true
        }

        restyleYear(globals.currentYear)
      } else {
        // Hide virtual processes
        for (const graphNodeIndex of virtualNodeIndices) {
          const graphNode = elemNodes[graphNodeIndex]
          for (const childNode of graphNode.children) {
            childNode.style.opacity = 0
            childNode.style.pointerEvents = "none"
          }

          const dataIndex = nodeIndexToDataIndex.get(graphNodeIndex)
          yearData.nodeColors[dataIndex] = "rgba(0,0,0,0)"
          yearData.nodeCustomData[dataIndex].is_visible = false
        }

        // Hide virtual flows
        for (const linkNodeIndex of virtualLinkIndices) {
          const graphNode = elemLinks[linkNodeIndex]
          graphNode.style.opacity = 0
          graphNode.style.pointerEvents = "none"

          const dataIndex = linkIndexToDataIndex.get(linkNodeIndex)
          yearData.linkColors[dataIndex] = "rgba(0,0,0,0)"
          yearData.linkCustomData[dataIndex].is_visible = false
        }
      }
    }

    function toggleShowProcessLabel(event) {
      const value = event.target.value == "yes" ? true : false
      globals.settings.showProcessLabel = value

      // Apply changes to all years
      const years = globals.getYears()
      for (const year of years) {
        const yearData = globals.getYearData(year)
        if (value) {
          // Use node label from node custom data
          for (const [nodeIndex, nodeCustomData] of yearData.nodeCustomData.entries()) {
            yearData.labels[nodeIndex] = nodeCustomData.label
          }
        } else {
          // Use node ID from node custom data
          for (const [nodeIndex, nodeCustomData] of yearData.nodeCustomData.entries()) {
            yearData.labels[nodeIndex] = nodeCustomData.node_id
          }
        }
      }

      restyleYear(globals.currentYear)
    }

    function moveMenuStart(event) {
      const menu = document.getElementById("menu-wrapper")
      const posRectStart = menu.getBoundingClientRect()
      const posStart = { x: event.clientX, y: event.clientY }

      const onMouseMove = function (ev) {
        const posUpdate = {
          x: ev.clientX,
          y: ev.clientY
        }

        const posDiff = {
          x: posUpdate.x - posStart.x,
          y: posUpdate.y - posStart.y
        }

        const newPos = {
          x: posRectStart.x + posDiff.x,
          y: posRectStart.y + posDiff.y
        }

        // Update menu position to CSS variables
        document.documentElement.style.setProperty("--menu-x", `${newPos.x}px`)
        document.documentElement.style.setProperty("--menu-y", `${newPos.y}px`)
      }

      const onMouseUp = function (ev) {
        removeEventListener("mousemove", onMouseMove)
        removeEventListener("mouseup", onMouseUp)
      }

      addEventListener("mousemove", onMouseMove)
      addEventListener("mouseup", onMouseUp)
    }

    function updateWindows() {
      if (globals.settings.showSettings) {
        updateWindowMenu()
      }

      if (globals.settings.showTools) {
        updateWindowTools()
      }

      if (globals.settings.showData) {
        updateWindowData()
      }
    }

    function updateWindowMenu() {
      updateMenu()
    }
    function updateWindowTools() {
      // console.log("Update window Tools")
    }
    function updateWindowData() {
      toggleTab(event, globals.settings.currentTabId)
    }

    function updateMenu() {
      // Reset "Show virtual processes" to
      const elemShowVirtualProcesses = document.getElementById("showVirtualProcesses")
      elemShowVirtualProcesses.value = globals.settings.showVirtualProcesses ? "yes" : "no"
      refreshNodePositions()
      updateMenuNodeInfo()
    }

    function updateMenuNodeInfo() {
      createNodeTable(globals.getCurrentYearData())
    }

    function createNodeTable(yearData) {
      const elemTableBody = document.getElementById("process-info-body")
      try {
        elemTableBody.replaceChildren()
      } catch (ex) { }

      const sortedNodeIds = [...yearData.graphNodeIds.entries()].sort((a, b) => {
        if (a[1] < b[1]) {
          return -1
        } else if (a[1] > b[1]) {
          return 1
        }
        return 0
      })

      for (const [graphNodeIndex, graphNodeId] of sortedNodeIds) {
        const elemRow = createNodeTableRow(yearData, graphNodeIndex, graphNodeId)
        elemTableBody.appendChild(elemRow)
      }
    }

    function createNodeTableRow(yearData, graphNodeIndex, graphNodeId, numDecimalPlaces = globals.settings.numDecimalPlaces) {
      const x = yearData.nodePositionsX[graphNodeIndex]
      const y = yearData.nodePositionsY[graphNodeIndex]

      const nodeIndex = yearData.nodeIdToNodeIndex.get(graphNodeId)
      const nodeCustomData = yearData.nodeCustomData[nodeIndex]

      const nodeLabel = yearData.labels[nodeIndex]
      const nodeId = yearData.nodeCustomData[nodeIndex].node_id
      const nodePosX = formatPosition(x)
      const nodePosY = formatPosition(y)

      // New row
      const elemRow = document.createElement("tr")

      // Process ID
      const elemDataId = document.createElement("td")
      elemDataId.dataset.type = "id"
      elemDataId.dataset.nodeId = nodeId
      elemDataId.innerHTML = nodeId
      elemRow.appendChild(elemDataId)

      // Process label
      const elemDataLabel = document.createElement("td")
      elemDataLabel.dataset.type = "label"
      elemDataLabel.dataset.nodeId = nodeId
      elemDataLabel.innerHTML = nodeLabel
      elemRow.appendChild(elemDataLabel)

      // Process normalized X position
      // Initialize with span
      const elemDataX = document.createElement("td")
      elemDataX.dataset.type = "pos-x"
      elemDataX.dataset.nodeId = nodeId

      const elemSpanX = document.createElement("span")
      elemSpanX.dataset.nodeId = nodeId
      elemSpanX.innerHTML = x
      elemSpanX.addEventListener("dblclick", (event) => onSpanDoubleClicked(event, "nodePositionsX", "x"))
      elemDataX.appendChild(elemSpanX)
      elemRow.appendChild(elemDataX)

      // Process normalized Y position
      // Initialize with span
      const elemDataY = document.createElement("td")
      elemDataY.dataset.type = "pos-y"
      elemDataY.dataset.nodeId = nodeId

      const elemSpanY = document.createElement("span")
      elemSpanY.dataset.nodeId = nodeId
      elemSpanY.innerHTML = y
      elemSpanY.addEventListener("dblclick", (event) => onSpanDoubleClicked(event, "nodePositionsY", "y"))
      elemDataY.appendChild(elemSpanY)
      elemRow.appendChild(elemDataY)

      return elemRow
    }

    function onSpanDoubleClicked(event, targetPropName, posPropName) {
      const tagName = event.target.tagName
      if (tagName === 'SPAN') {
        // Change span to input when user double-clicks the value
        // When input loses focus then convert back to span
        const value = event.target.textContent
        const parent = event.target.parentNode

        const elemInput = document.createElement("input")
        elemInput.setAttribute("type", "number")
        elemInput.setAttribute("min", "0.0")
        elemInput.setAttribute("max", "1.0")
        elemInput.setAttribute("step", "0.001")
        elemInput.value = value

        // Store also the original value
        elemInput.dataset.nodeId = event.target.dataset.nodeId
        elemInput.dataset.orig = value

        // Focus out
        elemInput.addEventListener("focusout", (ev) => {
          // Update node position for current year
          const yearData = globals.getCurrentYearData()

          const newValue = clamp(formatValue(ev.target.value), 0.001, 0.999)
          const nodeId = elemInput.dataset.nodeId
          const nodeIndex = yearData.graphNodeIdToGraphNodeIndex.get(nodeId)
          yearData[targetPropName][nodeIndex] = parseFloat(newValue)

          const newElemSpan = document.createElement("span")
          newElemSpan.dataset.nodeId = nodeId
          newElemSpan.textContent = newValue
          newElemSpan.addEventListener("dblclick", (newEvent) => onSpanDoubleClicked(newEvent, targetPropName, posPropName))

          const parent = ev.target.parentNode
          parent.replaceChildren()
          parent.appendChild(newElemSpan)
          restyleYear(globals.currentYear)
        })

        elemInput.addEventListener("change", (ev) => {
          // Update node position for current year
          const yearData = globals.getCurrentYearData()

          const newValue = clamp(formatValue(ev.target.value), 0.001, 0.999)
          const nodeId = elemInput.dataset.nodeId
          const nodeIndex = yearData.graphNodeIdToGraphNodeIndex.get(nodeId)
          yearData[targetPropName][nodeIndex] = parseFloat(newValue)

          // Update node position in graph and rebuild menu
          const prop = `node.${posPropName}[${nodeIndex}]`
          const dataUpdate = {}
          dataUpdate[prop] = newValue
          Plotly.update(globals.elem, dataUpdate)
        })

        elemInput.addEventListener("keydown", (ev) => {
          if (ev.code == "Escape") {
            // Lose focus and do not save changes
            const yearData = globals.getCurrentYearData()

            const newValue = clamp(formatValue(elemInput.dataset.orig), 0.001, 0.999)
            const nodeId = ev.target.dataset.nodeId

            // Update node position
            const nodeIndex = yearData.graphNodeIdToGraphNodeIndex.get(nodeId)
            yearData[targetPropName][nodeIndex] = parseFloat(newValue)

            const newElemSpan = document.createElement("span")
            newElemSpan.dataset.nodeId = nodeId
            newElemSpan.textContent = newValue
            newElemSpan.addEventListener("dblclick", (newEvent) => onSpanDoubleClicked(newEvent, targetPropName, posPropName))

            // NOTE: Required because removing child node causes NotFound-exception
            // because not node is not children of parent anymore
            try {
              const parent = ev.target.parentNode
              parent.replaceChildren()
              parent.appendChild(newElemSpan)
            } catch (ex) { }

            // Update node position in graph and rebuild menu
            const prop = `node.${posPropName}[${nodeIndex}]`
            const dataUpdate = {}
            dataUpdate[prop] = newValue
            Plotly.update(globals.elem, dataUpdate)
            toggleMenu(true, { keepPosition: true })
          }

          if (ev.code == "Enter") {
            // Lose focus and save changes
            const yearData = globals.getCurrentYearData()

            const newValue = clamp(formatValue(ev.target.value), 0.001, 0.999)
            const nodeId = ev.target.dataset.nodeId
            const nodeIndex = yearData.graphNodeIdToGraphNodeIndex.get(nodeId)
            yearData[targetPropName][nodeIndex] = parseFloat(newValue)

            const newElemSpan = document.createElement("span")
            newElemSpan.dataset.nodeId = nodeId
            newElemSpan.textContent = newValue
            newElemSpan.addEventListener("dblclick", (newEvent) => onSpanDoubleClicked(newEvent, targetPropName, posPropName))

            // NOTE: Required because removing child node causes NotFound-exception
            // because not node is not children of parent anymore
            try {
              const parent = ev.target.parentNode
              parent.replaceChildren()
              parent.appendChild(newElemSpan)
            } catch (ex) { }

            // Update node position in graph and rebuild menu
            const prop = `node.${posPropName}[${nodeIndex}]`
            const dataUpdate = {}
            dataUpdate[prop] = newValue
            Plotly.update(globals.elem, dataUpdate)
            toggleMenu(true, { keepPosition: true })
          }
        })

        parent.replaceChildren()
        parent.appendChild(elemInput)
        elemInput.focus()
      }
    }

    function onResize(event) {
      selectYear(globals.currentYear)
      updateMenu()
    }

    function onSliderValueChanged(data) {
      const nextYear = data.step.value
      selectYear(nextYear)
    }

    function onRestyle(event) {
      if (globals.init) {
        return
      }

      updateMenu()
    }

    function onKeyDown(event) {
      // Global "keydown" event callback
      if (globals.settings.showContextMenu || globals.settings.showInfoWindow) {
        return
      }

      let nextYearIndex = -1
      let changedYear = false
      const years = globals.getYears()

      if (event.code === 'ArrowLeft') {
        // Go to previous year
        nextYearIndex = globals.getIndexForYear(globals.currentYear) - 1
        changedYear = true
      }

      if (event.code === 'ArrowRight') {
        // Go to next year
        nextYearIndex = globals.getIndexForYear(globals.currentYear) + 1
        changedYear = true
      }

      if (event.code === "Home") {
        // Go to first year
        nextYearIndex = 0
        changedYear = true
      }

      if (event.code === 'End') {
        // Go to last year
        nextYearIndex = years.length - 1
        changedYear = true
      }

      // Prevent changing years when targeting input-element
      const isInputFocused = event.target.tagName === "INPUT"
      if (isInputFocused && changedYear) {
        return
      }

      if (changedYear) {
        // Check nextYearIndex only if year index has changed
        if (nextYearIndex < 0) {
          // Prevent going below first year (= first index)
          nextYearIndex = 0
          return
        }

        if (nextYearIndex > years.length - 1) {
          // Prevent going after last year (= last index)f
          nextYearIndex = years.length - 1
          return
        }

        const nextYear = globals.getYearForIndex(nextYearIndex)
        selectYear(nextYear)
      }

      // Global actions

      // // Apply process positions to all years
      // const keyCopyNodePositions = "KeyC"
      // if (event.code == keyCopyNodePositions) {
      //   // Copy current year node positions to all years
      //   // if node IDs match with other years
      //   applyPositionsToAllYears()
      //   return
      // }

      // const keyCopyToClipboard = "KeyV"
      // if (event.code == keyCopyToClipboard) {
      //   // Copy current year node positions to all years
      //   // if node IDs match with other years
      //   copyPositionsToClipboard()
      //   return
      // }

      // const keyToggleShowVirtualProcesses = "KeyV"
      // if (event.code == keyToggleShowVirtualProcesses) {
      //   toggleShowVirtualProcesses(!globals.settings.showVirtualProcesses)
      // }

      //
      const keyToggleMenu = "KeyM"
      if (event.code == keyToggleMenu) {
        toggleMenu()
        return
      }
    }

    function onContextMenu(event) {
      // Global context menu handler
      let elem = event.target

      // Context menu for rows in tab tables
      if (elem.tagName == "TD") {
        const row = elem.parentElement
        let processId = null
        let flowId = null
        let stockId = null
        if (row.dataset.type == "process") {
          processId = row.dataset.processId
        }
        if (row.dataset.type == "flow") {
          flowId = row.dataset.flowId
        }
        if (row.dataset.type == "stock") {
          stockId = row.dataset.stockId
        }

        if (processId) {
          showContextMenu(row, event.clientX, event.clientY)
        }
        if (flowId) {
          showContextMenu(row, event.clientX, event.clientY)
        }
        if (stockId) {
          showContextMenu(row, event.clientX, event.clientY)
        }
      }

      let isSankeyNode = false
      let isSankeyLink = false
      if (elem.tagName == "text") {
        // Select Sankey node from text (first child of parent <g>)
        elem = elem.parentElement.children[0]
      }
      if (elem.classList.contains("node-rect")) {
        isSankeyNode = true
      }
      if (elem.classList.contains("sankey-link")) {
        isSankeyLink = true
      }
      if (isSankeyNode) {
        showContextMenu(elem, event.clientX, event.clientY)
      }
      if (isSankeyLink) {
        showContextMenu(elem, event.clientX, event.clientY)
      }

      event.preventDefault()
    }

    function onFontSizeChanged(event) {
      globals.settings.fontSize = parseInt(event.target.value)
      restyleYear(globals.currentYear)
    }

    function onScenarioChanged(event) {
      selectScenario(event.target.value)
      selectYear(globals.currentYear)
    }

    function selectScenario(scenarioName) {
      globals.yearToData = globals.getScenarioData(scenarioName)
      globals.scenario = globals.getScenarioInfo(scenarioName)
    }

    function selectYear(year, opts = { calculateNodePositions: false }) {
      // Store current year node positions
      if (globals.elem) {
        const yearData = globals.getCurrentYearData()
        const fullData = globals.elem._fullData[0]
        const node = fullData.node
        yearData.nodePositionsX = node.x
        yearData.nodePositionsY = node.y
      }

      hideTooltip()

      // Update current year to year-parameter
      globals.currentYear = year
      globals.elem = null
      createPlotlyGraph(year, opts)

      // Reset show virtual processes to true
      updateMenu()
      toggleShowVirtualProcesses(true)
      updateWindows()
    }

    function restyleYear(year) {
      createPlotlyGraph(year)
    }

    function createPlotlyGraph(year, opts = { calculateNodePositions: false }) {
      const years = globals.getYears()
      const yearData = globals.getYearData(year)

      const data = [{
        type: 'sankey',
        orientation: 'h',
        arrangement: 'freeform',
        node: {
          label: yearData.labels,
          color: yearData.nodeColors,
          customdata: yearData.nodeCustomData,
          align: "justify",
          thickness: 20,
          x: yearData.nodePositionsX,
          y: yearData.nodePositionsY,
          hoverinfo: 'none',
          line: {
            color: "#555",
            width: [0.5],
          },
        },
        link: {
          arrowlen: 5,
          source: yearData.sources,
          target: yearData.targets,
          value: yearData.values,
          color: yearData.linkColors,
          customdata: yearData.linkCustomData,
          hoverinfo: 'none',
        },
      }]

      const layout = {
        title: {
          text: "Scenario: " + globals.getScenarioName(),
          font: {
            color: "#000",
            size: 20,
          }
        },
        sliders: [{
          active: globals.getIndexForYear(year),
          pad: {
            t: 30,
          },
          currentvalue: {
            xanchor: 'left',
            prefix: "Selected year: ",
            font: {
              color: '#000',
              size: 20,
            }
          },

          steps: years.map(x => ({
            label: x,
            method: 'update',
            args: [],
            execute: false,
          }))
        }],
        transition: {
          duration: 0,
        },
        frame: {
          duration: 0,
        },
        font: {
          size: globals.settings.fontSize,
        }
      }

      const config = {
        editable: false,
        showlegend: false,
        displayModeBar: false,
        responsive: true,
      }

      // Initialize Plotly plot and attach listener to it
      const elem = document.getElementById(globals.elemId)
      Plotly.newPlot(elem, data, layout, config)
      elem.on("plotly_sliderchange", onSliderValueChanged)
      elem.on("plotly_restyle", onRestyle)
      globals.elem = elem
      updateMenuNodeInfo()

      // Attach event listeners to nodes
      const nodeElems = document.querySelectorAll("#plotly .sankey-node")
      for (const elem of nodeElems) {
        elem.addEventListener("mousedown", (ev) => {
          globals.settings.isDragging = true
          hideTooltip()
        })

        elem.addEventListener("mouseup", (ev) => {
          globals.settings.isDragging = false
          hideTooltip()

          // Calculate node normalized position update update position to year data
          const nodeData = ev.target.__data__
          const node = nodeData.node
          const nodeId = node.customdata.node_i

          const sankey = nodeData.trace._sankey
          const nx = (node.x0 + node.dx * 0.5) / sankey.width
          const ny = (node.y0 + node.dy * 0.5) / sankey.height
          globals.updateNodePosition(globals.currentYear, nodeId, nx, ny)
        })


        elem.addEventListener("mouseenter", (ev) => {
          const node = ev.target.__data__.node
          if (!node.customdata.is_visible) {
            hideTooltip()
            return
          }
          showNodeTooltip(node, ev)
        })

        elem.addEventListener("mousemove", (ev) => {
          const node = ev.target.__data__.node
          if (globals.settings.isDragging) {
            hideTooltip()
            return
          }

          if (!node.customdata.is_visible) {
            hideTooltip()
            return
          }

          // Show tooltip only when not dragging and moving
          // over node
          const pos = { x: 0, y: 0 }
          showNodeTooltip(node, ev)
        })

        elem.addEventListener("mouseleave", (ev) => {
          hideTooltip()
        })
      }

      // Attach event listeners to links
      const linkElems = document.querySelectorAll("#plotly .sankey-link")
      for (const elem of linkElems) {
        elem.addEventListener("mouseenter", (ev) => {
          const link = ev.target.__data__.link
          if (!link.customdata.is_visible) {
            hideTooltip()
            return
          }

          showLinkTooltip(link, ev)
        })

        elem.addEventListener("mousemove", (ev) => {
          const link = ev.target.__data__.link

          if (globals.settings.isDragging) {
            hideTooltip()
            return
          }

          if (!link.customdata.is_visible) {
            hideTooltip()
            return
          }

          showLinkTooltip(link, ev)
        })

        elem.addEventListener("mouseleave", (ev) => {
          hideTooltip()
        })
      }
    }

    function getYearNodePositions(target, year) {
      const yearData = globals.getYearData(year)

      const fullData = target._fullData[0]
      const sankey = fullData._sankey
      const graph = sankey.graph
      const trace = sankey.trace
      const nodes = graph.nodes

      const newNodeX = []
      const newNodeY = []
      const nodeIndexToNodeId = new Map()
      for (const [nodeIndex, node] of nodes.entries()) {
        const nodeId = node.customdata.node_id
        const targetNodeIndex = yearData.nodeIdToNodeIndex.get(nodeId)
        const x = yearData.nodePositionsX[targetNodeIndex]
        const y = yearData.nodePositionsY[targetNodeIndex]
        newNodeX.push(x)
        newNodeY.push(y)
      }

      return { x: newNodeX, y: newNodeY }
    }

    function refreshNodePositions(year = globals.currentYear) {
      const targetYearData = globals.getYearData(year)
      const graphNodes = globals.elem.data[0].node
      for (let i = 0; i < graphNodes.x.length; i++) {
        targetYearData.nodePositionsX[i] = formatValue(graphNodes.x[i])
        targetYearData.nodePositionsY[i] = formatValue(graphNodes.y[i])
      }
    }

    function applyPositionsToAllYears() {
      globals.toast("Applied current year process positions to all years", globals.settings.toastDurationInMs)

      // Get and store current yaer node positions
      refreshNodePositions(globals.currentYear)

      // Map this years process ID to normalized position
      const sourceYearData = globals.getCurrentYearData()
      const sourceNodeIdToNormalizedPos = new Map()
      for (const [sourceNodeIndex, sourceNodeId] of sourceYearData.graphNodeIds.entries()) {
        const x = sourceYearData.nodePositionsX[sourceNodeIndex]
        const y = sourceYearData.nodePositionsY[sourceNodeIndex]
        sourceNodeIdToNormalizedPos.set(sourceNodeId, { x, y })
      }

      // Apply position to all others years except current year
      for (const targetYear of globals.yearToData.keys()) {
        if (targetYear == globals.currentYear) {
          continue
        }

        // Apply position from current year to target year only to nodes
        // that are found in both source and target year
        const targetYearData = globals.getYearData(targetYear)
        const targetNodeIdToTargetNodeIndex = new Map()
        for (const [targetNodeIndex, targetNodeId] of targetYearData.graphNodeIds.entries()) {
          targetNodeIdToTargetNodeIndex.set(targetNodeId, targetNodeIndex)
        }

        for (const [sourceNodeId, sourceNodeNormalizedPos] of sourceNodeIdToNormalizedPos.entries()) {
          const targetNodeIndex = targetNodeIdToTargetNodeIndex.get(sourceNodeId)
          const targetNodeId = targetYearData.graphNodeIds[targetNodeIndex]
          if (targetNodeIndex === undefined) {
            continue
          }

          targetYearData.nodePositionsX[targetNodeIndex] = sourceNodeNormalizedPos.x
          targetYearData.nodePositionsY[targetNodeIndex] = sourceNodeNormalizedPos.y
        }
      }
    }

    function copyPositionsToClipboard() {
      const yearData = globals.getCurrentYearData()

      // Header
      let headerColNames =
        [
          "Year",
          "Process ID",
          "Normalized X",
          "Normalized Y",
        ]

      // Header
      let text = ""
      text += headerColNames.join("\t") + "\n"

      // Values
      // const years = globals.getYears()
      // for (const year of years) {
      //   const yearData = globals.getYearData(year)
      //   for (let i = 0; i < yearData.nodeCustomData.length; i++) {
      //     const nodeId = yearData.nodeCustomData[i].node_id
      //     const x = yearData.nodePositionsX[i]
      //     const y = yearData.nodePositionsY[i]

      //     let line = [year, nodeId, x, y].join("\t") + "\n"
      //     text += line
      //   }
      // }

      // navigator.clipboard.writeText(text).then(() => {
      //   globals.toast("Copied all positions to clipboard")
      // }, (err) => {
      //   globals.toast("Unable to copy to clipboard", 2000, "error")
      // })

      // let year = 1900
      // const fullData = globals.elem._fullData[0]
      // const sankeyNodeSet = document.querySelectorAll(".sankey-node-set")[0]
      // for (const sankeyNode of sankeyNodeSet.children) {
      //   const node = sankeyNode.__data__
      //   const nodeId = node.node.customdata.node_id
      //   const nodeIndex = node.node.index
      //   const nodeDataIndex = node.node.pointNumber // index in yearData.nodePositionsX

      //   const x = fullData.node.x[nodeIndex]
      //   const y = fullData.node.y[nodeIndex]

      //   let line = [year, nodeId, x, y].join("\t") + "\n"
      //   text += line
      // }

      // navigator.clipboard.writeText(text).then(() => {
      //   globals.toast("Copied all positions to clipboard")
      // }, (err) => {
      //   globals.toast("Unable to copy to clipboard", 2000, "error")
      // })

      const years = globals.getYears()
      for (const year of years) {
        const yearData = globals.getYearData(year)
        for (const [index, nodeId] of yearData.graphNodeIds.entries()) {
          const x = yearData.nodePositionsX[index]
          const y = yearData.nodePositionsY[index]
          let line = [year, nodeId, x, y].join("\t") + "\n"
          text += line
        }
      }

      navigator.clipboard.writeText(text).then(() => {
        globals.toast("Copied all positions to clipboard")
      }, (err) => {
        globals.toast("Unable to copy to clipboard", 2000, "error")
      })
    }

    function showNodeTooltip(elem, event) {
      const pos = { x: event.clientX + 10, y: event.clientY }

      // Get node custom data for current year
      const yearData = globals.getCurrentYearData()
      const nodeIndex = elem.index
      const nodeCustomData = elem.customdata
      const nodeId = nodeCustomData.node_id
      const nodeLabel = elem.label
      const nodeValue = elem.value
      const nodeTransformationStage = nodeCustomData.transformation_stage

      // Tooltip label
      const itemLabel = document.getElementById("tooltip-item-label")
      itemLabel.textContent = `${nodeLabel}`

      // *****************
      // * Info for node *
      // *****************
      const elemItemInfo = document.getElementById("tooltip-info-item")
      elemItemInfo.dataset.show = true

      const elemStockInfo = document.getElementById("tooltip-info-stock")
      elemStockInfo.dataset.show = false

      const itemInfoTitle = document.getElementById("item-info-title")
      itemInfoTitle.textContent = "Process info"

      // Table head for item info
      const tableHeadInfo = document.getElementById("tooltip-table-head-item-info")
      tableHeadInfo.replaceChildren()

      // Row for "Type"
      const rowType = document.createElement("tr")
      tableHeadInfo.appendChild(rowType)

      const rowTypeName = document.createElement("th")
      rowTypeName.textContent = "Type"
      rowType.appendChild(rowTypeName)

      const rowTypeValue = document.createElement("td")
      rowTypeValue.textContent = "Process"
      rowType.appendChild(rowTypeValue)

      // Row for "ID"
      const rowId = document.createElement("tr")
      tableHeadInfo.appendChild(rowId)

      const rowIdName = document.createElement("th")
      rowIdName.textContent = "ID"
      rowId.appendChild(rowIdName)

      const rowIdValue = document.createElement("td")
      rowIdValue.textContent = nodeId
      rowId.appendChild(rowIdValue)

      // Row for "Transformation stage"
      const rowTransformationStage = document.createElement("tr")
      tableHeadInfo.appendChild(rowTransformationStage)

      const rowTransformationStageName = document.createElement("th")
      rowTransformationStageName.textContent = "Transformation stage"
      rowTransformationStage.appendChild(rowTransformationStageName)

      const rowTransformationStageValue = document.createElement("td")
      rowTransformationStageValue.textContent = nodeTransformationStage
      rowTransformationStage.appendChild(rowTransformationStageValue)

      // Show this row only if process has stock
      if (nodeCustomData.has_stock) {
        const tableHeadStock = document.getElementById("tooltip-table-head-stock-info")
        tableHeadStock.replaceChildren()

        const elemStockInfo = document.getElementById("tooltip-info-stock")
        elemStockInfo.dataset.show = true

        const stock = nodeCustomData.stock
        const stockDistributionType = stock.distribution_type
        const stockLifetime = stock.lifetime

        // Row for "Has stock"
        const rowStockType = document.createElement("tr")
        tableHeadStock.appendChild(rowStockType)

        // Stock type
        const rowStockTypeName = document.createElement("th")
        rowStockTypeName.textContent = "Stock distribution type"
        rowStockType.appendChild(rowStockTypeName)

        const rowStockTypeValue = document.createElement("td")
        rowStockTypeValue.textContent = `${stockDistributionType}`
        rowStockType.appendChild(rowStockTypeValue)

        // Stock lifetime
        const rowStockLifetime = document.createElement("tr")
        tableHeadStock.appendChild(rowStockLifetime)

        const rowStockLifetimeName = document.createElement("th")
        rowStockLifetimeName.textContent = "Stock lifetime"
        rowStockLifetime.appendChild(rowStockLifetimeName)

        const rowStockLifetimeValue = document.createElement("td")
        rowStockLifetimeValue.textContent = `${stockLifetime}`
        rowStockLifetime.appendChild(rowStockLifetimeValue)
      }

      // ***********
      // * Inflows *
      // ***********
      // Inflows table head
      const tableHeadInflows = document.getElementById("tooltip-table-head-inflows")
      tableHeadInflows.replaceChildren()

      const rowHeadInflows = document.createElement("tr")
      tableHeadInflows.appendChild(rowHeadInflows)

      const colHeadInflowsProcessName = document.createElement("th")
      colHeadInflowsProcessName.textContent = "Process"
      rowHeadInflows.appendChild(colHeadInflowsProcessName)

      const colHeadInflowsBaselineValue = document.createElement("th")
      colHeadInflowsBaselineValue.textContent = "Baseline value"
      rowHeadInflows.appendChild(colHeadInflowsBaselineValue)

      const colHeadInflowsUnit = document.createElement("th")
      colHeadInflowsUnit.textContent = "Unit"
      rowHeadInflows.appendChild(colHeadInflowsUnit)

      // Inflows table body
      const tableBodyInflows = document.getElementById("tooltip-table-body-inflows")
      tableBodyInflows.replaceChildren()

      // Populate inflows
      const inflows = elem.targetLinks
      const numInflows = inflows.length
      let totalInflows = 0.0
      if (!numInflows) {
        const rowBodyInflows = document.createElement("tr")
        tableBodyInflows.appendChild(rowBodyInflows)

        const dataProcessName = document.createElement("td")
        dataProcessName.textContent = "No inflows"
        dataProcessName.setAttribute("colspan", 3)
        dataProcessName.style.fontWeight = "bold"
        dataProcessName.style.textAlign = "center"
        rowBodyInflows.appendChild(dataProcessName)
      } else {
        for (const flow of inflows) {
          const sourceProcess = flow.source
          const value = formatValue(flow.value)
          totalInflows += parseFloat(value)

          const rowBodyInflows = document.createElement("tr")
          tableBodyInflows.appendChild(rowBodyInflows)

          const dataProcessName = document.createElement("td")
          dataProcessName.textContent = sourceProcess.label
          rowBodyInflows.appendChild(dataProcessName)

          const dataBaselineValue = document.createElement("td")
          dataBaselineValue.textContent = value
          rowBodyInflows.appendChild(dataBaselineValue)

          const dataBaselineUnitName = document.createElement("td")
          dataBaselineUnitName.textContent = globals.getScenarioBaselineUnitName()
          rowBodyInflows.appendChild(dataBaselineUnitName)
        }
      }


      // ************
      // * Outflows *
      // ************
      // Outflows table head
      const tableHeadOutflows = document.getElementById("tooltip-table-head-outflows")
      tableHeadOutflows.replaceChildren()

      const rowHeadOutflows = document.createElement("tr")
      tableHeadOutflows.appendChild(rowHeadOutflows)

      const colHeadOutflowsProcessName = document.createElement("th")
      colHeadOutflowsProcessName.textContent = "Process"
      rowHeadOutflows.appendChild(colHeadOutflowsProcessName)

      const colHeadOutflowsBaselineValue = document.createElement("th")
      colHeadOutflowsBaselineValue.textContent = "Baseline value"
      rowHeadOutflows.appendChild(colHeadOutflowsBaselineValue)

      const colHeadOutflowsUnit = document.createElement("th")
      colHeadOutflowsUnit.textContent = "Unit"
      rowHeadOutflows.appendChild(colHeadOutflowsUnit)

      // Outflows table body
      const tableBodyOutflows = document.getElementById("tooltip-table-body-outflows")
      tableBodyOutflows.replaceChildren()

      // Populate outflows
      const outflows = elem.sourceLinks
      const numOutflows = outflows.length
      let totalOutflows = 0.0
      if (!numOutflows) {
        const rowBodyOutflows = document.createElement("tr")
        tableBodyOutflows.appendChild(rowBodyOutflows)

        const dataProcessName = document.createElement("td")
        dataProcessName.textContent = "No outflows"
        dataProcessName.setAttribute("colspan", 3)
        dataProcessName.style.fontWeight = "bold"
        dataProcessName.style.textAlign = "center"
        rowBodyOutflows.appendChild(dataProcessName)
      } else {
        for (const flow of outflows) {
          const sourceProcess = flow.target
          const value = formatValue(flow.value)
          totalOutflows += parseFloat(value)

          const rowBodyOutflows = document.createElement("tr")
          tableBodyOutflows.appendChild(rowBodyOutflows)

          const dataProcessName = document.createElement("td")
          dataProcessName.textContent = sourceProcess.label
          rowBodyOutflows.appendChild(dataProcessName)

          const dataBaselineValue = document.createElement("td")
          dataBaselineValue.textContent = value
          rowBodyOutflows.appendChild(dataBaselineValue)

          const dataBaselineUnitName = document.createElement("td")
          dataBaselineUnitName.textContent = globals.getScenarioBaselineUnitName()
          rowBodyOutflows.appendChild(dataBaselineUnitName)
        }
      }

      // Total inflows
      const nodeTotalInflowsValue = document.getElementById("tooltip-total-inflows-value")
      if (!numInflows) {
        nodeTotalInflowsValue.textContent = "No inflows"
      } else {
        nodeTotalInflowsValue.textContent = formatValue(totalInflows)
      }

      const nodeTotalInflowsUnit = document.getElementById("tooltip-total-inflows-unit")
      if (!numInflows) {
        nodeTotalInflowsUnit.textContent = ""
      } else {
        nodeTotalInflowsUnit.textContent = globals.getScenarioBaselineUnitName()
      }

      // Total outflows
      const nodeTotalOutflowsValue = document.getElementById("tooltip-total-outflows-value")
      if (!numOutflows) {
        nodeTotalOutflowsValue.textContent = "No outflows"
      } else {
        nodeTotalOutflowsValue.textContent = formatValue(totalOutflows)
      }

      const nodeTotalOutflowsUnit = document.getElementById("tooltip-total-outflows-unit")
      if (!numOutflows) {
        nodeTotalOutflowsUnit.textContent = ""
      } else {
        nodeTotalOutflowsUnit.textContent = globals.getScenarioBaselineUnitName()
      }


      // Total node evaluated value
      const nodeEvaluatedValue = document.getElementById("tooltip-node-evaluated-value")
      nodeEvaluatedValue.textContent = formatValue(nodeValue)

      const nodeEvaluatedValueUnit = document.getElementById("tooltip-node-evaluated-value-unit")
      nodeEvaluatedValueUnit.textContent = globals.getScenarioBaselineUnitName()

      // Show tooltip
      const tooltip = document.getElementById("tooltip")
      tooltip.style.left = `${pos.x}px`
      tooltip.style.top = `${pos.y}px`
      tooltip.dataset.show = true

      const tooltipBodySectionNode = document.getElementById("tooltip-body-section-node")
      const tooltipBodySectionLink = document.getElementById("tooltip-body-section-link")
      tooltipBodySectionNode.dataset.show = true
      tooltipBodySectionLink.dataset.show = false

      adjustTooltipToSafePosition()
    }

    function showLinkTooltip(elem, event) {
      const pos = { x: event.clientX + 10, y: event.clientY }

      // Get node custom data for current year
      const yearData = globals.getCurrentYearData()
      const linkIndex = elem.index
      const linkValue = elem.value
      const linkCustomData = elem.customdata

      const sourceNodeId = elem.source.customdata.node_id
      const targetNodeId = elem.target.customdata.node_id
      const sourceNodeLabel = elem.source.label
      const targetNodeLabel = elem.target.label
      const linkLabel = `${sourceNodeLabel} -> ${targetNodeLabel}`
      const linkId = `${sourceNodeId} -> ${targetNodeId}`

      // Tooltip label
      const itemLabel = document.getElementById("tooltip-item-label")
      itemLabel.textContent = `${linkLabel}`

      // *****************
      // * Info for link *
      // *****************
      const elemItemInfo = document.getElementById("tooltip-info-item")
      elemItemInfo.dataset.show = true

      const elemStockInfo = document.getElementById("tooltip-info-stock")
      elemStockInfo.dataset.show = false

      const itemInfoTitle = document.getElementById("item-info-title")
      itemInfoTitle.textContent = "Flow info"

      // Table head for item info
      const tableHeadInfo = document.getElementById("tooltip-table-head-item-info")
      tableHeadInfo.replaceChildren()

      // Row for "Type"
      const rowType = document.createElement("tr")
      tableHeadInfo.appendChild(rowType)

      const rowTypeName = document.createElement("th")
      rowTypeName.textContent = "Type"
      rowType.appendChild(rowTypeName)

      const rowTypeValue = document.createElement("td")
      rowTypeValue.textContent = linkCustomData.is_virtual ? "Virtual flow" : "Flow"
      rowType.appendChild(rowTypeValue)

      // Row for "ID"
      const rowId = document.createElement("tr")
      tableHeadInfo.appendChild(rowId)

      const rowIdName = document.createElement("th")
      rowIdName.textContent = "ID"
      rowId.appendChild(rowIdName)

      const rowIdValue = document.createElement("td")
      rowIdValue.textContent = linkId
      rowId.appendChild(rowIdValue)

      // Table header for flow
      const tableHeadLink = document.getElementById("tooltip-table-head-link")
      tableHeadLink.replaceChildren()

      const rowHead = document.createElement("tr")
      tableHeadLink.appendChild(rowHead)

      // Indicator name
      const headIndicatorName = document.createElement("th")
      headIndicatorName.textContent = "Indicator"
      rowHead.appendChild(headIndicatorName)

      // Indicator name
      const headIndicatorValue = document.createElement("th")
      headIndicatorValue.textContent = "Value"
      rowHead.appendChild(headIndicatorValue)

      // Unit
      const headIndicatorUnit = document.createElement("th")
      headIndicatorUnit.textContent = "Unit"
      rowHead.appendChild(headIndicatorUnit)

      // Table body for flow
      const tableBodyLink = document.getElementById("tooltip-table-body-link")
      tableBodyLink.replaceChildren()

      // Create headers for indicator names (baseline unit, indicators)
      const baselineValueName = linkCustomData.baseline_value_name
      const baselineUnitName = linkCustomData.baseline_unit_name
      const indicatorNames = [baselineValueName, ...linkCustomData.indicator_names]
      const indicatorUnits = [baselineUnitName, ...linkCustomData.indicator_units]
      const indicatorsValues = linkCustomData.evaluated_indicator_values

      // Remove any indicator that has too small value
      let smallestValidIndicatorValue = 0.01
      let indicesToRemove = []
      if (indicatorsValues.length > 1) {
        for (let i = 1; i < indicatorsValues.length; i++) {
          if (indicatorsValues[i] < smallestValidIndicatorValue) {
            indicesToRemove.push(i)
          }
        }
      }

      const indicators = []
      for (let i = 0; i < indicatorNames.length; i++) {
        const entry = {
          name: indicatorNames[i],
          value: indicatorsValues[i],
          unit: indicatorUnits[i],
        }
        indicators.push(entry)
      }

      // Remove indicators that do not have enough flow
      if (indicesToRemove.length > 0) {
        const newIndicators = []
        const set = new Set(indicesToRemove)
        for (const [index, elem] of indicators.entries()) {
          if (!set.has(index)) {
            newIndicators.push(indicators[index])
          }
        }

        // Replace existing indicators
        indicators.length = 0
        for (const elem of newIndicators) {
          indicators.push(elem)
        }
      }

      for (const indicator of indicators) {
        const rowBody = document.createElement("tr")
        tableBodyLink.appendChild(rowBody)

        const dataName = document.createElement("td")
        dataName.textContent = indicator.name
        rowBody.appendChild(dataName)

        const dataValue = document.createElement("td")
        dataValue.textContent = formatValue(indicator.value)
        rowBody.appendChild(dataValue)

        const dataUnit = document.createElement("td")
        dataUnit.textContent = indicator.unit
        rowBody.appendChild(dataUnit)
      }



      // Flow evaluated value
      const linkEvaluatedValue = document.getElementById("tooltip-link-evaluated-value")
      linkEvaluatedValue.textContent = formatValue(linkValue)

      const linkEvaluatedValueUnit = document.getElementById("tooltip-link-evaluated-value-unit")
      linkEvaluatedValueUnit.textContent = globals.getScenarioBaselineUnitName()

      const tooltip = document.getElementById("tooltip")
      tooltip.style.left = `${pos.x}px`
      tooltip.style.top = `${pos.y}px`
      tooltip.dataset.show = true

      const tooltipBodySectionNode = document.getElementById("tooltip-body-section-node")
      const tooltipBodySectionLink = document.getElementById("tooltip-body-section-link")
      tooltipBodySectionNode.dataset.show = false
      tooltipBodySectionLink.dataset.show = true

      adjustTooltipToSafePosition()
    }

    function adjustTooltipToSafePosition() {
      const tooltip = document.getElementById("tooltip")

      // Move tooltip to other side horizontally or vertically if
      // tooltip would go over window edges
      const tooltipRect = tooltip.getBoundingClientRect()
      const safePad = { x: 10, y: 10 }
      const offsetX = tooltipRect.x + tooltipRect.width - window.innerWidth
      const offsetY = tooltipRect.y + tooltipRect.height - window.innerHeight
      if (offsetX > -safePad.x) {
        const newPosX = tooltipRect.x - (safePad.x * 2) - tooltipRect.width
        tooltip.style.left = `${newPosX}px`
      }

      if (offsetY > -safePad.y) {
        const newPosY = tooltipRect.y - safePad.y - tooltipRect.height
        tooltip.style.top = `${newPosY}px`
      }
    }

    function hideTooltip() {
      const tooltip = document.getElementById("tooltip")
      tooltip.dataset.show = false
    }

    function initProgressOverlay(numTotalSteps) {
      const elem = document.getElementById("progress-text")
      elem.dataset.current = 0
      elem.dataset.total = numTotalSteps
    }

    function updateProgressOverlay(numProcessedSteps, text = "") {
      const elem = document.getElementById("progress-text")
      const prevCurrent = parseInt(elem.dataset.current)
      const total = parseInt(elem.dataset.total)
      const newCurrent = prevCurrent + numProcessedSteps
      elem.dataset.current = newCurrent

      const progressPercent = ((newCurrent / total) * 100.0).toFixed(0)
      elem.textContent = `Building visualizations ${progressPercent}%${text}`
    }

    function hideProgressOverlay(id = "progress-text") {
      const elem = document.getElementById(id)
    }

    function clamp(val, min = 0.001, max = 0.999) {
      if (val < min) {
        val = min
        return val
      }

      if (val > max) {
        val = max
        return val
      }

      return val
    }

    function formatValue(val) {
      const valueAsInt = parseInt(val)
      const valueAsFloat = parseFloat(val)
      const diff = Math.abs(valueAsInt - valueAsFloat)
      if (diff < globals.settings.formatValueEps) {
        return valueAsInt
      }

      let formattedValue = parseFloat(val).toFixed(globals.settings.numDecimalPlaces)
      return formattedValue
    }

    function formatPosition(val) {
      return parseFloat(val).toFixed(globals.settings.numDecimalPlaces)
    }

    function formatBool(val) {
      // Convert string/bool to "Yes" or "No"
      return JSON.parse(val) == true ? "Yes" : "No"
    }

    // ***************
    // * GLOBAL INIT *
    // ***************
    async function globalInit() {
      // Set image sources
      const elem = document.getElementById("logo")
      elem.src = logoData

      const e = document.getElementById("logo-loading")
      e.src = logoData

      // Sleep for awhile to allow images to load
      await sleep(10)

      globals.init = true
      parseRawData()
      // await buildVisualizationData()
      await buildAllScenarioVisualizationData()
      init()
      globals.init = false

      // Initialize windows
      initWindows()
      initTabs()
    }
  </script>
</head>

<body onload="globalInit()">
  <!-- Logo -->
  <a href="https://github.com/EuropeanForestInstitute/aiphoria">
    <img id="logo" class="logo top-right" />
  </a>

  <!-- Container for toasts -->
  <div id="toast"></div>

  <!-- Button to toggle menu -->
  <!-- <span class="button-toggle-menu" onclick="toggleMenu()">&#9776</span> -->

  <div class="global-menu-wrapper">
    <div class="menu-buttons-wrapper">
      <div id="button-settings" class="menu-button" onclick="toggleWindow('window-settings')" data-show="false">
        <i class="icon icon-menu icon-1x"></i>
        <span>Settings</span>
      </div>

      <div id="button-tools" class="menu-button" onclick="toggleWindow('window-tools')" data-show="false">
        <i class="icon icon-menu icon-1x"></i>
        <span>Tools</span>
      </div>

      <div id="button-data" class="menu-button" onclick="toggleWindow('window-data')" data-show="false">
        <i class="icon icon-menu icon-1x"></i>
        <span>Data</span>
      </div>

      <div id="button-scenario" class="menu-button" onclick="toggleWindow('window-scenario')" data-show="false">
        <i class="icon icon-menu icon-1x"></i>
        <span>Scenario</span>
      </div>
    </div>

    <div class="menu-windows-wrapper">
      <div id="window-settings" class="menu-window" data-show="false">
        <div class="menu-window-title">
          Settings
          <span onclick="toggleWindow('window-settings', false)" class="menu-window-controls" data-variant="close">
            <i class="icon icon-close">
            </i>
          </span>
        </div>
        <div class="menu-window-content">
          <!-- Show virtual processes -->
          <div class="menu-item-wrapper">
            <div class="menu-item-title">
              <label for="showVirtualProcesses">Show virtual processes</label>
            </div>
            <div class="menu-item-content">
              <select id="showVirtualProcesses" name="showVirtualProcesses">
                <option value="yes" selected>Yes</option>
                <option value="no">No</option>
              </select>
            </div>
          </div>

          <!-- Show process labels / IDs -->
          <div class="menu-item-wrapper">
            <div class="menu-item-title">
              <label for="showProcessLabel">Show process labels</label>
            </div>
            <div class="menu-item-content">
              <select id="showProcessLabel" name="showProcessLabel">
                <option value="yes" selected>Yes (use process label)</option>
                <option value="no">No (use process ID)</option>
              </select>
            </div>
          </div>

          <!-- Sankey graph font size -->
          <div class="menu-item-wrapper">
            <div class="menu-item-title">
              <label for="showProcessLabel">Sankey graph font size</label>
            </div>
            <div class="menu-item-content">
              <input id="sankey-font-size" type="input" value="12" placeholder="Default font size: 12"
                onchange="onFontSizeChanged(event)" />
            </div>
          </div>

          <!-- Normalized process positions -->
          <div class="menu-item-wrapper">
            <div class="menu-item-title">
              <label>Process normalized positions</label>
            </div>
            <div class="menu-item-content">
              <table class="tooltip-table">
                <thead>
                  <tr>
                    <th>ID</th>
                    <th>Label</th>
                    <th>X</th>
                    <th>Y</th>
                  </tr>
                </thead>
                <tbody id="process-info-body">
                </tbody>
              </table>
              <br />
            </div>
          </div>

          <!-- Apply positions to all years / copy to clipboard -->
          <div class="menu-item-wrapper">
            <div class="menu-item-title">
              <label>Actions</label>
            </div>
            <div class="menu-item-content">
              <div class="menu-actions-wrapper">
                <button onclick="applyPositionsToAllYears()">
                  <i class="icon icon-share" style="margin-right: 0.5rem">
                  </i>
                  <span>Apply positions to all years</span>
                </button>
                <button onclick="copyPositionsToClipboard()" style="padding: 4px; vertical-align: middle">
                  <div>
                    <i class="icon icon-copy" style="margin-right: 0.5rem">
                    </i>
                    <span>Copy all positions to clipboard</span>
                  </div>
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="window-tools" class="menu-window" data-show="false">
        <div class="menu-window-title">
          Tools
          <span onclick="toggleWindow('window-tools', false)" class="menu-window-controls" data-variant="close">
            <i class="icon icon-close">
            </i>
          </span>
        </div>
        <div class="menu-window-content">
          <!-- Sankey chart arrangement mode -->
          <div class="menu-item-wrapper">
            <div class="menu-item-title">
              <label for="arrangementMode">Arrangement mode</label>
            </div>
            <div class="menu-item-content">
              <select id="arrangementMode" name="arrangementMode" onchange="useArrangementMode(event)">
                <option value="freeform" selected>Freeform</option>
                <option value="perpendicular">Perpendicular</option>
              </select>
            </div>
          </div>
        </div>
      </div>

      <div id="window-data" class="menu-window" data-show="false">
        <div class="menu-window-title">
          Data
          <span onclick="toggleWindow('window-data', false)" class="menu-window-controls" data-variant="close">
            <i class="icon icon-close">
            </i>
          </span>
        </div>
        <div class="menu-window-content">
          <div class="tabs-wrapper">
            <div id="tab-processes" class="tab-item" onclick="toggleTab(event, 'tab-processes')" data-show="false">
              Processes
            </div>
            <div id="tab-flows" class="tab-item" onclick="toggleTab(event, 'tab-flows')" data-show="false">
              Flows
            </div>
            <div id="tab-stocks" class="tab-item" onclick="toggleTab(event, 'tab-stocks')" data-show="false">
              Stocks
            </div>
          </div>

          <!-- Process-tab contents -->
          <!-- Processes -->
          <div id="tab-content-processes" class="tab-item-content" data-show="false">
            <div class="tab-item-content-wrapper">
              <div class="table-wrapper">
                <div>
                  <!-- <i class="icon icon-search icon-1x"></i> -->
                  <input id="search-processes" type="input" placeholder="Search for process ID..."
                    oninput="filterProcesses(event)" onkeydown="event.key == 'Escape' ? filterProcesses(null): ''" />
                  <button onclick="clearFilterProcesses(event)">Clear</button>
                </div>

                <div class="tab-table-wrapper">
                  <table id="table-data" class="tab-table">
                    <thead id="table-data-head">
                    </thead>
                    <tbody id="table-data-body">
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>

          <!-- Flows -->
          <div id="tab-content-flows" class="tab-item-content" data-show="false">
            <div class="tab-item-content-wrapper">
              <div class="table-wrapper">
                <div>
                  <!-- <i class="icon icon-search icon-1x"></i> -->
                  <input id="search-flows" type="input" placeholder="Search for flow IDs..."
                    oninput="filterFlows(event)" onkeydown="event.key == 'Escape' ? filterFlows(null): ''" />
                  <button onclick="clearFilterFlows(event)">Clear</button>
                </div>

                <div class="tab-table-wrapper">
                  <table id="table-flows" class="tab-table">
                    <thead id="table-flows-head">
                    </thead>
                    <tbody id="table-flows-body">
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>

          <!-- Stocks -->
          <div id="tab-content-stocks" class="tab-item-content" data-show="false">
            <div class="tab-item-content-wrapper">
              <div class="table-wrapper">
                <div>
                  <!-- <i class="icon icon-search icon-1x"></i> -->
                  <input id="search-stocks" type="input" placeholder="Search for stock IDs..."
                    oninput="filterStocks(event)" onkeydown="event.key == 'Escape' ? filterStocks(null): ''" />
                  <button onclick="clearFilterStocks(event)">Clear</button>
                </div>

                <div class="tab-table-wrapper">
                  <table id="table-stocks" class="tab-table">
                    <thead id="table-stocks-head">
                    </thead>
                    <tbody id="table-stocks-body">
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>

        </div>
      </div>

      <div id="window-scenario" class="menu-window" data-show="false">
        <div class="menu-window-title">
          Scenario
          <span onclick="toggleWindow('window-scenario', false)" class="menu-window-controls" data-variant="close">
            <i class="icon icon-close">
            </i>
          </span>
        </div>
        <div class="menu-window-content">
          <div class="menu-item-wrapper">
            <div class="menu-item-title">
              <label for="select-scenario">Selected scenario</label>
            </div>
            <div class="menu-item-content">
              <select id="select-scenario" name="select-scenario" onchange="onScenarioChanged(event)">
              </select>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Menu wrapper -->
  <div id="menu-wrapper" class="menu-wrapper" data-show="false">
    <!-- Menu control wrapper -->
    <div onmousedown="moveMenuStart(event)" class="menu-wrapper-controls-wrapper">
      <span onclick="toggleMenu(false)" class="menu-wrapper-controls" data-variant="close">
        <i class="icon icon-close">
        </i>
      </span>
    </div>
  </div>

  <!-- Overlay for loading -->
  <div id="overlay-wrapper" class="overlay-wrapper">
    <div class="overlay-row-wrapper">
      <div style="display: flex; justify-content: center; margin-bottom: 1rem">
        <img id="logo-loading" class="logo" />
      </div>
      <div id="loader" class="loader-wrapper">
        <span class="loader"></span>
      </div>
      <h4 id="progress-text"></h4>
    </div>
  </div>

  <!-- Element for Plotly -->
  <div id="plotly"></div>

  <!-- Tooltip -->
  <div id="tooltip" class="tooltip-wrapper" data-show="false">
    <!-- Tooltip title -->
    <div class="tooltip-title">
      <span id="tooltip-item-label">Item label here</span><br>
    </div>
    <br />

    <!-- Tooltip info -->
    <div id="tooltip-info" class="tooltip-info-wrapper">
      <div class="tooltip-info-row">
        <div id="tooltip-info-item" class="tooltip-info-col" data-show="false">
          <span id="item-info-title" class="tooltip-table-title">Info</span>
          <table class="tooltip-table">
            <thead id="tooltip-table-head-item-info">
            </thead>
          </table>
        </div>

        <!-- Process stock info (if hovering over process with stock) -->
        <div id="tooltip-info-stock" class="tooltip-info-col" data-show="false">
          <span id="stock-info-title" class="tooltip-table-title">Stock info</span>
          <table class="tooltip-table">
            <thead id="tooltip-table-head-stock-info">
            </thead>
          </table>
        </div>
      </div>
    </div>

    <br />

    <!-- Tooltip body -->
    <div id="tooltip-body" class="tooltip-body-wrapper" data-show="true">
      <!-- Node section -->
      <div id="tooltip-body-section-node" class="tooltip-body-section" data-show="false">
        <!-- Node info row -->
        <div class="tooltip-section-row">
          <div class="tooltip-content-grid">
            <div class="tooltip-content-grid-elem">
              <div class="tooltip-section-col">
                <span class="tooltip-table-title">Inflows</span>
                <table id="tooltip-table-inflows" class="tooltip-table">
                  <thead id="tooltip-table-head-inflows">
                  </thead>
                  <tbody id="tooltip-table-body-inflows">
                  </tbody>
                </table>
              </div>
            </div>

            <div class="tooltip-content-grid-elem">
              <span class="tooltip-table-title">Outflows</span>
              <table id="tooltip-table-outflows" class="tooltip-table">
                <thead id="tooltip-table-head-outflows">
                </thead>
                <tbody id="tooltip-table-body-outflows">
                </tbody>
              </table>
            </div>

            <div class="tooltip-content-grid-elem">
              <span class="tooltip-table-title">Total inflows</span><br />
              <span id="tooltip-total-inflows-value">123</span>
              <span id="tooltip-total-inflows-unit">Mm3</span>
            </div>

            <div class="tooltip-content-grid-elem">
              <span class="tooltip-table-title">Total outflows</span><br />
              <span id="tooltip-total-outflows-value">123</span>
              <span id="tooltip-total-outflows-unit">Mm3</span>
            </div>
          </div>
        </div>

        <br />

        <!-- Node total row -->
        <div class="tooltip-section-row">
          <div class="tooltip-section-col">
            <span class="tooltip-table-title">Evaluated value (baseline)</span><br />
            <span id="tooltip-node-evaluated-value" class="tooltip-evaluated-value">123</span>
            <span id="tooltip-node-evaluated-value-unit" class="tooltip-evaluated-value-unit">Mm3</span>
          </div>
        </div>
      </div>

      <!-- Flow section -->
      <div id="tooltip-body-section-link" class="tooltip-body-section" data-show="true">
        <!-- Flow info row -->
        <div class="tooltip-section-row">
          <div id="tooltip-body-col-link" class="tooltip-section-col">
            <span class="tooltip-table-title">Indicator values</span>
            <table id="tooltip-table-link" class="tooltip-table">
              <thead id="tooltip-table-head-link">
              </thead>
              <tbody id="tooltip-table-body-link">
              </tbody>
            </table>
          </div>
        </div>
        <br />

        <!-- Flow total row -->
        <div class="tooltip-section-row">
          <div class="tooltip-section-col">
            <span class="tooltip-table-title">Evaluated value (baseline)</span><br />
            <span id="tooltip-link-evaluated-value" class="tooltip-evaluated-value">123</span>
            <span id="tooltip-link-evaluated-value-unit" class="tooltip-evaluated-value-unit">Mm3</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Context menu -->
  <div id="context-menu-overlay" class="context-menu-overlay" data-show="false"></div>
  <div id="context-menu" class="context-menu" data-show="false">
  </div>

  <!-- Info window -->
  <div id="info-window-wrapper" class="info-window-wrapper" data-show="false">
    <div id="info-window" class="info-window">
    </div>
    <!-- <i class="icon icon-close icon-1x"></i> -->
    <button onclick="closeInfoWindow()">
      Close window
    </button>
  </div>
</body>

</html>